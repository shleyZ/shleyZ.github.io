[{"title":"NATAPP内网穿透与 webpack 一同食用出现invalid host header 问题","date":"2018-08-05T12:05:19.000Z","path":"2018/08/05/NATAPP内网穿透/","text":"disableHostCheck: true 在webpack配置文件中加入以上。","tags":[]},{"title":"node 版本升级","date":"2018-07-29T06:02:01.000Z","path":"2018/07/29/node版本升级/","text":"首先：查看当前node版本：node –v 安装n模块：npm install -g n 升级到指定版本/最新版本（该步骤可能需要花费一些时间）升级之前，可以执行n ls （查看可升级的版本）如： n 6.9.1 或者你也可以告诉管理器，安装最新的稳定版本 n stable 安装完成后，查看Node的版本，检查升级是否成功node -v","tags":[]},{"title":".net","date":"2018-07-19T06:14:24.000Z","path":"2018/07/19/net/","text":"","tags":[]},{"title":"Nginx 安装使用","date":"2018-04-20T05:11:12.000Z","path":"2018/04/20/nginx centOS/","text":"nginx基本操作安装： yum install nginx 启动： service nginx start 停止： service nginx stop 重载： service nginx reload 部署NGINX：// $ sudo service httpd stop $ sudo yum install nginx 查看是否启动： $ ps -ef | grep nginx 启动： $ sudo service nginx start $ sudo service nginx reload firewall-cmd --zone=public --add-port=80/tcp --permanent 防火墙开启80端口 firewall-cmd --reload 防火墙重载 yum install iptables-services systemctl enable iptables systemctl stop firewalld systemctl start firewalld 配置/etc/nginx/下的配置文件： 因为在nginx主配置文件中引入了conf.d文件夹中的: include /etc/nginx/conf.d/*.conf;所以在nginx/conf.d/下面添加**.conf文件进行配置. 主配置文件如下： # For more information on configuration, see: # * Official English Documentation: http://nginx.org/en/docs/ # * Official Russian Documentation: http://nginx.org/ru/docs/ user root; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; # Load dynamic modules. See /usr/share/nginx/README.dynamic. include /usr/share/nginx/modules/*.conf; events { worker_connections 1024; } http { log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; server { listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } } 首先主配置文件，修改用户组 user root; 2.然后进行操作： cd conf.d touch ******.conf //新建文件 vim ******.conf 修改**.conf: server { listen 80; server_name 47.**.***.**; #charset koi8-r; #access_log logs/host.access.log main; location / { root /home/********/****; index index.html index.htm; try_files $uri /index.html; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } react-router在nginx上的应用，参照：调整nginx正确服务react-router应用 注意在linux进行解压文件时unrar e build.rar build 这样会把build.rar里面所有的文件都解压到build文件夹，不保持原有的目录。 unrar x build.rar build 这样解压会保持原有的目录。","tags":[]},{"title":"Linux使用","date":"2018-04-20T05:11:12.000Z","path":"2018/04/20/linux操作/","text":"软件操作软件包管理 yum 安装 yum install ... 卸载 yum remove ... 搜索 yum serach ... 清理缓存 yum clean packages 列出已安装 yum list 软件包信息 yum info ... 硬件资源信息 内存 free -m 硬盘 df -h 负载（w或top） w 12:53:49 up 2:33, 3 users, load average: 0.00, 0.01, 0.05 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT root tty2 10:32 1:59m 0.04s 0.04s -bash root pts/0 121.239.246.23 11:34 1:13m 0.01s 0.01s -bash root pts/1 121.239.246.23 12:24 5.00s 0.02s 0.00s w load average: 0.00, 0.01, 0.05 分别表示最近1分钟，5分钟，15分钟时候的负载值 当到达1时说明负载快要超荷。0.6-0.7是健康值。 cpu个数和核数 cat /proc/cpuinfo 文件操作####目录结构 根目录/ 家目录 /home 临时目录 /tmp 配置目录 /etc 用户程序目录 /usr ####文件基本操作 touch --新建文件 rm --删除文件和目录 cp --复制 mv --移动 pwd --显示路径 ####vim gg--定位到行头 G--定位到行尾 dd--删除整行 u--恢复 ####文件权限421 r--4 可读 w--2 可写 x--1 可执行 ####文件搜索，查找 tail--从尾部开始读 head--从头部开始读 cat--读取整个文件 more--分页读取 less--可控分页 grep--搜索关键字 find--查找文件 wc--统计个数 find . -name &quot;*.conf&quot; --查找当前路径下以conf后缀的文件 find . -type f --查找当前路径下的文件 find . -type d --查找当前路径下的文件夹 find . -ctime -20 --查找20天内更新过的文件 文件压缩和解压tar和untar把zxl文件压缩为zxl.tar： tar -cf zxl.tar zxl 查看zxl.tar里面的内容： tar -tf zxl.tar 查看zxl.tar里面的详细内容： tar -tvf zxl.tar 把zxl.tar解压： tar -xf zxl.tar 系统用户操作命令添加用户cd /home/ useradd zhaolin 这时查看home里面会多了一个文件夹zhaolin 给zhaolin用户添加密码： passwd zhaolin 输入密码并确认密码。 这样就有了一个新的用户zhaolin，可以用ssh用zhaolin用户连接。 删除用户userdel zhaolin --删除用户zhaolin rm -rf zhaolin --删除用户zhaolin目录 userdel -r zhaolin --彻底删除用户以及用户文件夹 防火墙操作作用：保护服务器安全 安装： yum install firewalld 启动： service firewalld started 启动： service firewalld restarted 列出防火墙服务： yum list | grep firewall 查看是否启动防火墙： ps -ef|grep firewall 停止： service firewalld stop service firewalld status 提权root账号中 visudo 修改： ## Allows people in group wheel to run all commands %wheel ALL=(ALL) ALL %zhaolin ALL=(ALL) ALL 在zhaolin用户进行操作以前，前面加上sudo即可 sudo yum install XXXXX 文件上传linux: scpscp zhaolin@47.96.140.xx:/tmp/abc.txt ./ 把服务器47.96.140.xx上tmp里面的文件传到本地当前目录 scp abc.txt zhaolin@47.96.140.xx:/tmp 把本地当前目录的文件上传到服务器47.96.140.xx上tmp windows xshell 首先xshell连接linux， 然后再linux服务器上安装： yum install lrzsz 装好以后执行命令： rz 会出现弹框： 选择文件并上传即可 文件下载wget XXXXX","tags":[]},{"title":"SSH连接","date":"2018-04-20T05:11:12.000Z","path":"2018/04/20/SSH连接/","text":"服务器端安装SSH安装SSH： yum install openssh-server 启动SSH： sevice sshd start 设置开机运行： chkconfig sshd on 或 systemctl enable sshd.service 客户端SSH连接服务器端SSH本地命令行l： ssh root@server_ip 回车输入密码连接。 SSH config config方便批量管理多个ssh config存放在 ~/.ssh/config config语法 cd ~/.ssh/ vim config 编辑： host &quot;zhu&quot; HostName 47.96.140.** User root Port 22 同样可以配置多个host SSH免密码登录ssh key ssh key使用非对称加密方式生成公钥和私钥 私钥存放在本地~/.ssh目录 公钥可以对外开放，放在服务器的~/.ssh/authorized_keys linux生成秘钥 cd ~/.ssh/ ssh-keygen 然后输入文件名字输入密码确认密码 生成成功 Your identification has been saved in file_sra. Your public key has been saved in file_sra.pub. The key fingerprint is: SHA256:NrBxS72quC*************Mf54sqrl8tPwraeHYdKzg root@server The key&apos;s randomart image is: +---[RSA 2048]----+ | | | . | | o o . | | * . . | | . . S . | | . + o.o | | *.+oo+o. | | ==E==+== | | =@OO=*=oo. | +----[SHA256]-----+ [root@qyweb01 .ssh]# ls -al total 24 drwx------ 2 root root 4096 Apr 27 12:14 . dr-xr-x---. 5 root root 4096 Apr 27 12:02 .. -rw------- 1 root root 0 Apr 27 10:20 authorized_keys -rw-r--r-- 1 root root 67 Apr 27 11:52 config -rw-r--r-- 1 root root 174 Apr 27 11:58 known_hosts -rw------- 1 root root 1679 Apr 27 12:14 zxl_sra -rw-r--r-- 1 root root 394 Apr 27 12:14 zxl_sra.pub 把公钥 .pub 里面的内容复制到服务器 ~/.ssh/authorized_keys 这样就可以免密连接服务器 SSH设置安全端口ssh默认端口22 防止不法分子利用，最好修改默认端口 修改配置文件 /etc/ssh/sshd_config 的port部分， 然后重启服务 systemctl restart sshd.service 最好不要修改默认端口，而是使用复杂的密码，或者使用密钥登陆","tags":[]},{"title":"阿里云服务器nginx安装","date":"2018-04-20T05:11:12.000Z","path":"2018/04/20/nginx web服务器/","text":"阿里云服务器Linux远程ssh连接可以在创建 ECS 实例时分配密钥对，也可以为实例绑定密钥对。 一台 ECS 实例只能绑定一个 SSH 密钥对。 创建密钥对登录 ECS 控制台。 在左侧导航栏中，单击 密钥对。 在 密钥对 页面上，选择所需地域后，单击 创建密钥对。 在 创建密钥对 页面，设置密钥对名称，并选择 自动新建密钥对。 单击 确定 创建密钥对。 绑定密钥对登录 ECS 控制台。 在左侧导航栏中，选择 网络与安全 &gt; 密钥对。 选择一个地域。 找到需要操作的密钥对，在 操作 列中，单击 绑定密钥对。 在 绑定密钥对 对话框里，在 选择 ECS 实例 栏中，选中需要绑定该密钥对的 ECS 实例名称，单击 &gt;，移入 已选择 栏中。 单击 确定 绑定密钥对。 使用 SSH 密钥对连接 Linux 实例（本地为 Windows 环境）#####前提条件 已经下载并安装了 PuTTY 和 PuTTYgen。 PuTTY 和 PuTTYgen 的下载地址： PuTTY： https://the.earth.li/~sgtatham/putty/latest/w64/putty.exe PuTTYgen： https://the.earth.li/~sgtatham/putty/latest/w64/puttygen.exe 已经拥有一个分配了密钥对的 Linux 实例。可以在创建 ECS 实例时分配密钥对，也可以为实例绑定密钥对。 实例所在的安全组必须添加以下安全组规则（具体操作，请参考 https://help.aliyun.com/document_detail/51798.html?spm=a2c4g.11186623.4.2.4RBql5#windows） #####操作步骤 （可选）如果您正在使用阿里云生成的 .pem 私钥文件，应先按以下步骤转为 .ppk 私钥文件。如果您使用的私钥文件本身已经是 .ppk 文件，可以略过这一步。 启动 PuTTYgen。本示例中的 PuTTYgen 版本为 0.68。 在 Parameters &gt; Type of key to generate 中，选中 RSA。Number of bits in a generated key 的值不需要设置，软件会根据导入的私钥信息自动更新。 单击 Load。PuTTYgen 默认仅显示扩展名为 .ppk 的文件。要找到您的 .pem 文件，请选择显示所有类型的文件。 选择您从阿里云下载的“.pem”格式的私钥文件，然后单击 打开。 单击 OK（确定）关闭确认对话框。 单击 Save private key。PuTTYgen 会显示一条关于在没有口令的情况下保存密钥的警告，单击 是(Y)。 指定与密钥对相同的私钥名称，保存。PuTTY 会自动为文件添加 .ppk 扩展名。 启动 PuTTY。 单击 Connection &gt; SSH &gt; Auth，再单击 Browse…，选择前面所生成的 .ppk 文件。 单击 Session， 在 Host Name (or IP address) 里输入账号和需要连接的实例公网 IP 地址，格式为 “root@IP 地址”。 在 Port 里输入端口号 22； Connection type 选择 SSH。 单击 Open，开始连接您的 Linux 实例。 Ubuntu下搭建和配置Nginx Web服务器安装nginxapt-get update apt-get install nginx 启动nginxsystemctl start nginx systemctl status nginx -l systemctl enable nginx 停止nginxsystemctl stop nginx 测试：lsof -i:80 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME AliYunDun 898 root 18u IPv4 12980 0t0 TCP qyweb01:33654-&gt;140.205.140.205:http (CLOSE_WAIT) AliYunDun 934 root 18u IPv4 12980 0t0 TCP qyweb01:33654-&gt;140.205.140.205:http (CLOSE_WAIT) AliYunDun 934 root 21u IPv4 13271 0t0 TCP qyweb01:48738-&gt;106.11.68.13:http (ESTABLISHED) nginx 16177 root 6u IPv4 33583 0t0 TCP *:http (LISTEN) nginx 16177 root 7u IPv6 33584 0t0 TCP *:http (LISTEN) nginx 16178 www-data 6u IPv4 33583 0t0 TCP *:http (LISTEN) nginx 16178 www-data 7u IPv6 33584 0t0 TCP *:http (LISTEN) nginx 16179 www-data 6u IPv4 33583 0t0 TCP *:http (LISTEN) nginx 16179 www-data 7u IPv6 33584 0t0 TCP *:http (LISTEN) 看到如上的信息，说明nginx启动成功。 nginx配置文件全放在/etc/nginx 下面，用 ll 名令查看如下： root@qyweb01:/etc/nginx# ll total 64 drwxr-xr-x 6 root root 4096 Apr 26 12:47 ./ drwxr-xr-x 90 root root 4096 Apr 26 12:47 ../ drwxr-xr-x 2 root root 4096 Jul 12 2017 conf.d/ -rw-r--r-- 1 root root 1077 Feb 12 2017 fastcgi.conf -rw-r--r-- 1 root root 1007 Feb 12 2017 fastcgi_params -rw-r--r-- 1 root root 2837 Feb 12 2017 koi-utf -rw-r--r-- 1 root root 2223 Feb 12 2017 koi-win -rw-r--r-- 1 root root 3957 Feb 12 2017 mime.types -rw-r--r-- 1 root root 1462 Feb 12 2017 nginx.conf -rw-r--r-- 1 root root 180 Feb 12 2017 proxy_params -rw-r--r-- 1 root root 636 Feb 12 2017 scgi_params drwxr-xr-x 2 root root 4096 Apr 26 12:47 sites-available/ drwxr-xr-x 2 root root 4096 Apr 26 12:47 sites-enabled/ drwxr-xr-x 2 root root 4096 Apr 26 12:47 snippets/ -rw-r--r-- 1 root root 664 Feb 12 2017 uwsgi_params -rw-r--r-- 1 root root 3071 Feb 12 2017 win-utf nginx.conf是主配置文件 查看nginx进程是否启动 ps -ef|grep nginx 配置nginx Web服务器主要配置文件nginx.conf sudo vim /etc/nginx/nginx.conf 虚拟主机配置文件 sudo vim /etc/nginx/sites-enabled/default Ubuntu下安装nodesudo apt-get install nodejs-legacy nodejs sudo apt-get install npm Windows上传文件到Ubuntu服务器使用WinSCP工具，传输rar压缩文件 Linux解压文件apt install rar unrar unrar e build.rar","tags":[]},{"title":"git相关","date":"2018-03-17T06:42:05.000Z","path":"2018/03/17/git相关/","text":"git仓库1.创建版本库： $ mkdir learngit $ cd learngit $ git init 当前目录下多了一个.git的隐藏目录，这个目录是Git来跟踪管理版本库的，千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 2.把文件添加到版本库 新建一个文件readme.txt 用命令git add告诉Git，把文件添加到仓库（把要提交的所有修改放到暂存区）： $ git add readme.txt 用命令git commit告诉Git，把文件提交到仓库（把暂存区的所有修改提交到分支）： $ git commit -m &quot;本次提交的说明&quot; $ git push origin brachName 把分支上的所有本地提交推送到远程库 $ git status 可以让我们时刻掌握仓库当前的状态 $ git log 显示从最近到最远的提交日志 commit 8125d1babdf58e7f82b2ce78d048f47d867b1b5c (HEAD -&gt; master) Author: shleyZ &lt;zxl735975459@126.com&gt; Date: Sat Mar 17 11:13:22 2018 +0800 添加一段内容 commit 43c80b42f0d4da4005a4c7cf87d150d59a44e64a （HEAD表示当前版本） $ git reset --hard HEAD^ 回退到上一个版本 $ git reset --hard 3628164(版本号) 指定回到某个版本 $ git reflog 查看你之前的每一次命令，前面是版本号前几位 8125d1b (HEAD -&gt; master) HEAD@{0}: commit: 添加一段内容 43c80b4 HEAD@{1}: commit (initial): 本次提交的说明 $ git rm test.txt 删除文件 git分支创建dev分支，然后切换到dev分支 $ git checkout -b dev //Switched to a new branch &apos;dev&apos; 用git branch命令查看当前分支（列出所有分支，当前分支前面会标一个*号） $ git branch * dev master 合并某分支到当前分支： git merge &lt;name&gt; 删除分支： git branch -d &lt;name&gt; git branch -D &lt;name&gt; （强行删除分支） 冲突需要根据提示手动解决，最好不要两人在同时对一个文件修改。 分支1.master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 2.在dev分支干活，也就是说，dev分支是不稳定的 3.合并分支最好用下面这种方法： git merge --no-ff -m &quot;merge with no-ff&quot; dev 这样Git就会在merge时生成一个新的commit，能看出来曾经做过合并。 4.bug分支： 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 5.Feature分支（开发新功能） 多人协作：git remote -v 查看远程库的信息 多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。","tags":[]},{"title":"解决webstorm被限制读写权限的问题","date":"2018-03-15T08:32:28.000Z","path":"2018/03/15/解决webstorm被限制读写权限的问题/","text":"在webstorm上新建一个项目，发现项目下的所有文件上都多了一个小锁的图标，对这些文件修改或新建文件的时候总是弹出：‘ cannot modify a ready-only directory’的弹窗， 点击修改读写权限的小锁图标，页是弹出‘failed to change read-only flag’。 解决方法： 运行：sudo chown -R myusername my-project-folder","tags":[]},{"title":"mac修改hostname","date":"2017-12-13T12:10:07.000Z","path":"2017/12/13/mac修改hostname/","text":"修改Mac终端～前面的计算机名： sudo scutil --set HostName temp temp是你想要修改成的名字输入密码回车后重启终端计算机名就会显示temp了！","tags":[]},{"title":"shell进行vim操作Found a swp file by the name","date":"2017-12-10T12:15:52.000Z","path":"2017/12/10/shell进行vim操作Found-a-swp-file-by-the-name/","text":"用vim打开.bash_profile时出现： ATTENTION Found a swap file by the name &quot;.bash_profile.swp&quot; owned by: ****** dated: ****** file name: ******* modified: YES user name: ****** host name: ******* process ID: ****** 。。。。。。。 原因是之前vi 操作.bash_profile文件时出现了异常中断，所以在当前目录下产生了一个.bash_profile.swp文件 使用ls -a命令查看可以发现这个隐藏文件。 rm .bash_profile.swp 这样就不会有 ATTENTION 了","tags":[]},{"title":"python获取指定目录以及其子目录下所有文件","date":"2017-12-05T08:24:54.000Z","path":"2017/12/05/python获取指定目录以及其子目录下所有文件/","text":"#!/usr/bin/env python3 #-*- coding: utf-8 -*- import os def findfile(path): # 获取指定path下的所有文件和文件夹 allfiles = os.listdir(path) for x in allfiles: newPath = os.path.join(path,x) if os.path.isdir(newPath): # 如果是文件夹，就继续往下查找 findfile(newPath) if os.path.isfile(newPath): # 如果是文件，打印出来 print(newPath) #绝对路径 print(newPath.split(path)[1]) # 相对路径","tags":[]},{"title":"python操作文件和目录","date":"2017-12-02T07:28:27.000Z","path":"2017/12/02/python操作文件和目录/","text":"如何在python中进行文件和目录操作呢，我们可以在命令行输入操作系统提供的各种命令。 python内置的os模块可以直接调用操作系统提供的接口函数 1.引用os模块在python交互命令行中 &gt;&gt;&gt; import os &gt;&gt;&gt; os.name &apos;posix&apos; 如果系统是Linux，Unix或Mac OS X，那么os.name是’posix’如果系统是Windows，那么os.name是’nt’ 2.操作系统中定义的环境变量都在os.environ中&gt;&gt;&gt; os.environ environ({&apos;TERM_PROGRAM&apos;: &apos;Apple_Terminal&apos;, &apos;SHELL&apos;: &apos;/bin/bash&apos;, &apos;TERM&apos;: &apos;xterm-256color&apos;, &apos;TMPDIR&apos;: &apos;/var/folders/jg/dr9gc8rd7y7g0pzyv3xzzp500000gn/T/&apos;, &apos;Apple_PubSub_Socket_Render&apos;: &apos;/private/tmp/com.apple.launchd.LI1PfpIvgk/Render&apos;, &apos;TERM_PROGRAM_VERSION&apos;: &apos;38.8.1.1&apos;, &apos;OLDPWD&apos;: &apos;/Users/*****/workspace&apos;, &apos;TERM_SESSION_ID&apos;: &apos;475******6&apos;, &apos;USER&apos;: &apos;*****&apos;, &apos;SSH_AUTH_SOCK&apos;: &apos;/private/tmp/com.apple.launchd.h8tpeio0hp/Listeners&apos;, &apos;__CF_USER_TEXT_ENCODING&apos;: &apos;0x1F5:0x19:0x34&apos;, &apos;PATH&apos;: &apos;/anaconda3/bin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/anaconda3/bin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/bin:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/bin:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/bin:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/bin&apos;, &apos;PWD&apos;: &apos;/Users/*****/workspace/cpython&apos;, &apos;JAVA_HOME&apos;: &apos;/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home&apos;, &apos;LANG&apos;: &apos;zh_CN.UTF-8&apos;, &apos;XPC_FLAGS&apos;: &apos;0x0&apos;, &apos;XPC_SERVICE_NAME&apos;: &apos;0&apos;, &apos;SHLVL&apos;: &apos;1&apos;, &apos;HOME&apos;: &apos;/Users/*****&apos;, &apos;LOGNAME&apos;: &apos;*****&apos;, &apos;CLASSPATH&apos;: &apos;.:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/lib:.:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home&apos;, &apos;_&apos;: &apos;/anaconda3/bin/python3&apos;}) 要获取某个环境变量的值，可以用os.environ.get(‘key’): &gt;&gt;&gt; os.environ.get(&apos;PATH&apos;) &apos;/anaconda3/bin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/anaconda3/bin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/bin:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/bin:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/bin:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/bin&apos; 3.操作文件和目录#查看当前绝对路径 &gt;&gt;&gt; os.path.abspath(&apos;.&apos;) &apos;/Users/******/Workspace/Cpython&apos; # 在目录下创建一个新目录seconddir &gt;&gt;&gt; os.path.join(&apos;/Users/******/Workspace/Cpython&apos;,&apos;seconddir&apos;) &apos;/Users/******/Workspace/Cpython/seconddir&apos; &gt;&gt;&gt; os.mkdir(&apos;/Users/******/Workspace/Cpython/seconddir&apos;) # 删除一个目录: &gt;&gt;&gt; os.rmdir(&apos;/Users/******/Workspace/Cpython/seconddir&apos;) # 拼接路径： &gt;&gt;&gt; os.path.join(&apos;/Users/******/Workspace&apos;,&apos;Cpython&apos;) &apos;/Users/******/Workspace/Cpython&apos; # 拆分路径： &gt;&gt;&gt; os.path.split(&apos;/Users/******/Workspace/Cpython&apos;) (&apos;/Users/******/Workspace&apos;, &apos;Cpython&apos;) # 对文件夹或者文件重命名： &gt;&gt;&gt; os.rename(&apos;seconddir&apos;,&apos;second&apos;) # 删掉文件（当前目录下的） &gt;&gt;&gt; os.remove(&apos;first_test.py&apos;) # 列出当前目录下的所有目录 &gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isdir(x)] [&apos;__pycache__&apos;, &apos;second&apos;] # 列出所有的.py文件： &gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isfile(x) and os.path.splitext(x)[1] == &apos;.py&apos;] [&apos;first.py&apos;, &apos;first_test.py&apos;, &apos;hello.py&apos;, &apos;learning.py&apos;, &apos;module.py&apos;]","tags":[]},{"title":"JQuery tips","date":"2017-11-28T07:23:07.000Z","path":"2017/11/28/JQuery-tips/","text":"检查JQuery是否加载在使用JQuery之前应该确认它是否已经加载： if(typeOf JQuery == &apos;undefined&apos;){ console.log(&apos;jQuery hasn\\&apos;t loaded&apos;); }else{ console.log(&apos;jQuery has loaded&apos;); } 返回顶部按钮","tags":[]},{"title":"彻底弄懂javascript执行机制","date":"2017-11-28T06:05:11.000Z","path":"2017/11/28/彻底弄懂javascript执行机制/","text":"这一次，彻底弄懂 JavaScript 执行机制","tags":[]},{"title":"python参数","date":"2017-11-25T05:11:12.000Z","path":"2017/11/25/python参数/","text":"文章出自 菜比之路 python参数*与**可变参数在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。 我们以数学题为例子，给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……。 要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下： def calc(numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 但是调用的时候，需要先组装出一个list或tuple： &gt;&gt;&gt; calc([1, 2, 3]) 14 &gt;&gt;&gt; calc((1, 3, 5, 7)) 84 如果利用可变参数，调用函数的方式可以简化成这样： &gt;&gt;&gt; calc(1, 2, 3) 14 &gt;&gt;&gt; calc(1, 3, 5, 7) 84 所以，我们把函数的参数改为可变参数： def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 定义可变参数和定义list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数： &gt;&gt;&gt; calc(1, 2) 5 &gt;&gt;&gt; calc() 0 如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做： &gt;&gt;&gt; nums = [1, 2, 3] &gt;&gt;&gt; calc(nums[0], nums[1], nums[2]) 14 这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去： &gt;&gt;&gt; nums = [1, 2, 3] &gt;&gt;&gt; calc(*nums) 14 这种写法相当有用，而且很常见。 关键字参数可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例： def person(name, age, **kw): print &apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw 函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数： &gt;&gt;&gt; person(&apos;Michael&apos;, 30) name: Michael age: 30 other: {} 也可以传入任意个数的关键字参数： &gt;&gt;&gt; person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;) name: Bob age: 35 other: {&apos;city&apos;: &apos;Beijing&apos;} &gt;&gt;&gt; person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;) name: Adam age: 45 other: {&apos;gender&apos;: &apos;M&apos;, &apos;job&apos;: &apos;Engineer&apos;} 关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。 和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去： &gt;&gt;&gt; kw = {&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;} &gt;&gt;&gt; person(&apos;Jack&apos;, 24, city=kw[&apos;city&apos;], job=kw[&apos;job&apos;]) name: Jack age: 24 other: {&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;} 当然，上面复杂的调用可以用简化的写法： &gt;&gt;&gt; kw = {&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;} &gt;&gt;&gt; person(&apos;Jack&apos;, 24, **kw) name: Jack age: 24 other: {&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;} 参数组合在Python中定义函数，可以用必选参数、默认参数、可变参数和关键字参数，这4种参数都可以一起使用，或者只用其中某些，但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。 比如定义一个函数，包含上述4种参数： def func(a, b, c=0, *args, **kw): print &apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;args =&apos;, args, &apos;kw =&apos;, kw 在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。 &gt;&gt;&gt; func(1, 2) a = 1 b = 2 c = 0 args = () kw = {} &gt;&gt;&gt; func(1, 2, c=3) a = 1 b = 2 c = 3 args = () kw = {} &gt;&gt;&gt; func(1, 2, 3, &apos;a&apos;, &apos;b&apos;) a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = {} &gt;&gt;&gt; func(1, 2, 3, &apos;a&apos;, &apos;b&apos;, x=99) a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = {&apos;x&apos;: 99} 最神奇的是通过一个tuple和dict，你也可以调用该函数： &gt;&gt;&gt; args = (1, 2, 3, 4) &gt;&gt;&gt; kw = {&apos;x&apos;: 99} &gt;&gt;&gt; func(*args, **kw) a = 1 b = 2 c = 3 args = (4,) kw = {&apos;x&apos;: 99} 所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。 小结Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。 默认参数一定要用不可变对象，如果是可变对象，运行会有逻辑错误！ 要注意定义可变参数和关键字参数的语法： *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 以及调用函数时如何传入可变参数和关键字参数的语法： 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))； 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{‘a’: 1, ‘b’: 2})。 使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。","tags":[]},{"title":"javascript组件化","date":"2017-10-28T12:46:39.000Z","path":"2017/10/28/javascript组件化/","text":"文章来源于purplebamboo的博客：https://github.com/purplebamboo/blog/issues/16 作为一名前端工程师，写组件的能力至关重要。虽然javascript经常被人嘲笑是个小玩具，但是在一代代大牛的前仆后继的努力下，渐渐的也摸索了一套组件的编写方式。 下面我们来谈谈，在现有的知识体系下，如何很好的写组件。 比如我们要实现这样一个组件，就是一个输入框里面字数的计数。这个应该是个很简单的需求。 我们来看看，下面的各种写法。 为了更清楚的演示，下面全部使用jQuery作为基础语言库。 最简陋的写法 嗯 所谓的入门级写法呢，就是完完全全的全局函数全局变量的写法。（就我所知，现在好多外包还是这种写法） 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;test&lt;/title&gt; &lt;script src=&quot;http://code.jquery.com/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function() &#123; var input = $(&apos;#J_input&apos;); //用来获取字数 function getNum()&#123; return input.val().length; &#125; //渲染元素 function render()&#123; var num = getNum(); //没有字数的容器就新建一个 if ($(&apos;#J_input_count&apos;).length == 0) &#123; input.after(&apos;&lt;span id=&quot;J_input_count&quot;&gt;&lt;/span&gt;&apos;); &#125;; $(&apos;#J_input_count&apos;).html(num+&apos;个字&apos;); &#125; //监听事件 input.on(&apos;keyup&apos;,function()&#123; render(); &#125;); //初始化，第一次渲染 render(); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; id=&quot;J_input&quot;/&gt;&lt;/body&gt;&lt;/html&gt; 这段代码跑也是可以跑的，但是呢，各种变量混乱，没有很好的隔离作用域,当页面变的复杂的时候,会很难去维护。目前这种代码基本是用不了的。当然少数的活动页面可以简单用用。 作用域隔离 让我们对上面的代码作些改动，使用单个变量模拟命名空间。 textCount 1234567891011121314151617181920212223242526272829303132 input:null, init:function(config)&#123; this.input = $(config.id); this.bind(); //这边范围对应的对象，可以实现链式调用 return this; &#125;, bind:function()&#123; var self = this; this.input.on(&apos;keyup&apos;,function()&#123; self.render(); &#125;); &#125;, getNum:function()&#123; return this.input.val().length; &#125;, //渲染元素 render:function()&#123; var num = this.getNum(); if ($(&apos;#J_input_count&apos;).length == 0) &#123; this.input.after(&apos;&lt;span id=&quot;J_input_count&quot;&gt;&lt;/span&gt;&apos;); &#125;; $(&apos;#J_input_count&apos;).html(num+&apos;个字&apos;); &#125;&#125;$(function() &#123; //在domready后调用 textCount.init(&#123;id:&apos;#J_input&apos;&#125;).render();&#125;) 这样一改造，立马变的清晰了很多，所有的功能都在一个变量下面。代码更清晰，并且有统一的入口调用方法。 但是还是有些瑕疵，这种写法没有私有的概念，比如上面的getNum,bind应该都是私有的方法。但是其他代码可以很随意的改动这些。当代码量特别特别多的时候，很容易出现变量重复，或被修改的问题。 于是又出现了一种函数闭包的写法： TextCount 123456789101112131415161718192021222324252627282930313233343536373839 //私有方法，外面将访问不到 var _bind = function(that)&#123; that.input.on(&apos;keyup&apos;,function()&#123; that.render(); &#125;); &#125; var _getNum = function(that)&#123; return that.input.val().length; &#125; var TextCountFun = function(config)&#123; &#125; TextCountFun.prototype.init = function(config) &#123; this.input = $(config.id); _bind(this); return this; &#125;; TextCountFun.prototype.render = function() &#123; var num = _getNum(this); if ($(&apos;#J_input_count&apos;).length == 0) &#123; this.input.after(&apos;&lt;span id=&quot;J_input_count&quot;&gt;&lt;/span&gt;&apos;); &#125;; $(&apos;#J_input_count&apos;).html(num+&apos;个字&apos;); &#125;; //返回构造函数 return TextCountFun;&#125;)();$(function() &#123; new TextCount().init(&#123;id:&apos;#J_input&apos;&#125;).render();&#125;) 这种写法，把所有的东西都包在了一个自动执行的闭包里面，所以不会受到外面的影响，并且只对外公开了TextCountFun构造函数，生成的对象只能访问到init,render方法。这种写法已经满足绝大多数的需求了。事实上大部分的jQuery插件都是这种写法。 面向对象 上面的写法已经可以满足绝大多数需求了。 但是呢，当一个页面特别复杂，当我们需要的组件越来越多，当我们需要做一套组件。仅仅用这个就不行了。首先的问题就是，这种写法太灵活了，写单个组件还可以。如果我们需要做一套风格相近的组件，而且是多个人同时在写。那真的是噩梦。 在编程的圈子里，面向对象一直是被认为最佳的编写代码方式。比如java，就是因为把面向对象发挥到了极致，所以多个人写出来的代码都很接近，维护也很方便。但是很不幸的是，javascript不支持class类的定义。但是我们可以模拟。 下面我们先实现个简单的javascript类： var Class = (function() { var _mix = function(r, s) { for (var p in s) { if (s.hasOwnProperty(p)) { r[p] = s[p] } } } var _extend = function() { //开关 用来使生成原型时,不调用真正的构成流程init this.initPrototype = true var prototype = new this() this.initPrototype = false var items = Array.prototype.slice.call(arguments) || [] var item //支持混入多个属性，并且支持{}也支持 Function while (item = items.shift()) { _mix(prototype, item.prototype || item) } // 这边是返回的类，其实就是我们返回的子类 function SubClass() { if (!SubClass.initPrototype &amp;&amp; this.init) this.init.apply(this, arguments)//调用init真正的构造函数 } // 赋值原型链，完成继承 SubClass.prototype = prototype // 改变constructor引用 SubClass.prototype.constructor = SubClass // 为子类也添加extend方法 SubClass.extend = _extend return SubClass } //超级父类 var Class = function() {} //为超级父类添加extend方法 Class.extend = _extend return Class })() 这是拿John Resig的class简单修改了下。 这边只是很简陋的实现了类的继承机制。如果对类的实现有兴趣可以参考我另一篇文章javascript oo实现我们看下使用方法： //继承超级父类，生成个子类Animal，并且混入一些方法。这些方法会到Animal的原型上。 //另外这边不仅支持混入{}，还支持混入Function var Animal = Class.extend({ init:function(opts){ this.msg = opts.msg this.type = &quot;animal&quot; }, say:function(){ alert(this.msg+&quot;:i am a &quot;+this.type) } }) //继承Animal，并且混入一些方法 var Dog = Animal.extend({ init:function(opts){ //并未实现super方法，直接简单使用父类原型调用即可 Animal.prototype.init.call(this,opts) //修改了type类型 this.type = &quot;dog&quot; } }) //new Animal({msg:&apos;hello&apos;}).say() new Dog({msg:&apos;hi&apos;}).say() 使用很简单，超级父类具有extend方法，可以继承出一个子类。子类也具有extend方法。 这边要强调的是，继承的父类都是一个也就是单继承。但是可以通过extend实现多重混入。详见下面用法。 有了这个类的扩展，我们可以这么编写代码了： var TextCount = Class.extend({ init:function(config){ this.input = $(config.id); this._bind(); this.render(); }, render:function() { var num = this._getNum(); if ($(&apos;#J_input_count&apos;).length == 0) { this.input.after(&apos;&lt;span id=&quot;J_input_count&quot;&gt;&lt;/span&gt;&apos;); }; $(&apos;#J_input_count&apos;).html(num+&apos;个字&apos;); }, _getNum:function(){ return this.input.val().length; }, _bind:function(){ var self = this; self.input.on(&apos;keyup&apos;,function(){ self.render(); }); } }) $(function() { new TextCount({ id:&quot;#J_input&quot; }); }) 这边可能还没看见class的真正好处，不急我们继续往下。 抽象出base 可以看到，我们的组件有些方法，是大部分组件都会有的。 比如init用来初始化属性。比如render用来处理渲染的逻辑。比如bind用来处理事件的绑定。当然这也是一种约定俗成的规范了。如果大家全部按照这种风格来写代码，开发大规模组件库就变得更加规范，相互之间配合也更容易。 这个时候面向对象的好处就来了，我们抽象出一个Base类。其他组件编写时都继承它。 var Base = Class.extend({ init:function(config){ //自动保存配置项 this.__config = config this.bind() this.render() }, //可以使用get来获取配置项 get:function(key){ return this.__config[key] }, //可以使用set来设置配置项 set:function(key,value){ this.__config[key] = value }, bind:function(){ }, render:function() { }, //定义销毁的方法，一些收尾工作都应该在这里 destroy:function(){ } }) base类主要把组件的一般性内容都提取了出来，这样我们编写组件时可以直接继承base类，覆盖里面的bind和render方法。 于是我们可以这么写代码： var TextCount = Base.extend({ _getNum:function(){ return this.get(&apos;input&apos;).val().length; }, bind:function(){ var self = this; self.get(&apos;input&apos;).on(&apos;keyup&apos;,function(){ self.render(); }); }, render:function() { var num = this._getNum(); if ($(&apos;#J_input_count&apos;).length == 0) { this.get(&apos;input&apos;).after(&apos;&lt;span id=&quot;J_input_count&quot;&gt;&lt;/span&gt;&apos;); }; $(&apos;#J_input_count&apos;).html(num+&apos;个字&apos;); } }) $(function() { new TextCount({ //这边直接传input的节点了，因为属性的赋值都是自动的。 input:$(&quot;#J_input&quot;) }); }) 可以看到我们直接实现一些固定的方法，bind，render就行了。其他的base会自动处理（这里只是简单处理了配置属性的赋值）。 事实上，这边的init，bind，render就已经有了点生命周期的影子，但凡是组件都会具有这几个阶段，初始化，绑定事件，以及渲染。当然这边还可以加一个destroy销毁的方法，用来清理现场。 此外为了方便，这边直接变成了传递input的节点。因为属性赋值自动化了，一般来说这种情况下都是使用getter，setter来处理。这边就不详细展开了。 引入事件机制（观察者模式） 有了base应该说我们编写组件更加的规范化，体系化了。下面我们继续深挖。 还是上面的那个例子，如果我们希望输入字的时候超过5个字就弹出警告。该怎么办呢。 小白可能会说，那简单啊直接改下bind方法： var TextCount = Base.extend({ ... bind:function(){ var self = this; self.get(&apos;input&apos;).on(&apos;keyup&apos;,function(){ if(self._getNum() &gt; 5){ alert(&apos;超过了5个字了。。。&apos;) } self.render(); }); }, ... }) 的确也是一种方法，但是太low了，代码严重耦合。当这种需求特别特别多，代码会越来越乱。 这个时候就要引入事件机制，也就是经常说的观察者模式。 注意这边的事件机制跟平时的浏览器那些事件不是一回事，要分开来看。什么是观察者模式呢，官方的解释就不说了，直接拿这个例子来说。 想象一下base是个机器人会说话，他会一直监听输入的字数并且汇报出去（通知）。而你可以把耳朵凑上去，听着他的汇报（监听）。发现字数超过5个字了，你就做些操作。 所以这分为两个部分，一个是通知，一个是监听。 假设通知是 fire方法，监听是on。于是我们可以这么写代码： var TextCount = Base.extend({ ... bind:function(){ var self = this; self.get(&apos;input&apos;).on(&apos;keyup&apos;,function(){ //通知,每当有输入的时候，就报告出去。 self.fire(&apos;Text.input&apos;,self._getNum()) self.render(); }); }, ... }) $(function() { var t = new TextCount({ input:$(&quot;#J_input&quot;) }); //监听这个输入事件 t.on(&apos;Text.input&apos;,function(num){ //可以获取到传递过来的值 if(num&gt;5){ alert(&apos;超过了5个字了。。。&apos;) } }) }) fire用来触发一个事件，可以传递数据。而on用来添加一个监听。这样组件里面只负责把一些关键的事件抛出来，至于具体的业务逻辑都可以添加监听来实现。没有事件的组件是不完整的。 下面我们看看怎么实现这套事件机制。 我们首先抛开base，想想怎么实现一个具有这套机制的类。 //辅组函数，获取数组里某个元素的索引 index var _indexOf = function(array,key){ if (array === null) return -1 var i = 0, length = array.length for (; i &lt; length; i++) if (array[i] === item) return i return -1 } var Event = Class.extend({ //添加监听 on:function(key,listener){ //this.__events存储所有的处理函数 if (!this.__events) { this.__events = {} } if (!this.__events[key]) { this.__events[key] = [] } if (_indexOf(this.__events,listener) === -1 &amp;&amp; typeof listener === &apos;function&apos;) { this.__events[key].push(listener) } return this }, //触发一个事件，也就是通知 fire:function(key){ if (!this.__events || !this.__events[key]) return var args = Array.prototype.slice.call(arguments, 1) || [] var listeners = this.__events[key] var i = 0 var l = listeners.length for (i; i &lt; l; i++) { listeners[i].apply(this,args) } return this }, //取消监听 off:function(key,listener){ if (!key &amp;&amp; !listener) { this.__events = {} } //不传监听函数，就去掉当前key下面的所有的监听函数 if (key &amp;&amp; !listener) { delete this.__events[key] } if (key &amp;&amp; listener) { var listeners = this.__events[key] var index = _indexOf(listeners, listener) (index &gt; -1) &amp;&amp; listeners.splice(index, 1) } return this; } }) var a = new Event() //添加监听 test事件 a.on(&apos;test&apos;,function(msg){ alert(msg) }) //触发 test事件 a.fire(&apos;test&apos;,&apos;我是第一次触发&apos;) a.fire(&apos;test&apos;,&apos;我又触发了&apos;) a.off(&apos;test&apos;) a.fire(&apos;test&apos;,&apos;你应该看不到我了&apos;) 实现起来并不复杂，只要使用this.__events存下所有的监听函数。在fire的时候去找到并且执行就行了。 这个时候面向对象的好处就来了，如果我们希望base拥有事件机制。只需要这么写: var Base = Class.extend(Event,{ ... destroy:function(){ //去掉所有的事件监听 this.off() } }) //于是可以 //var a = new Base() // a.on(xxx,fn) // // a.fire() 是的只要extend的时候多混入一个Event，这样Base或者它的子类生成的对象都会自动具有事件机制。 有了事件机制我们可以把组件内部很多状态暴露出来，比如我们可以在set方法中抛出一个事件，这样每次属性变更的时候我们都可以监听到。 到这里为止，我们的base类已经像模像样了，具有了init，bind，render，destroy方法来表示组件的各个关键过程，并且具有了事件机制。基本上已经可以很好的来开发组件了。 更进一步，richbase 我们还可以继续深挖。看看我们的base，还差些什么。首先浏览器的事件监听还很落后，需要用户自己在bind里面绑定，再然后现在的TextCount里面还存在dom操作，也没有自己的模板机制。这都是需要扩展的，于是我们在base的基础上再继承出一个richbase用来实现更完备的组件基类。 主要实现这些功能： 事件代理：不需要用户自己去找dom元素绑定监听，也不需要用户去关心什么时候销毁。模板渲染：用户不需要覆盖render方法，而是覆盖实现setUp方法。可以通过在setUp里面调用render来达到渲染对应html的目的。单向绑定：通过setChuckdata方法，更新数据，同时会更新html内容，不再需要dom操作。我们看下我们实现richbase后怎么写组件： var TextCount = RichBase.extend({ //事件直接在这里注册，会代理到parentNode节点，parentNode节点在下面指定 EVENTS:{ //选择器字符串，支持所有jQuery风格的选择器 &apos;input&apos;:{ //注册keyup事件 keyup:function(self,e){ //单向绑定，修改数据直接更新对应模板 self.setChuckdata(&apos;count&apos;,self._getNum()) } } }, //指定当前组件的模板 template:&apos;&lt;span id=&quot;J_input_count&quot;&gt;&lt;%= count %&gt;个字&lt;/span&gt;&apos;, //私有方法 _getNum:function(){ return this.get(&apos;input&apos;).val().length || 0 }, //覆盖实现setUp方法，所有逻辑写在这里。最后可以使用render来决定需不需要渲染模板 //模板渲染后会append到parentNode节点下面，如果未指定，会append到document.body setUp:function(){ var self = this; var input = this.get(&apos;parentNode&apos;).find(&apos;#J_input&apos;) self.set(&apos;input&apos;,input) var num = this._getNum() //赋值数据，渲染模板，选用。有的组件没有对应的模板就可以不调用这步。 self.render({ count:num }) } }) $(function() { //传入parentNode节点，组件会挂载到这个节点上。所有事件都会代理到这个上面。 new TextCount({ parentNode:$(&quot;#J_test_container&quot;) }); }) /**对应的html,做了些修改，主要为了加上parentNode，这边就是J_test_container &lt;div id=&quot;J_test_container&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;J_input&quot;/&gt; &lt;/div&gt; */ 看下上面的用法，可以看到变得更简单清晰了： 1.事件不需要自己绑定，直接注册在EVENTS属性上。程序会自动将事件代理到parentNode上。 2.引入了模板机制，使用template规定组件的模板，然后在setUp里面使用render(data)的方式渲染模板，程序会自动帮你append到parentNode下面。 3.单向绑定，无需操作dom，后面要改动内容，不需要操作dom，只需要调用setChuckdata(key,新的值)，选择性的更新某个数据，相应的html会自动重新渲染。下面我们看下richebase的实现： var RichBase = Base.extend({ EVENTS:{}, template:&apos;&apos;, init:function(config){ //存储配置项 this.__config = config //解析代理事件 this._delegateEvent() this.setUp() }, //循环遍历EVENTS，使用jQuery的delegate代理到parentNode _delegateEvent:function(){ var self = this var events = this.EVENTS || {} var eventObjs,fn,select,type var parentNode = this.get(&apos;parentNode&apos;) || $(document.body) for (select in events) { eventObjs = events[select] for (type in eventObjs) { fn = eventObjs[type] parentNode.delegate(select,type,function(e){ fn.call(null,self,e) }) } } }, //支持underscore的极简模板语法 //用来渲染模板，这边是抄的underscore的。非常简单的模板引擎，支持原生的js语法 _parseTemplate:function(str,data){ /** * http://ejohn.org/blog/javascript-micro-templating/ * https://github.com/jashkenas/underscore/blob/0.1.0/underscore.js#L399 */ var fn = new Function(&apos;obj&apos;, &apos;var p=[],print=function(){p.push.apply(p,arguments);};&apos; + &apos;with(obj){p.push(\\&apos;&apos; + str .replace(/[\\r\\t\\n]/g, &quot; &quot;) .split(&quot;&lt;%&quot;).join(&quot;\\t&quot;) .replace(/((^|%&gt;)[^\\t]*)&apos;/g, &quot;$1\\r&quot;) .replace(/\\t=(.*?)%&gt;/g, &quot;&apos;,$1,&apos;&quot;) .split(&quot;\\t&quot;).join(&quot;&apos;);&quot;) .split(&quot;%&gt;&quot;).join(&quot;p.push(&apos;&quot;) .split(&quot;\\r&quot;).join(&quot;\\\\&apos;&quot;) + &quot;&apos;);}return p.join(&apos;&apos;);&quot;) return data ? fn(data) : fn }, //提供给子类覆盖实现 setUp:function(){ this.render() }, //用来实现刷新，只需要传入之前render时的数据里的key还有更新值，就可以自动刷新模板 setChuckdata:function(key,value){ var self = this var data = self.get(&apos;__renderData&apos;) //更新对应的值 data[key] = value if (!this.template) return; //重新渲染 var newHtmlNode = $(self._parseTemplate(this.template,data)) //拿到存储的渲染后的节点 var currentNode = self.get(&apos;__currentNode&apos;) if (!currentNode) return; //替换内容 currentNode.replaceWith(newHtmlNode) self.set(&apos;__currentNode&apos;,newHtmlNode) }, //使用data来渲染模板并且append到parentNode下面 render:function(data){ var self = this //先存储起来渲染的data,方便后面setChuckdata获取使用 self.set(&apos;__renderData&apos;,data) if (!this.template) return; //使用_parseTemplate解析渲染模板生成html //子类可以覆盖这个方法使用其他的模板引擎解析 var html = self._parseTemplate(this.template,data) var parentNode = this.get(&apos;parentNode&apos;) || $(document.body) var currentNode = $(html) //保存下来留待后面的区域刷新 //存储起来，方便后面setChuckdata获取使用 self.set(&apos;__currentNode&apos;,currentNode) parentNode.append(currentNode) }, destroy:function(){ var self = this //去掉自身的事件监听 self.off() //删除渲染好的dom节点 self.get(&apos;__currentNode&apos;).remove() //去掉绑定的代理事件 var events = self.EVENTS || {} var eventObjs,fn,select,type var parentNode = self.get(&apos;parentNode&apos;) for (select in events) { eventObjs = events[select] for (type in eventObjs) { fn = eventObjs[type] parentNode.undelegate(select,type,fn) } } } }) 主要做了两件事，一个就是事件的解析跟代理，全部代理到parentNode上面。另外就是把render抽出来，用户只需要实现setUp方法。如果需要模板支持就在setUp里面调用render来渲染模板，并且可以通过setChuckdata来刷新模板，实现单向绑定。 结语 有了richbase，基本上组件开发就没啥问题了。但是我们还是可以继续深挖下去。 比如组件自动化加载渲染，局部刷新，比如父子组件的嵌套，再比如双向绑定，再比如实现ng-click这种风格的事件机制。 当然这些东西已经不属于组件里面的内容了。再进一步其实已经是一个框架了。实际上最近比较流行的react，ploymer还有我们的brix等等都是实现了这套东西。受限于篇幅，这个以后有空再写篇文章详细分析下。 鉴于有人跟我要完整代码，其实上面都列出来了。好吧 那我就再整理下，放在github了包含具体的demo，请点这里。不过仅仅作为理解使用最好不要用于生产环境。如果觉得有帮助就给我个star吧。","tags":[{"name":"组件开发","slug":"组件开发","permalink":"https://shleyz.github.io/tags/组件开发/"}]},{"title":"我的FCC项目","date":"2017-10-20T01:42:56.000Z","path":"2017/10/20/我的FCC项目/","text":"我的codepen地址：https://codepen.io/Sherry728/","tags":[{"name":"codepen","slug":"codepen","permalink":"https://shleyz.github.io/tags/codepen/"}]},{"title":"科学上网","date":"2017-10-19T06:52:17.000Z","path":"2017/10/19/科学上网/","text":"科学上网：用 VPS 搭建 shadowsocks 服务器 目前 shadowsocks 服务已经受到了影响，不过部署在 25 端口目前还可用。 仍然可以通过 ubuntu 的 apt-get 获取到 shadowsocks 服务端，windows、Mac OS X、Android 客户端的 release 下载链接仍然保留。因此在写作本文时，shadowsocks 还是可以使用的。 shadowsocks 简介shadowsocks 是一款自定义协议的代理软件，由于其流量特征不明显，（直到不久前）一直可以稳定提供上网代理。 shadowsocks 客户端会在本地开启一个 socks5 代理，通过此代理的网络访问请求由客户端发送至服务端，服务端发出请求，收到响应数据后再发回客户端。 因此使用 shadowsocks 需要一台墙外的服务器来部署 shadowsocks 服务端。 购买 VPS 服务器主流的 VPS（虚拟主机）服务器提供商有三家： linodedigital oceanbandwagon下面的比上面的便宜。如果只是自用，bandwagon 足够。 一般使用 paypal 绑定一个 visa 或 mastercard 信用卡来付款。注意要用国际 paypal 帐号，国内的是不能用外币付款的。 在 bandwagon 购买 VPS 以后会获得一个主机地址和用于 ssh 登录的 root 密码。 远程登陆 VPSMac OS X 或 Linux 下直接在终端中 ssh root@your_vps_ip -p your_ssh_port 即可。 在 windows 系统下需要专门的客户端来 SSH 登录 VPS。在 xShell 官网 下载 xShell。 家庭和学校用户可以免费试用，下载时选择 home and school use 即可。需要用邮箱注册一下，下载链接会发送到邮箱中。 xShell 中新建一个连接，会要求输入目标 IP 地址和端口，以及 root 密码，按提示操作即可。 安装 shadowsocks打开 shell，使用 VPS 服务商提供的 root 用户和密码 SSH 登录 VPS。然后执行如下命令： Debian/Ubuntu: apt-get install python-pip pip install shadowsocks CentOS: yum install python-setuptools &amp;&amp; easy_install pip pip install shadowsocks shadowsocks 就安装好了。 有时 Ubuntu 会遇到第一个命令安装 python-pip 时找不到包的情况。pip 官方给出了一个安装脚本，可以自动安装 pip。先下载脚本，然后执行即可： wget https://bootstrap.pypa.io/get-pip.py python get-pip.py 编写配置文件shadowsocks 启动时的参数，如服务器端口，代理端口，登录密码等，可以通过启动时的命令行参数来设定，也可以通过 json 格式的配置文件设定。推荐使用配置文件，方便查看和修改。 用 vi 新建一个配置文件： vi /etc/shadowsocks.json 然后输入如下内容： { &quot;server&quot;:&quot;my_server_ip&quot;, &quot;server_port&quot;:25, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;mypassword&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false } 保存退出。 配置文件中个字段的含义： server: 服务器ip地址server_port: 绑定的端口，注意不要设置已经使用了的端口possword: 密码timeout: 超时时间method: 加密方法fast_open: 如果你的服务器 Linux 内核在3.7+，可以开启 fast_open 以降低延迟workers: 默认为1 如果需要配置多个SS账号，可以按照如下案例进行配置： { &quot;server&quot;:&quot;your_server_ip&quot;, &quot;port_password&quot;:{ &quot;8381&quot;:&quot;password1&quot;, &quot;8382&quot;:&quot;password2&quot;, &quot;8383&quot;:&quot;password3&quot;, &quot;8384&quot;:&quot;password4&quot; }, &quot;timeout&quot;:300, &quot;method&quot;:&quot;rc4-md5&quot;, &quot;fast_open&quot;:false, &quot;workers&quot;:1 } 启动 shadowsocks如果已经写好了配置文件，启动 shadowsocks 服务器的命令如下： ssserver -c /etc/shadowsocks.json 后台启动和停止 shadowsocks 服务器： ssserver -c /etc/shadowsocks.json -d start ssserver -c /etc/shadowsocks.json -d stop shadowsocks 的日志保存在 /var/log/shadowsocks.log 安装并启动 shadowsocks 客户端 shadowsocks 支持 windows、Mac OS X、Linux、Android、iOS 等多个平台。不过 iOS 由于系统对应用后台运行的限制，推荐使用客户端内嵌的浏览器科学上网，给其他应用代理时需要每过几分钟重新启动一下 app。 shadowsocks 项目 Github 主页在这里。 里面可以找到客户端下载地址。 下载安装客户端以后，只需按服务器的配置填写 IP 地址、服务器端口、本地端口（如果没有本地端口选项，就是默认的 1080）、密码、加密方式等参数，启动就可以了。 客户端支持全局代理和 PAC 代理两种方式，后者会使用一个脚本来自动检查一个网站是否在需要代理的网站列表中，自动选择直接连接或代理连接。 PAC 列表可以在线更新，但是难免有收录不全的情况。这时可以选择关闭 shadowsocks 代理（实际上是取消对系统代理的配置，shadowsocks 客户端仍然保持工作），然后使用支持自定义规则的代理管理插件来实现自动切换代理，比如 switchyOmega。 使用 switchyOmega 实现自动切换代理switchyOmega 是 chrome 浏览器上一个很好用的代理管理插件。它的前身 switchySharp 更有名。 chrome 应用商店本身需要翻墙才能访问，因此需要先在 shadowsocks 启动代理模式下下载安装，再关闭 shadowsocks 代理。 安装完毕后，右击 switchyOmega 图标，选择选项，进入 switchOmega 配置界面。 创建 shadowsocks 情景模式 新建一个情景模式，比如叫 SS，代理协议选择 socks5，代理地址为 127.0.0.1，端口 1080。 现在切换到 SS 情景模式就可以通过 shadowsocks 科学上网了。后面获取自动切换规则列表 设置自动切换模式 在设置界面选择自动切换模式，在 “切换规则” 中勾选“规则列表规则”，对应的情景模式选择刚刚新建的 SS。 然后在下面的规则列表地址中填写 https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt 规则列表格式选择 AutoProxy。 然后点击立即更新情景模式， 更新完成后会有提示。 点击左侧的 “应用选项”。然后单击 switchyOmega 图标，选择自动切换，就可以在访问“不存在的网站” 时自动切换到 shadowsocks 代理了。 添加自定义规则 如果遇到某个国外网站无法直接连接或速度太慢时，可以单击 switchyOmega 图标，选择 “添加条件”，情景模式选择 SS，就可以了。 这时打开 switchyOmega 选项，在自动切换模式的切换规则中就可以看到刚刚添加的规则。可以在这里管理自定义的规则。 导入和导出 switchyOmega 设置 如果换了一台电脑，重新设置一遍 switchyOmega 就太麻烦了。可以在设置好的 switchyOmega 中导出设置文件，在另一个 chrome 浏览器中导入，就可以直接复制原来的设置了。 在 switchyOmega 选项的左侧点击 “导入 / 导出”，点击“生成备份文件” 即可生成 switchyOmega 设置备份。点击 “从备份文件恢复” 可以导入备份文件。 (apt install shadowsocks-libev ) 坑： 1.远程连接ubuntu系统时，可能会出现如下错误： @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that a host key has just been changed. The fingerprint for the ECDSA key sent by the remote host is SHA256:JHdZe0uj0FNj0PzyxFFNGZ5TU4M0aY/HsyTRON2CgQ4. Please contact your system administrator. Add correct host key in /Users/*****/.ssh/known_hosts to get rid of this message. Offending ECDSA key in /Users/*****/.ssh/known_hosts:6 ECDSA host key for 45.77.195.128 has changed and you have requested strict checking. 这种情况可能是因为已经登陆过，但是你修改过了ubuntu系统的信息，导致ssh信息不一致，只需要找到.ssh文件（Mac系统里面使用command+shift+.来显示隐藏文件，一般.ssh文件就在个人文件夹里面），删除对应的ip信息就好。 2.在pip install shadowsocks时会出现error： ImportError: No module named setuptools 解决办法： wget http://pypi.python.org/packages/source/s/setuptools/setuptools-0.6c11.tar.gz tar zxvf setuptools-0.6c11.tar.gz cd setuptools-0.6c11 python setup.py build python setup.py install 3.error: invalid command ‘bdist_wheel’ 解决办法： pip install setuptools --upgrade","tags":[]},{"title":"Webpack","date":"2017-10-16T07:02:14.000Z","path":"2017/10/16/Webpack/","text":"webpack 是一个现代 JavaScript 应用程序的模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成少量的 bundle - 通常只有一个，由浏览器加载。 1.安装webpack 新建一个文件夹webpack npm init 此时最好把package.json中的name改掉，不能是webpack，否则局部安装webpack时会报错。改为webpack-test。 npm install webpack --save-dev 用编辑器打开 npm install css-loader style-loader –save-dev 2.webpack使用 入口:告诉 webpack 从哪里开始，并根据依赖关系图确定需要打包的内容。可以将应用程序的入口起点认为是根上下文(contextual root) 或 app 第一个启动文件。 出口:将所有的资源(assets)归拢在一起后，还需要告诉 webpack 在哪里打包应用程序。webpack 的 output 属性描述了如何处理归拢在一起的代码(bundled code)。 Loader:webpack 把每个文件(.css, .html, .scss, .jpg, etc.) 都作为模块处理。然而 webpack 自身只理解 JavaScript。webpack loader 在文件被添加到依赖图中时，其转换为模块。(loader的作用：1.识别需要转换的文件，2.转换这些文件，从而使这些文件添加到依赖图)。 插件:webpack 的插件系统极其强大和可定制化。要使用一个插件，需要先require它，再把它添加到plugin数组中。 下面是webpack.config.js: const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //installed via npm const webpack = require(&apos;webpack&apos;); //to access built-in plugins const path = require(&apos;path&apos;); const config = { entry: &apos;./path/to/my/entry/file.js&apos;, output: { path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; }, module: { rules: [ { test: /\\.txt$/, use: &apos;raw-loader&apos; } ] }, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin({template: &apos;./src/index.html&apos;}) ] }; module.exports = config; 入口单个入口： const config = { entry: { main: &apos;./path/to/my/entry/file.js&apos; } }; 多个入口（对象形式）： const config = { entry: { app: &apos;./src/app.js&apos;, vendors: &apos;./src/vendors.js&apos; } }; 分离 应用程序(app) 和 第三方库(vendor) 入口。（或者多页面应用程序） 输出output即使可以存在多个入口起点，但只指定一个输出配置。 在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点： filename 用于输出文件的文件名。 目标输出目录 path 的绝对路径。 const config = { output: { path: &apos;/home/proj/public/assets&apos;, filename: &apos;bundle.js&apos; } } 如果有多个入口，应该使用占位符(substitutions)来确保每个文件具有唯一的名称： { entry: { app: &apos;./src/app.js&apos;, vendors: &apos;./src/vendors.js&apos; } output: { filename: &apos;[name].js&apos;, path: __dirname + bundle.js } } // 写入到硬盘：./dist/app.js, ./dist/search.js loader对模块的源代码进行转换。 loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ module.exports = { entry: { … }, output: { … }, module: { rules:[ {test: /.css$/, use: ‘css-loader’}, {test:/.ts$/, use: ‘ts-loader’} ] } } loader的使用方法有三种： 1.推荐配置webpack.config.js module: { rules: [ { test: /\\.css$/, use: [ { loader: &apos;style-loader&apos; }, { loader: &apos;css-loader&apos;, options: { modules: true } } ] } ] } 2.内联 import Styles from &apos;style-loader!css-loader?modules!./styles.css&apos;; 3.CLI(webpack命令行借口) webpack --module-bind jade-loader --module-bind &apos;css=style-loader!css-loader&apos; 插件插件是webpack的支柱功能，目的是解决loader无法实现的事情。 用法： webpack 配置中，向 plugins 属性传入 new 实例。 plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin({template: &apos;./src/index.html&apos;}) ] 配置1.通过require(…)导入其他文件2.通过require(…)使用npm的工具函数3.使用JS的控制流表达式4.对常用值使用常量或者变量5.编写并执行函数来生成部分配置 模块在模块化编程中，开发者将程序分解成离散功能块，称为模块。","tags":[]},{"title":"python题目","date":"2017-10-14T05:27:40.000Z","path":"2017/10/14/python题目/","text":"1.打印多行字符串： &gt;&gt;&gt; print(&apos;&apos;&apos;line1 ... line2 ... line3&apos;&apos;&apos;) line1 line2 line3 2.练习格式化字符串的使用： &gt;&gt;&gt; &apos;Hello, {0}, 成绩提升了 {1:.1f}%&apos;.format(&apos;小明&apos;, 17.125) &apos;Hello, 小明, 成绩提升了 17.1%&apos; 3.小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数： 低于18.5：过轻18.5-25：正常25-28：过重28-32：肥胖高于32：严重肥胖用if-elif判断并打印结果： # -*- coding: utf-8 -*- height = 1.75 weight = 80.5 bmi = weight/(height*height) if bmi&lt;18.5: print(&apos;过轻&apos;) elif bmi&lt;25: print(&apos;正常&apos;) elif bmi&lt;28: print(&apos;过重&apos;) elif bmi&lt;32: print(&apos;肥胖&apos;) else: print(&apos;严重肥胖&apos;) &gt;&gt;&gt;过重 4.请利用循环依次对list中的每个名字打印出Hello, xxx!： # -*- coding: utf-8 -*- L = [&apos;Bart&apos;, &apos;Lisa&apos;, &apos;Adam&apos;] for i in L: print(&apos;hello,&apos;,i) &gt;&gt;&gt; hello, Bart &gt;&gt;&gt; hello, Lisa &gt;&gt;&gt; hello, Adam 5.请利用Python内置的hex()函数把一个整数转换成十六进制表示的字符串： # -*- coding: utf-8 -*- n1 = 255 n2 = 1000 print(&apos;n1转换成十六进制：%s&apos;% (hex(n1))) print(&apos;n2转换成十六进制：%s&apos;% (hex(n2))) &gt;&gt;&gt; n1转换成十六进制：0xff &gt;&gt;&gt; n2转换成十六进制：0x3e8 6.请定义一个函数quadratic(a, b, c)，接收3个参数，返回一元二次方程：ax2 + bx + c = 0的两个解。 提示：计算平方根可以调用math.sqrt()函数： # -*- coding: utf-8 -*- import math def quadratic(a, b, c): deta = b*b - 4*a*c if deta == 0: return -b/(2*a) elif deta &lt; 0: print(&apos;无解&apos;) return else: x1 = (-b + math.sqrt(deta))/(2*a) x2 = (-b - math.sqrt(deta))/(2*a) return x1,x2 7.一个函数：可接收一个或多个参数并计算乘积 # -*- coding: utf-8 -*- def product(x,*y): result = x if len(y)==0: return result else: for i in y: result = result * i return result 8.汉诺塔的移动可以用递归函数非常简单地实现。 请编写move(n, a, b, c)函数，它接收参数n，表示3个柱子A、B、C中第1个柱子A的盘子数量，然后打印出把所有盘子从A借助B移动到C的方法，例如： move(3, ‘A’, ‘B’, ‘C’) # 期待输出: # A --&gt; C # A --&gt; B # C --&gt; B # A --&gt; C # B --&gt; A # B --&gt; C # A --&gt; C # -*- coding: utf-8 -*- def move(n, a, b, c): if n == 1: print(a, &apos;--&gt;&apos;, c) else: move(n-1,a,c,b) move(1,a,b,c) move(n-1,b,a,c) 9.利用切片操作，实现一个trim()函数，去除字符串首尾的空格，注意不要调用str的strip()方法： # -*- coding: utf-8 -*- def trim(s): while s[0:1] == &apos; &apos;: s = s[1:] while s[-1:] == &apos; &apos;: s = s[:-1] return s 10.请使用迭代查找一个list中最小和最大值，并返回一个tuple： # -*- coding: utf-8 -*- def findMinAndMax(L): if len(L) == 0: return None,None max_value = L[0] min_value = L[0] for i in L: if max_value &lt; i: max_value = i if min_value &gt; i: min_value = i return min_value,max_value 11.请修改列表生成式，通过添加if语句保证列表生成式能正确地执行： # -*- coding: utf-8 -*- L1 = [&apos;Hello&apos;, &apos;World&apos;, 18, &apos;Apple&apos;, None] L2 = [i.lower() for i in L1 if isinstance(i,str)] # 测试: print(L2) if L2 == [&apos;hello&apos;, &apos;world&apos;, &apos;apple&apos;]: print(&apos;测试通过!&apos;) else: print(&apos;测试失败!&apos;) 12.杨辉三角定义如下： 1 / \\ 1 1 / \\ / \\ 1 2 1 / \\ / \\ / \\ 1 3 3 1 / \\ / \\ / \\ / \\ 1 4 6 4 1 / \\ / \\ / \\ / \\ / \\1 5 10 10 5 1 把每一行看做一个list，试写一个生成器generator，不断输出下一行的list： # -*- coding: utf-8 -*- def triangles(): result = [1] while True: yield result result = [result[x] + result[x+1] for x in range(len(result)-1)] result.append(1) result.insert(0,1) if n&gt;10: break 输出: &gt;&gt;&gt; [1] &gt;&gt;&gt; [1, 1] &gt;&gt;&gt; [1, 2, 1] &gt;&gt;&gt; [1, 3, 3, 1] &gt;&gt;&gt; [1, 4, 6, 4, 1] &gt;&gt;&gt; [1, 5, 10, 10, 5, 1] &gt;&gt;&gt; [1, 6, 15, 20, 15, 6, 1] &gt;&gt;&gt; [1, 7, 21, 35, 35, 21, 7, 1] &gt;&gt;&gt; [1, 8, 28, 56, 70, 56, 28, 8, 1] &gt;&gt;&gt; [1, 9, 36, 84, 126, 126, 84, 36, 9, 1] 13.利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[‘adam’, ‘LISA’, ‘barT’]，输出：[‘Adam’, ‘Lisa’, ‘Bart’]： # -*- coding: utf-8 -*- def normalize(name): return name[0].upper()+name[1:].lower() # 测试: L1 = [&apos;adam&apos;, &apos;LISA&apos;, &apos;barT&apos;] L2 = list(map(normalize, L1)) print(L2) &gt;&gt;&gt;[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 14.编写一个prod()函数，可以接受一个list并利用reduce()求积： # -*- coding: utf-8 -*- from functools import reduce def prod(L): return reduce(lambda x, y : x * y, L) 15.利用map和reduce编写一个str2float函数，把字符串’123.456’转换成浮点数123.456： # -*- coding: utf-8 -*- from functools import reduce def str2float(s): n = s.index(&apos;.&apos;) s1 = list(map(int, [x for x in s[:n]])) s2 = list(map(int,[x for x in s[n+1:]])) return reduce(lambda x, y : x * 10 + y, s1) + reduce(lambda x, y : x * 10 + y, s2)/10**len(s2) &gt;&gt;&gt; str2float(&apos;123.456&apos;) = 123.456 16.回数是指从左向右读和从右向左读都是一样的数，例如12321，909。请利用filter()筛选出回数： # -*- coding: utf-8 -*- def is_palindrome(n): n = str(n) return n == n[::-1] list(filter(is_palindrome, range(1, 200))) &gt;&gt;&gt;&gt;[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191] 17.假设我们用一组tuple表示学生名字和成绩： L = [(‘Bob’, 75), (‘Adam’, 92), (‘Bart’, 66), (‘Lisa’, 88)]请用sorted()对上述列表分别按名字排序： # -*- coding: utf-8 -*- L = [(&apos;Bob&apos;, 75), (&apos;Adam&apos;, 92), (&apos;Bart&apos;, 66), (&apos;Lisa&apos;, 88)] def by_name(t): return t[0] L2 = sorted(L, key=by_name) print(L2) &gt;&gt;&gt; [(&apos;Adam&apos;, 92), (&apos;Bart&apos;, 66), (&apos;Bob&apos;, 75), (&apos;Lisa&apos;, 88)] 再按成绩从高到低排序： def by_name(t): return -t[1] &gt;&gt;&gt; [(&apos;Adam&apos;, 92), (&apos;Lisa&apos;, 88), (&apos;Bob&apos;, 75), (&apos;Bart&apos;, 66)] 18.利用闭包返回一个计数器函数，每次调用它返回递增整数： # -*- coding: utf-8 -*- def createCounter(): n = 0 def counter(): nonlocal n n = n + 1 return n return counter 内层函数”可以使用”外层作用域中的变量,内层函数”无法修改”外层变量,使用 nonlocal 修改外层变量.通常情况下不要在内部函数中对外部作用域的变量重新赋值。 19.请设计一个decorator，它可作用于任何函数上，并打印该函数的执行时间： # -*- coding: utf-8 -*- import time, functools def metric(fn): def wrapper(*args,**wk): time_start = time.time() fn(*args,**wk) time_end = time.time() print(&apos;%s executed in %s ms&apos; % (fn.__name__, time_end - time_start)) return fn(*args,**wk) return wrapper 20.安装常用的第三方模块Anaconda 21.请把下面的Student对象的gender字段对外隐藏起来，用get_gender()和set_gender()代替，并检查参数有效性： # -*- coding: utf-8 -*- class Student(object): def __init__(self, name, gender): self.name = name self.__gender = gender def get_gender(self): return self.__gender def set_gender(self, gende): if not isinstance(gende, str): raise ValueError(&apos;Bad Value&apos;) else: self.__gender = gende 22.为了统计学生人数，可以给Student类增加一个类属性，每创建一个实例，该属性自动增加： # -*- coding: utf-8 -*- class Student(object): count = 0 def __init__(self, name): self.name = name Student.count = Student.count + 1 print(Student.count) 测试:if Student.count != 0: print(&apos;测试失败!&apos;) else: bart = Student(&apos;Bart&apos;) if Student.count != 1: print(&apos;测试失败!&apos;) else: lisa = Student(&apos;Bart&apos;) if Student.count != 2: print(&apos;测试失败!&apos;) else: print(&apos;Students:&apos;, Student.count) print(&apos;测试通过!&apos;) &gt;&gt;&gt; 1 &gt;&gt;&gt; 2 &gt;&gt;&gt; Students: 2 &gt;&gt;&gt; 测试通过! 实例属性属于各个实例所有，互不干扰； 类属性属于类所有，所有实例共享一个属性； 23.请利用装饰器@property给一个Screen对象加上width和height属性，以及一个只读属性resolution： # -*- coding: utf-8 -*- class Screen(object): @property def width(self): return self._width @width.setter def width(self,value): self._width = value @property def height(self): return self._height @height.setter def height(self,value): self._height = value @property def resolution(self): self._resolution = 786432 return self._resolution # 测试: s = Screen() s.width = 1024 s.height = 768 print(&apos;resolution =&apos;, s.resolution) if s.resolution == 786432: print(&apos;测试通过!&apos;) else: print(&apos;测试失败!&apos;) #结果： &gt;&gt;&gt; resolution = 786432 &gt;&gt;&gt; 测试通过! 24.利用os模块编写一个能实现dir -l输出的程序。(显示当前目录下所有的文件和文件夹) &gt;&gt;&gt; import os &gt;&gt;&gt; print([x for x in os.listdir(&apos;.&apos;)]) [&apos;.deploy_git&apos;, &apos;.DS_Store&apos;, &apos;.gitignore&apos;, &apos;_config.yml&apos;, &apos;db.json&apos;, &apos;debug.log&apos;, &apos;node_modules&apos;, &apos;package.json&apos;, &apos;public&apos;, &apos;scaffolds&apos;, &apos;source&apos;, &apos;themes&apos;]","tags":[]},{"title":"ES6的babel转码器","date":"2017-10-14T01:43:06.000Z","path":"2017/10/14/ES6的babel转码器/","text":"我使用的是Mac系统，webstorm，在webstorm上创建一个新的项目ES6，安装babel。（首先要安装node）1.在ES6项目下执行npm init -y (根据权限不同，有的时候前面需要加sudo：sudo npm init -y，然后输入管理员密码) 这样是为了生成一个package.json的文件 2.本地安装babel命令行工具，这样就可以命令行使用babel。babel命令行工具可以全局安装也可本地安装，不过官方推荐本地安装，原因有两点： 本地安装不同的项目可以使用不同版本的babel，你也可以单独对某个项目的babel进行升级等操作 每个项目单独安装的意味着对计算机环境没有依赖，便于移植 安装： npm install --save-dev babel-cli 这时项目里面又了node_modules文件夹 如果你已经全局安装了babel-cli,可以使用下面的命令卸载： npm uninstall --global babel-cli 这时的package.json文件如下： { &quot;name&quot;: &quot;ES6-babel&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: { &quot;babel-cli&quot;: &quot;^6.26.0&quot; } } 3.在命令行中调用babel本地安装的babel是不能够在直接命令行中运行的，为了在命令行中运行babel，有两种方法，不过推荐第一种： 方法一：配置package.json文件的scripts项（在script中添加 “build”: “babel src -d lib”,”babel”: “babel”） { &quot;name&quot;: &quot;ES6-babel&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;babel src -d lib&quot;, &quot;babel&quot;: &quot;babel&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: { &quot;babel-cli&quot;: &quot;^6.26.0&quot; } } 方法二：进入node_modules文件夹，再进入.bin文件夹，然后执行在命令行中执行babel src -d lib。 4.创建 .babelrc 配置文件type nul&gt;.babelrc 或者： mkfile -n 1m .babelrc 都能创建.babelrc文件 5.安装babel转译器把ES6代码转换为ES5的代码必须要用转译器，装好需要的转译器还需要在babelrc进行配置这些转译器(presets)选项。 下面是一些转译器，可以选择一个或多个，根据自己需要安装： ##ES2015转码规则 npm install --save-dev babel-preset-es2015 ##react转码规则 npm install --save-dev babel-preset-react ##ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个 npm install --save-dev babel-preset-stage-0 npm install --save-dev babel-preset-stage-1 npm install --save-dev babel-preset-stage-2 npm install --save-dev babel-preset-stage-3 6.配置.babelrc文件.babelrc用于配置除回调以外的所有babel api 选项。例如plugins和presets。plugins用于配置我们转译所需要的插件，presets用于配置我们所需要的转译器。 添加： { &quot;presets&quot;: [ &quot;es2015&quot; ], &quot;plugins&quot;: [] } 7.这样我们就可以来转码了由于”build”: “babel src -d lib”,所以我们要创建src文件夹，里面是要转码的es6内容 例如在 ES6/src/es6.js里面添加如下内容： input.map(item =&gt; item + 1); 执行命令： npm run build 就会自动生成一个lib文件夹，里面是已经转码好的内容： &quot;use strict&quot;; input.map(function (item) { return item + 1; });","tags":[{"name":"babel","slug":"babel","permalink":"https://shleyz.github.io/tags/babel/"}]},{"title":"bind","date":"2017-10-11T08:33:37.000Z","path":"2017/10/11/bind/","text":"bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 语法： fun.bind(thisArg[, arg1[, arg2[, ...]]]) 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 返回由指定的this值和初始化参数改造的原函数拷贝。 bind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的call属性）。当新函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。绑定函数被调用时，bind() 也接受预设的参数提供给原函数。一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。","tags":[]},{"title":"Array.prototype.slice.call(obj)","date":"2017-10-11T06:01:38.000Z","path":"2017/10/11/Array-prototype-slice-call-obj/","text":"Array.prototype.slice.call(obj)能将具有length属性的对象obj转换为数组。 1.首先我们看Array.prototype.slice() Array.prototype.slice()返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。如果开始和结束都省略，那就是返回一个新的数组，是原来数组（从头到尾浅拷贝原数组） 2.然后我们看Function.prototype.call() call()方法的语法是： fun.call(thisArg, arg1, arg2, ...) applay()方法的语法： fun.apply(thisArg, [argsArray]) （两者差不多，唯一的区别就是call接受的是若干个参数的列表，而apply接受的是一个参数数组,这样实现了对象的继承） thisArg是在fun函数运行时指定的this值，后面的arg1, arg2, …是指定的参数列表。 这样很清楚了，Array.prototype.slice.call(obj)就是把obj这个类似数组的对象转换为数组，让它可以有数组的方法来进行其他操作。 也就相当于： obj.slice() 看栗子： var a = {length:4,0:&apos;a&apos;,1:&apos;b&apos;,2:&apos;c&apos;,3:&apos;d&apos;} Array.prototype.slice.call(a) //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] Array.prototype.slice.call(a,2) //[&quot;c&quot;, &quot;d&quot;] Array.prototype.slice.call(a,2,3) //[&quot;c&quot;] 用在函数参数中： function comp(a,b,c,d) { var newArr = Array.prototype.slice.call(arguments); console.log(arguments); console.log(newArr); } comp(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;); 这样从控制台看到：arguments是一个对象，而newArr则是一个数组。","tags":[]},{"title":"关于ES6语法","date":"2017-09-28T02:39:20.000Z","path":"2017/09/28/关于ES6语法/","text":"1.let和const命令let1.let用法类似var，但是let声明的变量只在let代码块内有效。用let很适用于for循环。 2.for循环有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 for (let i = 0; i &lt; 3; i++) { let i = &apos;abc&apos;; console.log(i); } // abc // abc // abc 上面代码正确运行，输出了3次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 3.let不存在变量提升，即不可以没有声明就使用。否则会报错。 // var 的情况 console.log(foo); // 输出undefined var foo = 2; // let 的情况 console.log(bar); // 报错ReferenceError let bar = 2; 这表示在let声明bar之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 4.暂时性死区 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 5.不允许重复声明 let不允许在相同作用域内，重复声明同一个变量。 // 报错 function func() { let a = 10; var a = 1; } // 报错 function func() { let a = 10; let a = 1; } 因此，不能在函数内部重新声明参数。 function func(arg) { let arg; // 报错 } function func(arg) { { let arg; // 不报错 } } 块级作用域ES5的作用域只有全局作用域和函数作用域ES6中的let相当于增加了块级作用域 1.块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。 // IIFE 写法 (function () { var tmp = ...; ... }()); // 块级作用域写法 { let tmp = ...; ... } 2.块级作用域与函数声明 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。 // 情况一（在ES5规定中是非法的，但是实际可以运行不会报错） if (true) { function f() {} } // 情况二（在ES5规定中是非法的，但是实际可以运行不会报错） try { function f() {} } catch(e) { // ... } ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。 注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 // 函数声明语句 { let a = &apos;secret&apos;; function f() { return a; } } // 函数表达式 { let a = &apos;secret&apos;; let f = function () { return a; }; } const 声明一个只读的常量1.一旦声明，常量的值不能改变。并且声明的时候必须赋值，不能先声明后赋值。 const PI = 3.1415; PI // 3.1415 PI = 3; // TypeError: Assignment to constant variable. 2.const与let的作用域一样，只在声明所在的块级作用域内有效。 if (true) { const MAX = 5; } MAX // Uncaught ReferenceError: MAX is not defined 3.const同样存在暂时性死区，只能在声明的位置后面使用。 4.const声明的常量，也与let一样不可重复声明。 5.const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。 ES6声明对象的六种方法ES5有:var,function两种方法 ES6有:var,function,let,const,import,class六种方法 顶层对象的属性ES5之中，顶层对象的属性与全局变量是等价的。 window.a = 1; a // 1 a = 2; window.a // 2 顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。 var a = 1; // 如果在Node的REPL环境，可以写成global.a // 或者采用通用方法，写成this.a window.a // 1 let b = 1; window.b // undefined 全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。 2.变量的结构赋值数组的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 let [a, b, c] = [1, 2, 3]; 从数组中提取值，按照对应位置，对变量赋值。如果解构不成功，变量的值就等于undefined。如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。 解构赋值允许指定默认值。（如果一个数组成员不严格等于undefined，默认值是不会生效的。） let [foo = true] = []; foo // true let [x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos; let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos; 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 对象的解构赋值对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; foo // &quot;aaa&quot; bar // &quot;bbb&quot; let { baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; baz // undefined 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 字符串的解构赋值字符串被转换成了一个类似数组的对象。 let {length : len} = &apos;hello&apos;; len // 5 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 圆括号的问题ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。因此，建议只要有可能，就不要在模式中放置圆括号。 不可以使用圆括号的情况： 1.变量声明语句2.函数参数3.赋值语句的模式 可以使用圆括号的情况： 只有一种：赋值语句的非模式部分，可以使用圆括号。 [(b)] = [3]; // 正确 ({ p: (d) } = {}); // 正确 [(parseInt.prop)] = [3]; // 正确 变量解构赋值的用途1.交换变量的值 let x = 1; let y = 2; [x, y] = [y, x]; 2.从函数返回多个值 // 返回一个数组 function example() { return [1, 2, 3]; } let [a, b, c] = example(); // 返回一个对象 function example() { return { foo: 1, bar: 2 }; } let { foo, bar } = example(); 3.函数参数的定义 // 参数是一组有次序的值 function f([x, y, z]) { ... } f([1, 2, 3]); // 参数是一组无次序的值 function f({x, y, z}) { ... } f({z: 3, y: 2, x: 1}); 4.提取JSON数据 let jsonData = { id: 42, status: &quot;OK&quot;, data: [867, 5309] }; let { id, status, data: number } = jsonData; console.log(id, status, number); // 42, &quot;OK&quot;, [867, 5309] 5.函数参数的默认值 jQuery.ajax = function (url, { async = true, beforeSend = function () {}, cache = true, complete = function () {}, crossDomain = false, global = true, // ... more config }) { // ... do stuff }; 6.遍历Map结构 任何部署了Iterator接口的对象，都可以用for...of循环遍历。 const map = new Map(); map.set(&apos;first&apos;, &apos;hello&apos;); map.set(&apos;second&apos;, &apos;world&apos;); for (let [key, value] of map) { console.log(key + &quot; is &quot; + value); } // first is hello // second is world 7.输入模块的指定方法 const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;); 3.字符串的扩展codePointAt() —返回一个字符的码点。String.fromCodePoint() —从码点返回对应字符。字符串的遍历器接口 —字符串可以被for…of循环遍历。normalize() —将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。includes(), startsWith(), endsWith()repeat(n) —返回一个新字符串，表示将原字符串重复n次。padStart()，padEnd() —头部补全，尾部补全模板字符串 —使用In JavaScript &#39;\\n&#39; is a line-feed.模板字符串中嵌入变量，需要将变量名写在${}之中。使用&lt;%…%&gt;放置JavaScript代码，使用&lt;%= … %&gt;输出JavaScript表达式。标签模板String.raw() —模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串 4.正则的扩展1.RegExp构造函数在ES5中RegExp构造函数的参数有两种表现形式： var regex = new RegExp(&apos;xyz&apos;, &apos;i&apos;); var regex = new RegExp(/xyz/i); 在第二种参数为正则表达式时，不允许有第二个参数。 但是在ES6中，如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。并且会忽略第一个参数正则里面的修饰符，只使用新的修饰符。 new RegExp(/abc/ig, &apos;i&apos;).flags // &quot;i&quot; 2.字符串的正则方法match()replace()search()split() 3.u修饰符ES6 对正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于\\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。 1.点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。 var s = &apos;𠮷&apos;; /^.$/.test(s) // false /^.$/u.test(s) // true 2.Unicode 字符表示法：ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。 /\\u{61}/.test(&apos;a&apos;) // false /\\u{61}/u.test(&apos;a&apos;) // true /\\u{20BB7}/u.test(&apos;𠮷&apos;) // true 3.量词:使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。 /a{2}/.test(&apos;aa&apos;) // true /a{2}/u.test(&apos;aa&apos;) // true /𠮷{2}/.test(&apos;𠮷𠮷&apos;) // false /𠮷{2}/u.test(&apos;𠮷𠮷&apos;) // true 4.预定义模式 /^\\S$/.test(&apos;𠮷&apos;) // false /^\\S$/u.test(&apos;𠮷&apos;) // true 上面代码的\\S是预定义模式，匹配所有不是空格的字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的 Unicode 字符。 5.i 修饰符:有些 Unicode 字符的编码不同，但是字型很相近，比如，\\u004B与\\u212A都是大写的K。 /[a-z]/i.test(&apos;\\u212A&apos;) // false /[a-z]/iu.test(&apos;\\u212A&apos;) // true 上面代码中，不加u修饰符，就无法识别非规范的K字符。 y修饰符—“粘连”（sticky）修饰符y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。 单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。 &apos;a1a2a3&apos;.match(/a\\d/y) // [&quot;a1&quot;] &apos;a1a2a3&apos;.match(/a\\d/gy) // [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;] 5.数值的扩展1.二进制和八进制表示法：ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。 如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。 Number(&apos;0b111&apos;) // 7 Number(&apos;0o10&apos;) // 8 2.Number.isFinite(), Number.isNaN()3.Number.parseInt(), Number.parseFloat()// ES5的写法 parseInt(&apos;12.34&apos;) // 12 parseFloat(&apos;123.45#&apos;) // 123.45 // ES6的写法 Number.parseInt(&apos;12.34&apos;) // 12 Number.parseFloat(&apos;123.45#&apos;) // 123.45 4.Number.isInteger()判断一个值是否为整数5.Number.EPSILONES6在Number对象上面，新增一个极小的常量Number.EPSILON。 Number.EPSILON // 2.220446049250313e-16 Number.EPSILON.toFixed(20) // &apos;0.00000000000000022204&apos; Number.EPSILON的实质是一个可以接受的误差范围。 function withinErrorMargin (left, right) { return Math.abs(left - right) &lt; Number.EPSILON; } withinErrorMargin(0.1 + 0.2, 0.3) // true withinErrorMargin(0.2 + 0.2, 0.3) // false 上面的代码为浮点数运算，部署了一个误差检查函数。 6.Math对象的扩展Math.trunc()去除一个数的小数部分，返回整数部分Math.sign()判断一个数是正数(返回+1)、负数(返回-1)、还是0(返回0)，非数值转换为数值，无法转换为数值返回NaN。Math.cbrt()计算一个数的立方根Math.clz32()返回一个数的32位无符号整数形式有多少个前导0,如果是小数的话，则只考虑整数部分。Math.imul()返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。Math.fround()返回一个数的单精度浮点数形式。Math.hyot()返回所有参数的平方之和的平方根。如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回NaN。 对数方法：Math.expm1()返回ex - 1，即Math.exp(x) - 1（e的x次方减1）.Math.log1p()返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。Math.log10()返回以10为底的x的对数。如果x小于0，则返回NaN。Math.log2()返回以2为底的x的对数。如果x小于0，则返回NaN。 双曲函数方法：Math.sinh(x)返回x的双曲正弦Math.cosh(x)返回x的双曲余弦Math.tanh(x)返回x的双曲正切Math.asinh(x)返回x的反双曲正弦Math.acosh(x)返回x的反双曲余弦Math.atanh(x)返回x的反双曲正切 7.Math.signbit()判断值是否是负值（包括-0，判断符号位）如果参数是NaN，返回false如果参数是-0，返回true如果参数是负值，返回true其他情况返回false 8.指数运算符**ES6新增的指数运算符： a ** b //a的b次幂 注：在V8引擎中，指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。 Math.pow(99,99) //3.697296376497263e+197 99 ** 99 //3.697296376497268e+197 9.integer数据类型JavaScript 所有数字都保存成64位浮点数，这决定了整数的精确程度只能到53个二进制位。大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。 为了与 Number 类型区别，Integer 类型的数据必须使用后缀n表示。 6.函数的扩展1.函数参数的默认值在ES6以前是不能给参数指定默认值的，但在ES6可以，即直接写着参数定义的后面。参数变量是默认声明的，所以不能用let或const再次声明。参数不能有同名参数出现 function(x,y = &apos;world&apos;){ console.log(x,y); } 优点：1.可以明显得知那些参数是可以省略的2.利于代码的优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。 2.函数的length属性arguments.length是函数实际接收到的参数个数Function.length 是函数形参的个数，即期望得到的参数的个数 当函数制定了默认值，函数的length属性将失真，即不包含默认值的参数（也不包含设置默认值参数之后的参数） (function (a) {}).length // 1 (function (a = 5) {}).length // 0 (function (a, b, c = 5) {}).length // 2 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。 (function (a = 0, b, c) {}).length // 0 (function (a, b = 1, c) {}).length // 1 3.rest参数用于获取函数的多余参数（values是一个数组） 形式为 ...变量名 function add(...values){} 栗子： function add(...values) { let sum = 0; for(var val of values){ sum += val; } return sum; } add(1,2,3,4,5); //15 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 函数的length属性，不包括 rest 参数。 (function(a) {}).length // 1 (function(...a) {}).length // 0 (function(a, ...b) {}).length // 1 函数的arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。 function push(array, ...items) { items.forEach(function(item) { array.push(item); console.log(item); }); } var a = []; push(a, 1, 2, 3) 4.严格模式从 ES5 开始，函数内部可以设定为严格模式。 ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 两种方法可以规避这种情况： 1.设定全局性的严格模式，这是合法的。 &apos;use strict&apos;; function doSomething(a, b = a) { // code } 2.把函数包在一个无参数的立即执行函数里面。 const doSomething = (function () { &apos;use strict&apos;; return function(value = 42) { return value; }; }()); 5.name属性返回函数的函数名 function foo() {} foo.name // &quot;foo&quot; 匿名函数在ES5和ES6中返回结果不一样，ES5返回空，ES6返回函数名 var f = function () {}; // ES5 f.name // &quot;&quot; // ES6 f.name // &quot;f&quot; 构造函数的name返回值为：anonymous (new Function).name // &quot;anonymous&quot; bind返回的函数，name属性值会加上bound前缀。 function foo() {}; foo.bind({}).name // &quot;bound foo&quot; (function(){}).bind({}).name // &quot;bound &quot; 6.箭头函数ES6允许使用“箭头”（=&gt;）定义函数。 var sum = (num1, num2) =&gt; { return num1 + num2; } (num1, num2)是参数部分， { return num1 + num2; }是函数体 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 var f = () =&gt; 5; // 等同于 var f = function () { return 5 }; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 // 报错 let getTempItem = id =&gt; { id: id, name: &quot;Temp&quot; }; // 不报错 let getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; }); 箭头函数的一个用处是简化回调函数。 // 正常函数写法 [1,2,3].map(function (x) { return x * x; }); // 箭头函数写法 [1,2,3].map(x =&gt; x * x); rest 参数与箭头函数结合的例子： const numbers = (...nums) =&gt; nums; numbers(1, 2, 3, 4, 5) // [1,2,3,4,5] const headAndTail = (head, ...tail) =&gt; [head, tail]; headAndTail(1, 2, 3, 4, 5) // [1,[2,3,4,5]] 箭头函数的注意点（箭头函数没有自己的this）： 1.函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。2.不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。3.不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。4.不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 7.绑定this函数绑定运算符::，运算符左边是对象，右边是函数，将对象绑定到函数的this对象上。 foo::bar; // 等同于 bar.bind(foo); foo::bar(...arguments); // 等同于 bar.apply(foo, arguments); const hasOwnProperty = Object.prototype.hasOwnProperty; function hasOwn(obj, key) { return obj::hasOwnProperty(key); } 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。 var method = obj::obj.foo; // 等同于 var method = ::obj.foo; let log = ::console.log; // 等同于 var log = console.log.bind(console); 由于双冒号运算符返回的还是原对象，因此可以采用链式写法。 // 例一 import { map, takeWhile, forEach } from &quot;iterlib&quot;; getPlayers() ::map(x =&gt; x.character()) ::takeWhile(x =&gt; x.strength &gt; 100) ::forEach(x =&gt; console.log(x)); // 例二 let { find, html } = jake; document.querySelectorAll(&quot;div.myClass&quot;) ::find(&quot;p&quot;) ::html(&quot;hahaha&quot;); 8.尾调用优化尾调用就是函数的最后一步是调用另一个函数。 “尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 function f() { let m = 1; let n = 2; return g(m + n); } f(); // 等同于 function f() { return g(3); } f(); // 等同于 g(3); 尾递归：尾调用自身的情况 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 function factorial(n) { if (n === 1) return 1; return n * factorial(n - 1); } factorial(5) // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。 function factorial(n, total) { if (n === 1) return total; return factorial(n - 1, n * total); } factorial(5, 1) // 120 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 非尾递归的 Fibonacci 数列实现如下。 function Fibonacci (n) { if ( n &lt;= 1 ) {return 1}; return Fibonacci(n - 1) + Fibonacci(n - 2); } Fibonacci(10) // 89 Fibonacci(100) // 堆栈溢出 Fibonacci(500) // 堆栈溢出 尾递归优化过的 Fibonacci 数列实现如下。 function Fibonacci2 (n , ac1 = 1 , ac2 = 1) { if( n &lt;= 1 ) {return ac2}; return Fibonacci2 (n - 1, ac2, ac1 + ac2); } Fibonacci2(100) // 573147844013817200000 Fibonacci2(1000) // 7.0330367711422765e+208 Fibonacci2(10000) // Infinity ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 7.数组的扩展1.扩展运算符spread（…）它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。主要用于函数的调用 function push(array, ...items) { array.push(...items); } function add(x, y) { return x + y; } const numbers = [4, 38]; add(...numbers) // 42 扩展运算符与正常的函数参数可以结合使用，非常灵活。 function f(v, w, x, y, z) { } const args = [0, 1]; f(-1, ...args, 2, ...[3]); 扩展运算符可以替换apply方法（把数组转换为函数的参数）： // ES5 的写法 Math.max.apply(null, [14, 3, 77]) // ES6 的写法 Math.max(...[14, 3, 77]) // 等同于 Math.max(14, 3, 77); 上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。 扩展运算符的应用： 1.复制数组 对于ES5，一维数组可以用slice或者concat实现深拷贝。 const a1 = [1, 2]; const a2 = a1.concat(); a2[0] = 2; a1 // [1, 2] 用扩展运算符…实现： const a1 = [1,2,3]; const a2 = [...a1]; 2.合并数组 // ES5 [1, 2].concat(more) // ES6 [1, 2, ...more] 3.与解构赋值结合 4.将字符串转换为数组 [...&apos;hello&apos;] // [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ] 5.实现了 Iterator 接口的对象 任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组。 let nodeList = document.querySelectorAll(&apos;div&apos;); let array = [...nodeList]; 2.Array.from将类数组对象和可遍历的对象转换为数组 Array.from(&apos;hello&apos;) // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;] let namesSet = new Set([&apos;a&apos;, &apos;b&apos;]) Array.from(namesSet) // [&apos;a&apos;, &apos;b&apos;] 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。 Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。 Array.from({ length: 2 }, () =&gt; &apos;jack&apos;) // [&apos;jack&apos;, &apos;jack&apos;] 3.Array.of将一组值，转换为数组。 Array.of(3, 11, 8) // [3,11,8] Array.of(3) // [3] Array.of(3).length // 1 4.数组实例的copyWithin()数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 [1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5] 语法： Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。 target（必需）：从该位置开始替换数据。start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 5.数组实例的find()和findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 [1, 4, -5, 10].find((n) =&gt; n &lt; 0) // -5 [1, 5, 10, 15].findIndex(function(value, index, arr) { return value &gt; 9; }) // 2 这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。 [NaN].indexOf(NaN) // -1 [NaN].findIndex(y =&gt; Object.is(NaN, y)) // 0 6.数组实例的fill()fill方法使用给定值，填充一个数组。 fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2) // [&apos;a&apos;, 7, &apos;c&apos;] 7.数组实例的 entries(),keys(),values()ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) { console.log(index); } // 0 // 1 for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) { console.log(elem); } // &apos;a&apos; // &apos;b&apos; for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) { console.log(index, elem); } // 0 &quot;a&quot; // 1 &quot;b&quot; 8.数组实例的 includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。 [1, 2, 3].includes(2) // true [1, 2, 3].includes(4) // false [1, 2, NaN].includes(NaN) // true 9.数组的空位数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。 Array(3) // [, , ,] 由于空位的处理规则非常不统一，所以建议避免出现空位。 8.对象的扩展1.属性的简洁表示法ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。 function f(x, y) { return {x, y}; } // 等同于 function f(x, y) { return {x: x, y: y}; } f(1, 2) // Object {x: 1, y: 2} 方法的简写： let birth = &apos;2000/01/01&apos;; const Person = { name: &apos;张三&apos;, //等同于birth: birth birth, // 等同于hello: function ()... hello() { console.log(&apos;我的名字是&apos;, this.name); } }; 2.属性名表达式ES6允许用表达式定义对象的属性名。 let propKey = &apos;foo&apos;; let obj = { [propKey]: true, [&apos;a&apos; + &apos;bc&apos;]: 123 }; S6允许用表达式定义对象的方法名： let obj = { [&apos;h&apos; + &apos;ello&apos;]() { return &apos;hi&apos;; } }; obj.hello() // hi 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。 const keyA = {a: 1}; const keyB = {b: 2}; const myObject = { [keyA]: &apos;valueA&apos;, [keyB]: &apos;valueB&apos; }; myObject // Object {[object Object]: &quot;valueB&quot;} 上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。 3.方法的name属性函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。 const person = { sayName() { console.log(&apos;hello!&apos;); }, }; person.sayName.name // &quot;sayName&quot; 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。 有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。 (new Function()).name // &quot;anonymous&quot; var doSomething = function() { // ... }; doSomething.bind().name // &quot;bound doSomething&quot; 4.Object.is()比较两个值是否严格相等它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。 它们的不同是(+0与-0，NaN与NaN)： +0 === -0 //true NaN === NaN //false Object.is(+0,-0) //false Object.is(NaN,NaN) //true 5.Object.assign()用于对象的合并const target = { a: 1 }; const source1 = { b: 2 }; const source2 = { c: 3 }; Object.assign(target, source1, source2); target // {a:1, b:2, c:3} 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 如果该参数不是对象，则会先转成对象，然后返回。 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。 Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。 用途： 1.为对象添加属性或方法2.克隆对象（浅拷贝）3.合并多个对象 const merge =(...sources) =&gt; Object.assign({}, ...sources); 4.为属性指定默认值 6.属性的可枚举性和遍历Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。 let obj = { foo: 123 }; Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;) //configurable:true //enumerable:true //value:123 //writable:true 其中的enumerable枚举属性，如果为false，那么for…in,Object.keys(),JSON.stringfy(),Object.assign()这些操作都会忽略该属性。（for…in会遍历继承的属性，而Object.keys()则不会，因此当我们只关心对象自身的属性时，最好不要用for…in,而选用Object.keys()）. 7.Object.getOwnPropertyDescriptors()返回某个对象属性的描述对象（descriptor）,即返回某个对象的自身属性，而不包含继承属性 8.proto 属性，Object.setPrototypeOf()，Object.getPrototypeOf()1.proto 属性用来读取和设置当前对象的prototype属性。 一个属性的proto 值表示这个对象的原型。ES6不建议用这个方法。 2.Object.setPrototypeOf() 设置对象的prototype，ES6建议用Object.setPropertyOf().返回对象本身。 let proto = {}; let obj = { x: 10 }; Object.setPrototypeOf(obj, proto); proto.y = 20; proto.z = 40; obj.x // 10 obj.y // 20 obj.z // 40 3.Object.getPrototypeOf() 用于读取一个对象的原型 9.super关键字super关键字指向当前对象的原型对象。只能用在对象的方法里面，用在其他地方会报错。 10.Object.keys(),Object.values(),Object.entries()Object.keys() 遍历对象的所有（enumerable为true，不是继承的）键名Object.values() 遍历对象的所有（enumerable为true，不是继承的）键值Object.entries() 遍历对象的所有（enumerable为true，不是继承的）键值对 10.symbolES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 let s = Symbol(); typeof s // &quot;symbol&quot; Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 Symbol值不能与其他类型的值进行运算，否则会报错。 由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 注意，Symbol 值作为对象属性名时，不能用点运算符。在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。 11.Set和Map数据结构1.SetES6提供新的数据结构SET。它类似于数组，但是其内部成员的值都是唯一的，没有重复值(判断的方法类似于全等判断)。 const s = new Set(); [2,3,5,4,5,2,2].forEach(x =&gt; s.add(x)); for(let i of s){ console.log(i); } 返回结果是：2 3 5 4。结果表明 Set 结构不会添加重复的值。 Set函数可以接受一个数组作为参数来初始化： const set = new Set([1, 2, 3, 4, 4]); [...set] // [1, 2, 3, 4] const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]); items.size // 5 items.length //undefined 利用Set的成员唯一性，可以用来数组去重： let myArray = [1,2,3,4,3,2,4,1]; let arr = [...new Set(myArray)]; console.log(arr); //[1, 2, 3, 4] 2.Set实例的属性和方法操作方法： 1.add(value) 添加某个值，返回Set结构本身2.delete(value) 删除某个值，返回布尔值，是否删除成功3.has(value) 判断某个值是不是Set成员，返回布尔值4.clear() 清空Set成员，没有返回值 s.add(1).add(2).add(2); // 注意2被加入了两次 s.size // 2 s.has(1) // true s.has(2) // true s.has(3) // false s.delete(2); s.has(2) // false Array.from方法可以将 Set 结构转为数组。 const items = new Set([1, 2, 3, 4, 5]); const array = Array.from(items); 这样数组去重就可以这样来写： Array.from(new Set(array)) 遍历Set： 1.keys() 返回键名2.values() 返回键值3.entries() 返回键值对4.foreach() 使用回调函数遍历 3.WeakSet与Set差不多，都是不重复值的集合，但是WeakSet的值必须是对象，不能是其他类型的值。 语法： const ws = new WeakSet() 作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。这个类数组对象的成员必须是对象。否则会报错 const a = [[1, 2], [3, 4]]; const ws = new WeakSet(a); // WeakSet {[1, 2], [3, 4]} const b = [3, 4]; const ws = new WeakSet(b); // Uncaught TypeError: Invalid value used in weak set(…) WeakSet的方法： 1.WeakSet.prototype.add(value)2.WeakSet.prototype.delete(value)3.WeakSet.prototype.has(value) 他没有size属性,不能遍历它的成员 4.MapObject 结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应。即对象的属性名（键）不只是字符串形式了，还可以是各种类型的值或对象。 const m = new Map(); const o = {p: &apos;Hello World&apos;}; m.set(o, &apos;content&apos;) m.get(o) // &quot;content&quot; m.has(o) // true m.delete(o) // true m.has(o) // false 作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。 const map = new Map([ [&apos;name&apos;, &apos;张三&apos;], [&apos;title&apos;, &apos;Author&apos;] ]); map.size // 2 map.has(&apos;name&apos;) // true map.get(&apos;name&apos;) // &quot;张三&quot; map.has(&apos;title&apos;) // true map.get(&apos;title&apos;) // &quot;Author&quot; 5.WeakMapWeakMap结构与Map结构类似，也是用于生成键值对的集合。 首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。 其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。 一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。 const wm = new WeakMap(); const element = document.getElementById(&apos;example&apos;); wm.set(element, &apos;some information&apos;); wm.get(element) // &quot;some information&quot; 总之，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。 注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。 const wm = new WeakMap(); let key = {}; let obj = {foo: 1}; wm.set(key, obj); obj = null; wm.get(key) // Object {foo: 1} 上面代码中，键值obj是正常引用。所以，即使在 WeakMap 外部消除了obj的引用，WeakMap 内部的引用依然存在。 WeakMap规定不能取到键名,无法清空.即不支持clear方法。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。 const wm = new WeakMap(); // size、forEach、clear 方法都不存在 wm.size // undefined wm.forEach // undefined wm.clear // undefined 12.ProxyProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。 13.ReflectReflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。 （1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。 （2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 （3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 （4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 14.Promise对象一种异步解决方案。从Promise对象，可以获取异步操作的信息。 简单来说Promise是一个容器，它包含着一个未来才会结束的事件（通常是一个异步操作） Promise分为三个状态：pending-进行中,fulfilled-已成功,rejected-已失败. Promise的特点： 1.对象的状态不受外部影响。只有异步操作的结果可以影响Promise状态。任何其他操作都无法改变这个状态。 2.一旦状态改变就不会再次改变，这时就称为 resolved（已定型）。任何时候都能得到异步结果（状态）。Promise状态的改变，只有可能有两种：pending -&gt; fulfilled 或者 pending -&gt; rejected. Promise的缺点： 1.无法取消Promise。一旦新建就会立即执行，无法中途取消。 2.如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 3.当处于pending状态时，无法得知目前进展到什么阶段（是刚刚开始海试即将完成）。 Promise基本用法Promise对象是一个构造函数。 var promise = new Promise(function(resolve,reject){ //some coding .... //如果异步操作成功resolve(value)，否则reject(err) if(win){ resolve(value); }else{ reject(err); } }) 其中的回调函数中的两个参数resolve和reject分别是两个函数，它们由javascript引擎提供，不需要自己部署。 resolve函数的作用：将Promise对象的状态由pending变为fulfilled，并且在异步操作成功时，将异步操作的结果value，作为参数传递出去。 reject函数的作用：将Promise对象的状态由pending变为rejected。并且在异步操作失败时，将异步操作报出的错误作为参数传递出去。","tags":[{"name":"ES6","slug":"ES6","permalink":"https://shleyz.github.io/tags/ES6/"}]},{"title":"CSS揭秘","date":"2017-09-25T04:07:53.000Z","path":"2017/09/25/CSS揭秘/","text":"1.background-clip:padding-boxbackground-clip默认为border-box，也就是说border的颜色会把元素背景颜色覆盖掉。如果设置background-clip:padding-box，背景颜色的范围就是在padding和containt。 2.box-shadow可以进行多重投影button{ background: yellowgreen; box-shadow: 0 0 0 10px #655, 0 0 0 15px deeppink, 0 2px 5px 15px rgba(0,0,0,.6); } box-shadow语法： box-shadow: h-shadow v-shadow blur spread color inset; h-shadow水平阴影的位置v-shadow垂直阴影的位置blur模糊距离spread阴影尺寸color阴影颜色inset将外部阴影变为内部阴影 3.使用border+outline实现两层边框button{ background: yellowgreen; border: 10px solid #655; outline: 5px solid deeppink; } 不过当outline的内部border设置圆角时，outline边框就不能与border相贴合了。 4.实现边框内圆角用两个元素实现： &lt;div class=&quot;example&quot;&gt; &lt;div class=&quot;ex1&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .example{ padding: 0.5em; background: #655; } .ex1{ background: tan; border-radius: .8em; padding: 1em; } &lt;/style&gt; 用一个元素实现： .ex1{ background: tan; border-radius: .8em; padding: 1em; box-shadow: 0 0 0 .4em #655; outline: .6em solid #655; } 原理就是outline和border圆角之间的空白用box-shadow填补上。 5.条纹背景","tags":[{"name":"CSS","slug":"CSS","permalink":"https://shleyz.github.io/tags/CSS/"}]},{"title":"Vue--自定义指令","date":"2017-09-23T08:39:39.000Z","path":"2017/09/23/Vue-自定义指令/","text":"","tags":[{"name":"Vue","slug":"Vue","permalink":"https://shleyz.github.io/tags/Vue/"}]},{"title":"Vue--混合","date":"2017-09-23T07:54:08.000Z","path":"2017/09/23/Vue-混合/","text":"混合 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混合对象可以包含任意组件选项。以组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。混合以一种灵活的方式为组件提供分布复用功能。混合对象可以包含任意的组件选项。当组件使用了混合对象时，混合对象的所有选项将被“混入”组件自己的选项中。两种写法都不是很容易理解，我的理解是：组件使用混合对象时，组件就拥有了混合对象里面的所有的属性，相当于把这个组件extend了。 原文示例： // 定义一个混合对象 var myMixin = { created: function () { this.hello() }, methods: { hello: function () { console.log(&apos;hello from mixin!&apos;) } } } // 定义一个使用混合对象的组件 var Component = Vue.extend({ mixins: [myMixin] }) var component = new Component() // =&gt; &quot;hello from mixin!&quot; 1.选项合并： 当组件和混合对象含有同名选项时，这些选项将以恰当的方式混合。比如，同名钩子函数将混合为一个数组，因此都将被调用。另外，混合对象的 钩子将在组件自身钩子 之前 调用 var mixin = { created: function () { console.log(&apos;混合对象的钩子被调用&apos;) } } new Vue({ mixins: [mixin], created: function () { console.log(&apos;组件钩子被调用&apos;) } }) // =&gt; &quot;混合对象的钩子被调用&quot; // =&gt; &quot;组件钩子被调用&quot; 值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。 var mixin = { methods: { foo: function () { console.log(&apos;foo&apos;) }, conflicting: function () { console.log(&apos;from mixin&apos;) } } } var vm = new Vue({ mixins: [mixin], methods: { bar: function () { console.log(&apos;bar&apos;) }, conflicting: function () { console.log(&apos;from self&apos;) } } }) vm.foo() // =&gt; &quot;foo&quot; vm.bar() // =&gt; &quot;bar&quot; vm.conflicting() // =&gt; &quot;from self&quot; 2.全局混合 全局注册混合对象。一旦使用全局混合对象，将会影响到 所有 之后创建的 Vue 实例。 // 为自定义的选项 &apos;myOption&apos; 注入一个处理器。 Vue.mixin({ created: function () { var myOption = this.$options.myOption if (myOption) { console.log(myOption) } } }) new Vue({ myOption: &apos;hello!&apos; }) // =&gt; &quot;hello!&quot; 大多数情况下，全局混合只应当应用于自定义选项，就像上面示例一样。也可以将其用作 Plugins 以避免产生重复应用","tags":[{"name":"Vue","slug":"Vue","permalink":"https://shleyz.github.io/tags/Vue/"}]},{"title":"Vue动画--列表过渡","date":"2017-09-22T08:48:21.000Z","path":"2017/09/22/Vue动画-列表过渡/","text":"列表过渡要使用：&lt;transition-group&gt;组件: 不同于 &lt;transition&gt;，它会以一个真实元素呈现：默认为一个 &lt;span&gt;。你也可以通过 tag 特性更换为其他元素。内部元素 总是需要 提供唯一的 key 属性值 1.列表的进入／离开过渡 &lt;style&gt; .list-item{ display: inline-block; margin-right: 10px; } .list-enter-active,.list-leave-active{ transition: all 1s; } .list-enter,.list-leave-to{ opacity: 0; transform: transilateY(30px); } &lt;/style&gt; &lt;div id=&quot;list-demo&quot;&gt; &lt;button v-on:click=&quot;add&quot;&gt;添加&lt;/button&gt; &lt;button v-on:click=&quot;remove&quot;&gt;移除&lt;/button&gt; &lt;transition-group name=&quot;list&quot; tag=&quot;p&quot;&gt; &lt;span v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-item&quot;&gt;{{item}}&lt;/span&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;#list-demo&apos;, data:{ items: [1,2,3,4,5,6,7,8,9], nextNum: 10, }, methods:{ randomIndex:function () { return Math.floor(Math.random()*this.items.length); }, add:function () { this.items.splice(this.randomIndex(),0,this.nextNum++); }, remove:function () { this.items.splice(this.randomIndex(),1); } } }) &lt;/script&gt; 2.列表的排序过渡 改变定位：使用v-move特性根据这一特性我们可以实现下面的单列列表过渡： &lt;div id=&quot;flip-list-demo&quot; class=&quot;demo&quot;&gt; &lt;button @click=&quot;shuffle&quot;&gt;列表随机排序&lt;/button&gt; &lt;button @click=&quot;add&quot;&gt;添加&lt;/button&gt; &lt;button @click=&quot;remove&quot;&gt;移除&lt;/button&gt; &lt;transition-group name=&quot;list&quot; tag=&quot;p&quot;&gt; &lt;span v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-item&quot;&gt;{{item}}&lt;/span&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;#flip-list-demo&apos;, data:{ items: [1,2,3,4,5,6,7,8,9], nextNum: 10, }, methods:{ shuffle:function () { this.items = _.shuffle(this.items) }, randomIndex:function () { return Math.floor(Math.random()*this.items.length); }, add:function () { this.items.splice(this.randomIndex(),0,this.nextNum++); }, remove:function () { this.items.splice(this.randomIndex(),1); } } }) &lt;/script&gt; 查看运行结果 同样可以实现多维网格的过渡。 &lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Vue多维网格动画&lt;/title&gt; &lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .demo{ width: 300px; margin:100px auto; } button{ float:right; width:100px; height:30px; border-radius: 5px; outline: none; } .container{ margin-bottom: 30px; width:270px; } .cell{ display: inline-block; width:30px; height:30px; outline: 1px solid #aaa; line-height: 30px; text-align: center; } .cell-move{ transition: 1s; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;cell-demo&quot; class=&quot;demo&quot;&gt; &lt;transition-group name=&quot;cell&quot; tag=&quot;div&quot; class=&quot;container&quot;&gt; &lt;span v-for=&quot;cell in cells&quot; :key=&quot;cell.id&quot; class=&quot;cell&quot;&gt;{{cell.number}}&lt;/span&gt; &lt;/transition-group&gt; &lt;button @click=&quot;shuffle&quot;&gt;随机排序&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;#cell-demo&apos;, data:{ cells:Array.apply(null,{length:81}).map(function (_,index) { return{ id: index, number: index % 9 + 1 } }) }, methods:{ shuffle:function () { this.cells = _.shuffle(this.cells) }, } }) &lt;/script&gt; &lt;/body&gt; 查看运行结果 3.可复用的过渡 过渡可以通过 Vue 的组件系统实现复用。要创建一个可复用过渡组件，你需要做的就是将 &lt;transition&gt; 或者 &lt;transition-group&gt;作为根组件，然后将任何子组件放置在其中就可以了。下面是一个简单的例子： Vue.component(&apos;my-special-transition&apos;, { template: &apos;\\ &lt;transition\\ name=&quot;very-special-transition&quot;\\ mode=&quot;out-in&quot;\\ v-on:before-enter=&quot;beforeEnter&quot;\\ v-on:after-enter=&quot;afterEnter&quot;\\ &gt;\\ &lt;slot&gt;&lt;/slot&gt;\\ &lt;/transition&gt;\\ &apos;, methods: { beforeEnter: function (el) { // ... }, afterEnter: function (el) { // ... } } }) 动态过渡：使用v-bind：name=””来绑定不同过渡的name值，再进行切换。当你想用 Vue 的过渡系统来定义的 CSS 过渡/动画 在不同过渡间切换会非常有用。","tags":[{"name":"Vue","slug":"Vue","permalink":"https://shleyz.github.io/tags/Vue/"}]},{"title":"Vue动画--单元素或组件的过渡","date":"2017-09-22T07:35:15.000Z","path":"2017/09/22/Vue动画-单元素或组件的过渡/","text":"单元素／组件的过渡1.Vue提供了transition的封装组件，在以下情境中可以给任何元素和组件添加entering／leaving过渡。 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点 &lt;style&gt; .fade-enter-active, .fade-leave-active { transition: opacity .5s } .fade-enter, .fade-leave-to /* .fade-leave-active in below version 2.1.8 */ { opacity: 0 } &lt;/style&gt; &lt;div id=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;show=!show&quot;&gt;Toggle&lt;/button&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello!&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el:&apos;#demo&apos;, data: { show:true } }) &lt;/script&gt; 当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理：1.自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。2.如果过渡组件提供了 JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用。3.如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和 Vue 的 nextTick 概念不同) 2.在进入／离开的过渡中，有6个类名进行切换： 1.v-enter：定义进入*过渡的开始状态*。在元素被插入时生效，在下一个帧移除。 2.v-enter-active：定义*过渡的状态*。在元素整个过渡过程中作用，在元素被插入时生效，在 transition/animation 完成之后移除。这个类可以被用来定义过渡的过程时间，延迟和曲线函数。 3. v-enter-to: 2.1.8版及以上 定义*进入过渡的结束状态*。在元素被插入一帧后生效 (于此同时 v-enter 被删除)，在 transition/animation 完成之后移除。 4.v-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。 5.v-leave-active：定义过渡的状态。在元素整个过渡过程中作用，在离开过渡被触发后立即生效，在 transition/animation 完成之后移除。这个类可以被用来定义过渡的过程时间，延迟和曲线函数。 6.v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发一帧后生效 (于此同时 v-leave 被删除)，在 transition/animation 完成之后移除。 3.自定义过渡类名： 我们可以通过以下特性来自定义过渡类名，它们的优先级高于普通的类名： enter-classenter-active-classenter-to-classleave-classleave-active-classleave-to-class 例如： &lt;link href=&quot;https://cdn.jsdelivr.net/npm/animate.css@3.5.1&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; &lt;div id=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;show=!show&quot;&gt;Toggle&lt;/button&gt; &lt;transition name=&quot;custom-classes-transition&quot; enter-active-class=&quot;animated data&quot; leave-active-class=&quot;animated bounceOutRight&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello!&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el:&apos;#demo&apos;, data: { show:true } }) &lt;/script&gt; 这样方便于结合其他的动画库，比如上面的Animate.css动画库 4.设置显性的过渡持续时间： &lt;transition :duration=&quot;1000&quot;&gt;...&lt;/transition&gt; &lt;transition :duration=&quot;{ enter: 500, leave: 800 }&quot;&gt;...&lt;/transition&gt; //定制进入和移出的持续时间 5.多个组件的过渡可以用动态组件来实现： &lt;style&gt; .component-fade-enter-active, .component-fade-leave-active { transition: opacity .3s ease; } .component-fade-enter, .component-fade-leave-to /* .component-fade-leave-active for below version 2.1.8 */ { opacity: 0; } &lt;/style&gt; &lt;div id=&quot;demo&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;view&quot; id=&quot;a&quot; v-on:click=&quot;toggle&quot;&gt; &lt;label for=&quot;a&quot;&gt;A&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;view&quot; id=&quot;b&quot; v-on:click=&quot;toggle&quot;&gt; &lt;label for=&quot;b&quot;&gt;B&lt;/label&gt; &lt;transition name=&quot;component-fade&quot; mode=&quot;out-in&quot;&gt; &lt;component v-bind:is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el:&apos;#demo&apos;, data: { view:&apos;v-a&apos; }, components:{ &apos;v-a&apos;:{ template:&apos;&lt;button&gt;componentA&lt;/button&gt;&apos; }, &apos;v-b&apos;:{ template:&apos;&lt;button&gt;componentB&lt;/button&gt;&apos; } }, methods:{ toggle:function () { if(this.view == &apos;v-a&apos;){ this.view = &apos;v-b&apos; }else if(this.view == &apos;v-b&apos;){ this.view = &apos;v-a&apos; } } } }) &lt;/script&gt; 6.Vue的过渡模式 默认是不设置过渡模式的，默认是同时进入喝离开 in-out：新元素先进入过渡，完成之后当前元素过渡离开。out-in：当前元素先过渡离开，离开后新元素再过渡进入。 &lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt;&lt;/transition&gt;","tags":[{"name":"Vue","slug":"Vue","permalink":"https://shleyz.github.io/tags/Vue/"}]},{"title":"Vue组件--可复用的组件等杂项","date":"2017-09-22T06:05:51.000Z","path":"2017/09/22/Vue组件-可复用的组件等杂项/","text":"1.可复用的组件可复用的组件需要与其他的组件解耦。它应当定义一个清晰的接口，方便使用。 Vue组件的API包括三个部分： Props 允许外部环境传递数据给组件 Events 允许从外部环境在组件内触发副作用 Slots 允许外部环境将额外的内容组合在组件中。 这样我们可以有一个清晰的模版： &lt;component :foo=&quot;baz&quot; :bar=&quot;qux&quot; @event-a=&quot;doThis&quot; @event-b=&quot;doThat&quot;&gt; &lt;img slot=&quot;con&quot; src=&quot;&quot; alt=&quot;&quot;&gt; &lt;p slot=&quot;main-text&quot;&gt;Hello!&lt;/p&gt; &lt;/component&gt; 2.子组件索引虽然有props和events来实现外部环境向内部传递数据，内部触发事件影响外部环境，但是我们仍然需要在javascript中直接访问子组件。这时我们就需要在子组件中添加ref索引ID。 &lt;div id=&quot;app&quot;&gt; &lt;navbar ref=&quot;navbar&quot;&gt;&lt;/navbar&gt; &lt;pagefooter ref=&quot;pagefooter&quot;&gt;&lt;/pagefooter&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;navbar&apos;,{ templates:&apos;&lt;div&gt;&apos; + &apos;&lt;ul&gt;&apos; + &apos;&lt;li&gt;apple&lt;/li&gt;&apos; + &apos;&lt;li&gt;pear&lt;/li&gt;&apos; + &apos;&lt;li&gt;grape&lt;/li&gt;&apos; + &apos;&lt;/ul&gt;&apos; + &apos;&lt;/div&gt;&apos;, data:function () { return { navs:[1,2,3] } } }) Vue.component(&apos;pagefooter&apos;,{ templated:&apos;&lt;div&gt;&lt;img src=&quot;https://www.baidu.com&quot;&gt;&lt;/div&gt;&apos;, data:function () { return { footer:&apos;hello&apos; } } }) var vm = new Vue({ el:&apos;#app&apos;, mounted:function () { //钩子函数，在vue的多有函数执行之前必须先执行钩子函数。 console.log(this.$refs.navbar.navs); console.log(this.$refs.pagefooter.footer); } }) &lt;/script&gt; 3.异步组件暂时还没有弄明白 4.组件命名约定当注册组件 (或者 props) 时，可以使用 kebab-case，camelCase，或 PascalCase。 // 在组件定义中 components: { // 使用 kebab-case 形式注册 &apos;kebab-cased-component&apos;: { /* ... */ }, // register using camelCase &apos;camelCasedComponent&apos;: { /* ... */ }, // register using PascalCase &apos;PascalCasedComponent&apos;: { /* ... */ } } 在 HTML 模板中，请使用 kebab-case 形式： &lt;!-- 在 HTML 模板中始终使用 kebab-case --&gt; &lt;kebab-cased-component&gt;&lt;/kebab-cased-component&gt; &lt;camel-cased-component&gt;&lt;/camel-cased-component&gt; &lt;pascal-cased-component&gt;&lt;/pascal-cased-component&gt; 当使用字符串模式时，可以不受 HTML 的 case-insensitive 限制。这意味实际上在模板中，你可以使用下面的方式来引用你的组件： kebab-case camelCase 或 kebab-case 如果组件已经被定义为 camelCase kebab-case，camelCase 或 PascalCase 如果组件已经被定义为 PascalCase PascalCase 是最通用的 声明约定 而 kebab-case 是最通用的 使用约定。 递归组件当组件有name选项时，组件在它的模版里面可以递归的调用自己。当你利用Vue.component全局注册了一个组件，全局的 ID 作为组件的 name 选项，被自动设置.","tags":[{"name":"Vue","slug":"Vue","permalink":"https://shleyz.github.io/tags/Vue/"}]},{"title":"Vue组件--动态组件","date":"2017-09-22T03:14:11.000Z","path":"2017/09/22/Vue组件-动态组件/","text":"动态组件就是几个组件放在一个挂载点，父组件根据变量来决定显示哪个 &lt;component v-bind:is=&quot;which_to_show&quot;&gt;&lt;/component&gt;,根据which_to_show的值来决定显示哪个组件,which_to_show值的改变相对显示的组件也会改变。 &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;toShow&quot;&gt;点击切换组件&lt;/button&gt; &lt;my_component v-bind:is=&quot;which_to_show&quot;&gt;&lt;/my_component&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &apos;#app&apos;, data: { which_to_show: &quot;first&quot; }, methods: { toShow: function () { var myArr=[&apos;first&apos;,&apos;second&apos;,&apos;third&apos;,&apos;&apos;]; var index = myArr.indexOf(this.which_to_show); if(index &lt; 3){ this.which_to_show = myArr[index + 1]; }else{ this.which_to_show = myArr[0]; } } }, components:{ first:{ template:&apos;&lt;div&gt;这是first组件&lt;/div&gt;&apos; }, second:{ template:&apos;&lt;div&gt;这是second组件&lt;/div&gt;&apos; }, third:{ template:&apos;&lt;div&gt;这是third组件&lt;/div&gt;&apos; } } }); &lt;/script&gt; keep-alive假如需要子组件在切换后，依然需要他保留在内存中，避免下次出现的时候重新渲染。那么就应该在component标签中添加keep-alive指令。","tags":[{"name":"Vue","slug":"Vue","permalink":"https://shleyz.github.io/tags/Vue/"}]},{"title":"Vue组件--内容分发slot","date":"2017-09-22T02:42:35.000Z","path":"2017/09/22/Vue组件-内容分发slot/","text":"使用插槽分发内容 假如父组件需要在子组件内放一些DOM元素，那么这些DOM元素是显示、不显示、在哪个地方显示、如何显示，就是slot内容分发。Vue实现了一个内容分发API,使用特殊的&lt;slot&gt;元素作为原始内容的插槽。 1.单个插槽 除非子组件有至少一个slot插槽，否则父组件的内容会被丢弃。如果子组件有一个插槽时，父组件的整个内容片段就会插入到插槽所在的DOM位置，并替换掉插槽标签slot。最初在 &lt;slot&gt;标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。 &lt;div id=&quot;test&quot;&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;my-component&gt; &lt;p&gt;这是父初始内容&lt;/p&gt; &lt;p&gt;这是更多初始内容&lt;/p&gt; &lt;/my-component&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;my-component&apos;, { template: &apos;&lt;div&gt;&apos; + &apos;&lt;h2&gt;我是子组件的标题&lt;/h2&gt;&apos; + &apos;&lt;slot&gt;只有在没有分发内容时我才会显示&lt;/slot&gt;&apos; + &apos;&lt;/div&gt;&apos;, }) new Vue({ el: &apos;#test&apos;, }) &lt;/script&gt; 如果子组件中没有slot插槽，那么父元素的内容（两个p标签）都会被丢弃。 2.具名插槽 &lt;slot&gt; 元素可以用一个特殊的属性 name 来配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应 slot 特性的元素。父组件在要分发的标签内添加： slot = ‘slotName’,子组件在对应分发的位置的slot标签内添加：&lt;slot name = &#39;slotName&#39;&gt;. &lt;div id=&quot;test&quot;&gt; &lt;my-component&gt; &lt;h1 slot=&quot;header&quot;&gt;这是slot为header&lt;/h1&gt; &lt;p&gt;这是主要内容&lt;/p&gt; &lt;p&gt;这是另一个主要片段&lt;/p&gt; &lt;p slot=&quot;footer&quot;&gt;这是slot为footer&lt;/p&gt; &lt;/my-component&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;my-component&apos;, { template: &apos;&lt;div class=&quot;container&quot;&gt;&apos; + &apos;&lt;header&gt;&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;&lt;/header&gt;&apos;+ &apos;&lt;main&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/main&gt;&apos; + &apos;&lt;footer&gt;&lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;&lt;/footer&gt;&apos; + &apos;&lt;/div&gt;&apos;, }) new Vue({ el: &apos;#test&apos;, }) &lt;/script&gt; 3.作用域插槽 使用一个 (能够传递数据到) 可重用模板替换已渲染元素。在子组件中，只需将数据传递到插槽，就像你将 props 传递给组件一样在父级中，具有特殊属性 scope 的 &lt;template&gt; 元素必须存在，表示它是作用域插槽的模板。scope 的值对应一个临时变量名，此变量接收从子组件中传递的 props 对象: &lt;div id=&quot;test&quot;&gt; &lt;div class=&quot;parent&quot;&gt; &lt;child&gt; &lt;template scope=&quot;props&quot;&gt; &lt;p&gt;hello from parent&lt;/p&gt; &lt;p&gt;{{props.text}}&lt;/p&gt; &lt;/template&gt; &lt;/child&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;child&apos;, { template: &apos;&lt;div class=&quot;child&quot;&gt;&apos; + &apos;&lt;slot text=&quot;hello from child&quot;&gt;&lt;/slot&gt;&apos; + &apos;&lt;/div&gt;&apos;, }) new Vue({ el: &apos;#test&apos;, }) &lt;/script&gt; 作用域插槽更具代表性的用例是列表组件，允许组件自定义应该如何渲染列表每一项： &lt;div id=&quot;test&quot;&gt; &lt;my-awesome-list :items=&quot;items&quot;&gt; &lt;template slot=&quot;item&quot; scope=&quot;props&quot;&gt; &lt;li class=&quot;my-fancy-item&quot;&gt;{{ props.text }}&lt;/li&gt; &lt;/template&gt; &lt;/my-awesome-list&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;my-awesome-list&apos;, { props:[&apos;items&apos;], template: &apos;&lt;ul&gt;&apos; + &apos;&lt;slot name=&quot;item&quot; v-for=&quot;item in items&quot; v-bind:text=&quot;item.text&quot;&gt;这里是备用内容&lt;/slot&gt;&apos; + &apos;&lt;/ul&gt;&apos;, }) new Vue({ el: &apos;#test&apos;, data:{ items:[ {text:&apos;apple&apos;}, {text:&apos;pear&apos;}, {text:&apos;grape&apos;} ] }, }) &lt;/script&gt;","tags":[{"name":"Vue","slug":"Vue","permalink":"https://shleyz.github.io/tags/Vue/"}]},{"title":"逻辑与或操作符","date":"2017-09-21T02:28:27.000Z","path":"2017/09/21/逻辑与或操作符/","text":"布尔操作符1.逻辑与 当操作数有一个不是布尔值时，逻辑操作就不一定返回布尔值。 例如 a &amp;&amp; b 若a是对象，则返回第二个操作数b若b是对象，则只有在a是true时才返回b对象若ab都是对象，则返回第二个操作数b若a时null，则返回null若a是NaN，则返回NaN若a是undefined，则返回undefined 2.逻辑或 与逻辑与相似，当操作数有一个不是布尔值时，逻辑操作就不一定返回布尔值。 例如 a || b 若a是对象，则返回第一个操作数a若a的求值结果为false，则返回第二个操作数b若ab都是对象，则返回第一个操作数a若ab都是null，则返回null若ab都是NaN，则返回NaN若ab都是undefined，则返回undefined 例如： var myObj = preferredObject || backupObject 变量myObj被赋予两个值中的一个，preferredObject优先赋给myObj，但是当preferredObject不包含有效值时，会把备用backupObject赋给myObj。","tags":[]},{"title":"Vue之组件","date":"2017-09-19T07:13:02.000Z","path":"2017/09/19/Vue之组件/","text":"1.注册全局组件： Vue.component(tagName, options) 使用： &lt;tagName&gt;&lt;/tagName&gt; 要确保在初始化根实例之前注册了组件 &lt;div id=&quot;test&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;my-component&apos;,{ template:&quot;&lt;p&gt;组件渲染的一个段落&lt;/p&gt;&quot; }); var vm = new Vue({ el:&apos;#test&apos; }) &lt;/script&gt; 2.局部注册组件：使组件仅在另一个实例/组件的作用域中可用 &lt;div id=&quot;test&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;script&gt; var Child={ template:&apos;&lt;p&gt;这是child组件渲染的部分&lt;/p&gt;&apos; }; var vm = new Vue({ el:&apos;#test&apos;, components:{ &apos;my-component&apos;:Child } }) &lt;/script&gt; data必须是函数 4.组合组件 父子组件的关系可以总结为 props down, events up。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。 props组件实例的作用域是孤立的，这意味着不能在子组件的模版内直接引用父组件的数据。如果要访问父组件的数据，子组件要显式的用props选项声明它期待获取的数据。 &lt;div id=&quot;test&quot;&gt; &lt;child message=&quot;hello&quot;&gt;&lt;/child&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;child&apos;,{ props:[&apos;message&apos;], template: &apos;&lt;p&gt;{{message}}&lt;/p&gt;&apos;, }); var vm = new Vue({ el:&apos;#test&apos;, }) &lt;/script&gt; 动态props： &lt;div id=&quot;test&quot;&gt; &lt;todo-item :my-message=&quot;todo&quot;&gt;&lt;/todo-item&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;todo-item&apos;,{ props:[&apos;myMessage&apos;], template: &apos;&lt;p&gt;{{myMessage.text + \" \" + myMessage.isComplete}}&lt;/p&gt;&apos;, }); var vm = new Vue({ el:&apos;#test&apos;, data:{ todo:{ text:&apos;Learn Vue&apos;, isComplete:false } } }) &lt;/script&gt; 单向数据流：prop是单向绑定的，当父组件的属性改变时，子组件的所有prop属性都会更新。但子组件不会影响父组件。不可以在子组件中更改prop属性，否则会警告 如果需要使用prop属性，可以定义一个局部变量活着一个计算属性： &lt;div id=&quot;test&quot;&gt; &lt;todo-item :my-message=&quot;todo&quot;&gt;&lt;/todo-item&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;todo-item&apos;,{ props:[&apos;myMessage&apos;], template: &apos;&lt;p&gt;{{myMessage.text + \" \" + myMessage.isComplete + \" 大写表示:\" + content}}&lt;/p&gt;&apos;, computed:{ content:function () { return this.myMessage.text.toUpperCase() + this.myMessage.isComplete; } } }); var vm = new Vue({ el:&apos;#test&apos;, data:{ todo:{ text:&apos;Learn Vue&apos;, isComplete:1 } } }) &lt;/script&gt; 注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。 prop验证 props 会在组件实例创建之前进行校验，所以在 default 或 validator 函数里，诸如 data、computed 或 methods 等实例属性还无法使用。 Vue.component(&apos;example&apos;, { props: { // 基础类型检测 (`null` 意思是任何类型都可以) propA: Number, // 多种类型 propB: [String, Number], // 必传且是字符串 propC: { type: String, required: true }, // 数字，有默认值 propD: { type: Number, default: 100 }, // 数组/对象的默认值应当由一个工厂函数返回 propE: { type: Object, default: function () { return { message: &apos;hello&apos; } } }, // 自定义验证函数 propF: { validator: function (value) { return value &gt; 10 } } } }) type 可以是下面原生构造器： StringNumberBooleanFunctionObjectArraySymbo","tags":[{"name":"Vue","slug":"Vue","permalink":"https://shleyz.github.io/tags/Vue/"}]},{"title":"Vue之表单输入","date":"2017-09-17T08:56:47.000Z","path":"2017/09/17/Vue之表单输入/","text":"v-model指令在表单控件元素上创建双向数据绑定。它本质上来说是一种语法糖（没有改变什么功能，只是对于程序员来说更容易理解），负责监听用户的输入事件以更新数据。它会根据控件类型自动选取正确的方法来更新元素。 注意： 1.v-model会忽略掉所有表单元素的value、checked、selected特性的初始值。因为它选择的是Vue的实力数据作为具体的值。所以应该在vue的data中声明初始值。 2.对于要求IME(input method如中文、日语、韩语等),v-model 不会在 ime 输入中得到更新。如果你也想实现更新，请使用 input 事件。 基础用法(v-model 绑定的 value 通常是静态字符串)1.文本: &lt;div id=&quot;test&quot;&gt; &lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt; &lt;p&gt;Message is: {{ message }}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;#test&apos;, data:{message:&quot;&quot;} }) &lt;/script&gt; 2.多行文本 注意：在文本区域插值 (&lt;textarea&gt;&lt;/textarea&gt;) 并不会生效，应用 v-model 来代替。 &lt;div id=&quot;test&quot;&gt; &lt;p&gt;多行文本：&lt;/p&gt; &lt;p style=&quot;white-space: pre-line;&quot;&gt;{{message}}&lt;/p&gt; &lt;textarea v-model=&quot;message&quot; placeholder=&quot;请输入多行文本&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;#test&apos;, data:{message:&quot;&quot;} }) &lt;/script&gt; 3.复选框 &lt;div id=&quot;test&quot;&gt; &lt;p&gt;复选框：&lt;/p&gt; &lt;input type=&quot;checkbox&quot; value=&quot;Joe&quot; id=&quot;Joe&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;Joe&quot;&gt;Joe&lt;/label&gt; &lt;input type=&quot;checkbox&quot; value=&quot;LiLei&quot; id=&quot;LiLei&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;LiLei&quot;&gt;LiLei&lt;/label&gt; &lt;input type=&quot;checkbox&quot; value=&quot;HanMeiMei&quot; id=&quot;HanMeiMei&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;HanMeiMei&quot;&gt;HanMeiMei&lt;/label&gt; &lt;p&gt;{{checkedNames}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;#test&apos;, data:{checkedNames:[]} }) &lt;/script&gt; for 属性规定 label 与哪个表单元素(id)绑定。 复选框v-model关联：数据为数组形式时，关联的是选中的复选框的value值。是字符串形式时，关联的则是选中的状态true／false 4.单选按钮 &lt;div id=&quot;test&quot;&gt; &lt;p&gt;单选框：&lt;/p&gt; &lt;input type=&quot;radio&quot; value=&quot;Joe&quot; id=&quot;Joe&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;Joe&quot;&gt;Joe&lt;/label&gt; &lt;input type=&quot;radio&quot; value=&quot;LiLei&quot; id=&quot;LiLei&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;LiLei&quot;&gt;LiLei&lt;/label&gt; &lt;input type=&quot;radio&quot; value=&quot;HanMeiMei&quot; id=&quot;HanMeiMei&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;HanMeiMei&quot;&gt;HanMeiMei&lt;/label&gt; &lt;p&gt;{{checkedNames}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;#test&apos;, data:{checkedNames:&apos;&apos;} }) &lt;/script&gt; 单选框v-model关联的只是单选选中的value值。 5.下拉框单选： &lt;div id=&quot;test&quot;&gt; &lt;p&gt;下拉框：&lt;/p&gt; &lt;select name=&quot;&quot; id=&quot;&quot; v-model=&quot;selected&quot;&gt; &lt;option value=&quot;请选择&quot; disabled&gt;请选择&lt;/option&gt; &lt;option value=&quot;A&quot;&gt;A&lt;/option&gt; &lt;option value=&quot;B&quot;&gt;B&lt;/option&gt; &lt;option value=&quot;C&quot;&gt;C&lt;/option&gt; &lt;/select&gt; &lt;p&gt;选择的是：{{selected}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;#test&apos;, data:{selected:&apos;&apos;} }) &lt;/script&gt; 多选下拉框只需要在select标签里面增加multiple 用v-for动态渲染： &lt;div id=&quot;test&quot;&gt; &lt;p&gt;v-for实现下拉框：&lt;/p&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt;{{option.text}}&lt;/option&gt; &lt;/select&gt; &lt;p&gt;选择的是：{{selected}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;#test&apos;, data:{ selected:&apos;A&apos;, options:[ {text:&apos;one&apos;,value:&apos;A&apos;}, {text:&apos;two&apos;,value:&apos;B&apos;}, {text:&apos;three&apos;,value:&apos;C&apos;} ] } }) &lt;/script&gt; 值绑定:(绑定 value 到 Vue 实例的一个动态属性上)1.复选框：v-bind:true-value=&quot;a&quot; v-bind:false-value=&quot;b&quot; &lt;div id=&quot;test&quot;&gt; &lt;p&gt;复选框：&lt;/p&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checkedNames&quot; v-bind:true-value=&quot;a&quot; v-bind:false-value=&quot;b&quot;&gt; &lt;p&gt;{{checkedNames}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;#test&apos;, data:{checkedNames:&apos;&apos;, a:&apos;yes&apos;, b:&apos;no&apos; }, }) &lt;/script&gt; 2.单选按钮&lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; v-bind:value=&quot;a&quot;&gt; &lt;div id=&quot;test&quot;&gt; &lt;p&gt;单选按钮：&lt;/p&gt; &lt;input type=&quot;radio&quot; v-model=&quot;select&quot; v-bind:value=&quot;a&quot;&gt; &lt;p&gt;{{select}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;#test&apos;, data:{select:&apos;&apos;, a:&apos;selected&apos; }, }) &lt;/script&gt; 3.下拉列表： &lt;div id=&quot;test&quot;&gt; &lt;p&gt;v-for实现下拉框：&lt;/p&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option v-bind:value=&quot;{number:123}&quot;&gt;123&lt;/option&gt; &lt;option v-bind:value=&quot;{number:456}&quot;&gt;456&lt;/option&gt; &lt;option v-bind:value=&quot;{number:789}&quot;&gt;789&lt;/option&gt; &lt;/select&gt; &lt;p&gt;选择的是：{{selected}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;#test&apos;, data:{ selected:&apos;&apos;, } }) &lt;/script&gt; v-model的修饰符.lazy 转变为在 change 事件中同步.number 自动将用户的输入值转为 Number 类型(如果原值的转换结果为 NaN 则返回原值).trim 自动过滤用户输入的首尾空格","tags":[{"name":"Vue","slug":"Vue","permalink":"https://shleyz.github.io/tags/Vue/"}]},{"title":"Vue之事件处理","date":"2017-09-17T07:58:58.000Z","path":"2017/09/17/Vue之事件处理/","text":"1.方法事件处理器 用 v-on 指令监听 DOM 事件来触发一些 JavaScript 代码.当事件处理的逻辑很复杂时，v-on 可以接收一个定义的方法来调用： &lt;div id=&quot;test&quot;&gt; &lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;#test&apos;, data:{ name:&apos;Vue.js&apos; }, methods:{ greet:function (event) { alert(&apos;hello&apos;+this.name+&apos;!&apos;); if(event){ alert(event.target.tagName); } } } }) &lt;/script&gt; 2.内联事件处理器 如果需要在内联语句里面访问原生DOM事件，可以使用特殊变量$event把它传入方法： &lt;div id=&quot;test&quot;&gt; &lt;button v-on:click=&quot;warn(&apos;Form cannot be submmit yet&apos;,$event)&quot;&gt;warn&lt;/button&gt; &lt;/div&gt; var vm = new Vue({ el:&apos;#test&apos;, methods:{ warn:function (msg,event) { if(event){ event.preventDefault(); } alert(msg); } } }) 3.事件修饰符 在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在 methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。为了解决这个问题，Vue.js 为 v-on 提供了 事件修饰符。通过由点 (.) 表示的指令后缀来调用修饰符。 .stop.prevent.capture.self.once &lt;!-- 阻止单击事件冒泡 --&gt; &lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt; &lt;!-- 提交事件不再重载页面 --&gt; &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt; &lt;!-- 修饰符可以串联 --&gt; &lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt; &lt;!-- 只有修饰符 --&gt; &lt;form v-on:submit.prevent&gt;&lt;/form&gt; &lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt; &lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt; &lt;!-- 只当事件在该元素本身 (比如不是子元素) 触发时触发回调 --&gt; &lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt; &lt;!-- 点击事件将只会触发一次 --&gt; &lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt; 4.键值修饰符 监听键盘事件的键值，Vue 为最常用的按键提供了别名。 &lt;div id=&quot;test&quot;&gt; &lt;input v-on:keyup.enter=&quot;sub&quot;&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;#test&apos;, methods:{ sub:function () { alert(&apos;回车事件&apos;); } } }) &lt;/script&gt; 全部的按键别名： .enter.tab.delete (捕获“删除”和“退格”键).esc.space.up.down.left.right 可以通过全局 config.keyCodes 对象自定义键值修饰符别名： // 可以使用 v-on:keyup.f1 Vue.config.keyCodes.f1 = 112 5.修饰键 可以用如下修饰符开启鼠标或键盘事件监听，使在按键按下时发生响应。 .ctrl.alt.shift.meta 注意：在 Mac 系统键盘上，meta 对应命令键 (⌘)。在 Windows 系统键盘 meta 对应 windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 键盘及其后续，比如 Knight 键盘，space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。 6.鼠标按钮修饰符 .left.right.middle这些修饰符会限制处理程序监听特定的滑鼠按键。","tags":[{"name":"Vue","slug":"Vue","permalink":"https://shleyz.github.io/tags/Vue/"}]},{"title":"Mac下chrome快捷键","date":"2017-09-17T01:54:27.000Z","path":"2017/09/17/Mac下chrome快捷键/","text":"1.标签页和窗口快捷键 快捷键 对应操作 ⌘-N 打开新窗口 ⌘-T 打开新标签页 ⌘-Shift-N 在隐身模式下打开新窗口 按 ⌘-O，然后选择文件 在 Chrome 浏览器中打开计算机中的文件 按住 ⌘ 的同时点击链接。或用鼠标中键（或鼠标滚轮）点击链接 从后台在新标签页中打开链接 按住 Shift 键的同时点击链接 在新窗口中打开链接 ⌘-Shift-T 重新打开上次关闭的标签页 同时按 ⌘-Option 和向右箭头键 切换到下一个标签页 同时按 ⌘-Option 和向左箭头键 切换到上一个标签页 2.Chrome 浏览器功能快捷键 快捷键 对应操作 ⌘-Shift-B 打开和关闭书签栏 ⌘-Option-B 打开书签管理器 ⌘-, 打开“偏好设置”对话框 ⌘-Y 打开“历史记录”页 ⌘-Shift-J 打开“下载内容”页 ⌘-Shift-Delete 打开“清除浏览数据”对话框 3.地址栏快捷键 快捷键 对应操作 ⌘-Shift-B 打开和关闭书签栏 ⌘-L 突出显示网址 ⌘-Option-F 在地址栏中输入“?”。在问号后键入搜索字词可用默认搜索引擎执行搜索 同时按 Option 和向左箭头键 将光标移到地址栏中的前一个关键字词 同时按 Option 和向右箭头键 在地址栏中将光标移到下一个关键字词 同时按 Shift-Option 和向左箭头键 在地址栏中突出显示上一关键字词 同时按 Shift-Option 和向右箭头键 在地址栏中突出显示下一关键字词 4.网页快捷键 快捷键 对应操作 ⌘-Shift-I 通过电子邮件发送当前网页 ⌘-R 重新载入当前网页 ⌘-, 停止载入当前网页 ⌘-Option-I 打开“开发人员工具” ⌘-Option-J 打开“JavaScript 控制台” ⌘-Option-U 打开当前网页的源代码 按住 Option 键，然后点击链接 下载链接目标 ⌘-D 将当前网页保存为书签&lt; ⌘-Shift-F 在全屏模式下打开网页。再按一次 ⌘-Shift-F 可退出全屏模式 ⌘-+ 放大网页上的所有内容 ⌘– 缩小网页上的所有内容 ⌘-0 将网页上的所有内容恢复到正常大小 ⌘-Shift-H 在当前标签页中打开主页 5.文本快捷键 快捷键 对应操作 ⌘-C 将突出显示的内容复制到剪贴板中 ⌘-V 从剪贴板中粘贴内容 ⌘-X 删除突出显示的内容并将其复制到剪贴板中 ⌘-Z 撤消最后一步操作 ⌘-Shift-Z 重复最后一步操作 ⌘-A 选择当前网页上的所有文本 ⌘-: 打开“拼写和语法”对话框","tags":[{"name":"chrome快捷键","slug":"chrome快捷键","permalink":"https://shleyz.github.io/tags/chrome快捷键/"}]},{"title":"Vue之条件渲染和列表渲染","date":"2017-09-16T05:47:58.000Z","path":"2017/09/16/Vue之条件渲染和列表渲染/","text":"1.条件渲染&lt;h1 v-if=&quot;ok&quot;&gt;YES&lt;/h1&gt; &lt;h1 v-else&gt;No&lt;/h1&gt; //v-else来表示else块 在template中配合v-if条件渲染一整组:&lt;template v-if=&quot;ok&quot;&gt; &lt;p&gt;title&lt;/p&gt; &lt;h2&gt;第一段落&lt;/h2&gt; &lt;h2&gt;第二段落&lt;/h2&gt; &lt;/template&gt; 把一个&lt;template&gt;元素当做包装元素，并在上面使用 v-if。最终的渲染结果不会包含 &lt;template&gt; 元素。 v-if／v-else-if／v-else组合使用: &lt;div id=&quot;isIf&quot;&gt; &lt;div v-if=&quot;ran &gt; 0.5&quot;&gt; 随机数大于0.5时显示 &lt;/div&gt; &lt;div v-else-if=&quot;ran == 0.5&quot;&gt; 随机数等于0.5时显示 &lt;/div&gt; &lt;div v-else&gt; 随机数小于0.5时显示 &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &apos;#isIf&apos;, data:{ ran: Math.floor(Math.random()*10)/10, //获取0-1的随机数 } }) &lt;/script&gt; 用key管理可复用的元素：&lt;div id=&quot;testKey&quot;&gt; &lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt; &lt;label&gt;Username:&lt;/label&gt; &lt;input placeholder=&quot;Enter your username&quot;&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;label&gt;Email:&lt;/label&gt; &lt;input placeholder=&quot;Enter your Email&quot;&gt; &lt;/template&gt; &lt;div&gt; &lt;button id=&quot;btn&quot;&gt;toggle login type&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &apos;#testKey&apos;, data: { loginType: &apos;username&apos;, } }) document.getElementById(&apos;btn&apos;).onclick = function () { if(vm.loginType == &apos;username&apos;){ vm.loginType = &apos;Email&apos;; }else{ vm.loginType = &apos;username&apos;; } } &lt;/script&gt; 这样执行之后会有一些问题：如果input标签中有内容的话，每次切换，input中的内容都是不变的，不能重新渲染input标签。 切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素， 不会被替换,仅仅是替换了它的 placeholder… 如果要不复用template的元素的话，就需要用key属性(具有唯一值):&lt;div id=&quot;testKey&quot;&gt; &lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt; &lt;label&gt;Username:&lt;/label&gt; &lt;input placeholder=&quot;Enter your username&quot; key=&quot;input-username&quot;&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;label&gt;Email:&lt;/label&gt; &lt;input placeholder=&quot;Enter your Email&quot; key=&quot;input-Email&quot;&gt; &lt;/template&gt; &lt;div&gt; &lt;button id=&quot;btn&quot;&gt;toggle login type&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; 现在，每次切换时，输入框都将被重新渲染。 v-show 也是根据条件展示元素的指令v-show 只是简单的切换CSS样式的display属性，不支持 &lt;template&gt; 语法，也不支持 v-else v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好。 2.列表渲染v-for根据一组数组的选项列表进行渲染:&lt;div id=&quot;testKey&quot;&gt; &lt;div v-for=&quot;item in items&quot;&gt; {{item.message}} &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &apos;#testKey&apos;, data: { items:[ {message:&apos;Joe&apos;}, {message:&apos;Li&apos;}, {message:&apos;Han&apos;} ], } }) &lt;/script&gt; 以v-for=“item in items”形式的特殊语法 还支持一个可选的第二个参数为当前项的索引：v-for=”(item, index) in items” 还可以用 of 替代 in 作为分隔符 &lt;div id=&quot;testKey&quot;&gt; &lt;div v-for=&quot;(item,index) in items&quot;&gt; {{headMessage}}-{{index}}-{{item.message}} &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &apos;#testKey&apos;, data: { headMessage: &apos;Class&apos;, items:[ {message:&apos;Joe&apos;}, {message:&apos;Li&apos;}, {message:&apos;Han&apos;} ], } }) &lt;/script&gt; 输出为： Class-0-Joe Class-1-Li Class-2-Han 对象的v-for：&lt;div id=&quot;testKey&quot;&gt; &lt;div v-for=&quot;(value,key,index) in object&quot;&gt; {{index}}:{{key}}:{{value}} &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &apos;#testKey&apos;, data: { object:{ first: &apos;zhap&apos;, second: &apos;lin&apos;, third: &apos;Joe&apos; } } }) &lt;/script&gt; v-for=&quot;(value,key,index) in object&quot;的三个参数分别对应对象的值，键名，索引 上面的代码输出为： 0:first:zhap 1:second:lin 2:third:Joe key当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。 如数据项的顺序被改变,Vue 将不会移动 DOM 元素来匹配数据项的顺序,而是简单复用此处每个元素,并且确保它在特定索引下显示已被渲染过的每个元素. 这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。 如果想要重用或者重新排序现有的元素，需要给每项提供唯一的key，用v-bind来绑定key。 &lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt; &lt;!-- 内容 --&gt; &lt;/div&gt; 数组更新检测1.变异方法(mutation method)： push(), 在数组末尾添加pop(), 删除数组末位shift(), 删除数组首位unshift(), 在数组首位添加splice(), 从数组中添加/删除项目sort(), 按规则排序reverse(),按原来顺序的倒序排列 这些变异方法会触发视图更新 2.非变异方法(non-mutating method): filter(),concat(),slice(), 这些不会改变原始数组,但总是返回一个新数组.这样不会重新渲染整个列表.Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的、启发式的方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。 3.注意事项 Vue不能检测以下变动的数组： 利用索引值来设置某项：vm.items[indexOfitem] = newValue 直接修改数组的长度：vm.items.length = newLength 想要实现相同效果并且出发更新，解决办法： Vue.set(vm.items,indexOfItem,newValue)或者 vm.items.splice(indexOfItem,1,newValue) vm.items.splice(newLength) 对象更改检测注意事项Vue 不能检测对象属性的添加或删除，可以这样实现: Vue.set(vm.userProfile, &apos;age&apos;, 27) 还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名: this.$set(this.userProfile, &apos;age&apos;, 27) 要添加多个属性，使用assign: this.userProfile = Object.assign({}, this.userProfile, { age: 27, favoriteColor: &apos;Vue Green&apos; }) 显示过滤／排序结果可以用计算属性computed实现，当计算属性不适用时可以用方法methods &lt;div id=&quot;testKey&quot;&gt; &lt;div v-for=&quot;n in evenNumbers&quot;&gt; {{n}} &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &apos;#testKey&apos;, data: { numbers:[1,2,3,4,5,6,7,8,9,10] }, computed:{ evenNumbers:function () { return this.numbers.filter(function (number) { return number%2 === 0; }) } } }) &lt;/script&gt; 用methods: &lt;div id=&quot;testKey&quot;&gt; &lt;div v-for=&quot;n in even(numbers)&quot;&gt; {{n}} &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &apos;#testKey&apos;, data: { numbers:[1,2,3,4,5,6,7,8,9,10] }, methods:{ even:function (numbers) { return numbers.filter(function (number) { return number%2 === 0; }) } } }) &lt;/script&gt; v-for和v-if当它们处于同一节点时，v-for的优先级比v-if高。意味着v-if将分别重复运行于v-for的每个循环中 &lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt; {{ todo }} &lt;/li&gt;","tags":[{"name":"Vue","slug":"Vue","permalink":"https://shleyz.github.io/tags/Vue/"}]},{"title":"Vue之绑定属性样式","date":"2017-09-15T08:06:12.000Z","path":"2017/09/15/Vue之绑定属性样式/","text":"1.绑定Class: 对象语法： &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;static&quot; v-bind:class=&quot;classObj&quot;&gt;aaaa&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;#app&apos;, data:{ classObj: { &apos;active&apos;: true, &apos;text-danger&apos;: true } } }) &lt;/script&gt; 数组语法： &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;static&quot; v-bind:class=&quot;[activeClass,errorClass]&quot;&gt;aaaa&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;#app&apos;, data:{ activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos; } }) &lt;/script&gt; 绑定到组件上时，这些类将被添加到根元素上面。这个元素上已经存在的类不会被覆盖。 2.绑定到内联样式： 对象语法： &lt;div id=&quot;app&quot;&gt; &lt;div v-bind:style=&quot;styleObj&quot;&gt;aaa&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;#app&apos;, data:{ styleObj:{ width: &apos;100px&apos;, height: &apos;100px&apos;, color: &apos;red&apos;, backgroundColor: &apos;orange&apos; } } }) &lt;/script&gt; 数组语法： &lt;div id=&quot;app&quot;&gt; &lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;aaa&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;#app&apos;, data:{ baseStyles:{ width: &apos;200px&apos;, height: &apos;200px&apos; }, overridingStyles:{ color: &apos;white&apos;, backgroundColor: &apos;red&apos;, transform: &apos;rotate(7deg)&apos; //旋转 } } }) &lt;/script&gt; 当 v-bind:style 使用需要特定前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。 多重值: &lt;div :style=&quot;{ display: [&apos;-webkit-box&apos;, &apos;-ms-flexbox&apos;, &apos;flex&apos;] }&quot;&gt;&lt;/div&gt;","tags":[{"name":"Vue","slug":"Vue","permalink":"https://shleyz.github.io/tags/Vue/"}]},{"title":"Vue之计算属性","date":"2017-09-14T07:57:09.000Z","path":"2017/09/14/Vue之计算属性/","text":"当模版比较复杂，不容易理解的时候可以使用计算属性： &lt;div id=&quot;app&quot;&gt; &lt;p&gt;message:&quot;{{msg}}&quot;&lt;/p&gt; &lt;p&gt;reverseMessage:&quot;{{reversedMessage}}&quot;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;#app&apos;, data:{ msg: &apos;我是msg&apos;, }, computed:{ reversedMessage:function () { return this.msg.split(&apos;&apos;).reverse().join(&apos;&apos;); } } }) &lt;/script&gt; 这样模版reversedMessage的属性值就与模版msg的属性值进行绑定。 计算属性的缓存VS方法：上面的计算属性可以用方法表示如下： &lt;div id=&quot;app&quot;&gt; &lt;p&gt;message:&quot;{{msg}}&quot;&lt;/p&gt; &lt;p&gt;reverseMessage:&quot;{{reversedMessage()}}&quot;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;#app&apos;, data:{ msg: &apos;我是msg&apos;, }, methods:{ reversedMessage:function () { return this.msg.split(&apos;&apos;).reverse().join(&apos;&apos;); } } }) &lt;/script&gt; 这里计算属性和方法的结果都是一致的。计算属性是基于它们的依赖进行缓存的,当msg的值没有改变时,多次访问reversedMessage时,计算属性会立即返回之前缓存的计算结果,而不会执行reversedMessage函数。而方法(methods),每次访问reversedMessage时，都会执行一次reversedMessage函数。 计算属性VS被观察的属性(watch)watch属性： &lt;div id=&quot;watch&quot;&gt;FullName:{{fullName}}&lt;/div&gt; &lt;script&gt; var vmWatch = new Vue({ el:&apos;#watch&apos;, data:{ firstName:&apos;xiao&apos;, lastName:&apos;hong&apos;, fullName:&apos;xiao hong&apos; }, watch:{ firstName: function (val) { this.fullName = val + &quot; &quot; + this.lastName; }, lastName:function (val) { this.fullName = this.firstName + &quot; &quot; + val; } } }) &lt;/script&gt; 如果用计算属性来实现相同的效果(相对watch属性来说简单)： computed:{ fullName: function () { return this.firstName + &quot; &quot; + this.lastName; } } 计算属性默认只有getter,但是可以自定义setter:&lt;div id=&quot;watch&quot;&gt;FullName:{{fullName}}&lt;/div&gt; &lt;script&gt; var vmWatch = new Vue({ el:&apos;#watch&apos;, data:{ firstName:&apos;xiao&apos;, lastName:&apos;hong&apos;, fullName:&apos;xiao hong&apos; }, computed:{ fullname:{ get: function () { return this.firstName + &quot; &quot; + this.lastName; }, set: function (newValue) { var names = newValue.split(&quot; &quot;); this.firstName = names[0]; this.lastName = names[names.length - 1]; } } } }) &lt;/script&gt; 运行 vm.fullName = ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也相应地会被更新。 watch&lt;div id=&quot;watch-example&quot;&gt; &lt;p&gt; 提出问题: &lt;input v-model=&quot;question&quot;&gt; &lt;/p&gt; &lt;p&gt;{{answer}}&lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var watchExampleVM = new Vue({ el:&apos;#watch-example&apos;, data:{ question: &quot;&quot;, answer: &quot;提问以后会有回答&quot; }, watch:{ question: function (newQuestion) { this.answer = &apos;等待你的输入...&apos;; this.getAnswer(); } }, methods:{ // _.debounce 是一个通过 lodash 限制操作频率的函数。 // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率 // ajax 请求直到用户输入完毕才会发出 getAnswer: _.debounce(function () { if(this.question.indexOf(&apos;?&apos;) === -1){ this.answer = &apos;问题需要一个问号来表示...&apos;; return } this.answer = &apos;认真思考中...&apos;; var vm = this; axios.get(&apos;https://yesno.wtf/api&apos;).then(function (response) { vm.answer = _.capitalize(response.data.answer) }).catch(function (error) { vm.answer = &apos;错误！不能获取API&apos; + error; }) },500) } }) &lt;/script&gt; 这里,使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这是计算属性无法做到的。 注：axios—–一个打包好的XMLHttpRequests，也就是说，是一个ajax库。可以实现: 1.在浏览器里建立XHR 2.通过nodejs进行http请求 甚至可以实现: 3.转换或者拦截请求数据或响应数据 4.支持Promise的API 5.可以取消请求 6.自动转换JSON 7.可以防御XSRF攻击！ lodash—–一套工具库，它内部封装了诸多对字符串、数组、对象等常见数据类型的处理函数，其中部分是目前 ECMAScript 尚未制定的规范，但同时被业界所认可的辅助函数。","tags":[{"name":"Vue","slug":"Vue","permalink":"https://shleyz.github.io/tags/Vue/"}]},{"title":"sass学习笔记","date":"2017-09-11T06:06:10.000Z","path":"2017/09/11/sass学习笔记/","text":"Sass 实时编译 sass –watch &lt;要编译的Sass文件路径&gt;/style.scss:&lt;要输出CSS文件路径&gt;/style.css Grunt 和 Gulp 自动化编译 Sass 编译常见的错误 在Sass的编译的过程中，是不是支持“GBK”编码的。所以在创建 Sass 文件时，就需要将文件编码设置为“utf-8”。 路径中的中文字符，建议在项目中文件命名或者文件目录命名不要使用中文字符 不同样式风格的输出方法 嵌套输出方式 nested 展开输出方式 expanded 紧凑输出方式 compact 压缩输出方式 compressed 默认变量sass 的默认变量仅需要在值后面加上 !default 即可。 $baseLineHeight:1.5 !default;body{line-height: $baseLineHeight;} sass 的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可。默认变量的价值在进行组件化开发的时候会非常有用。 Sass嵌套 选择器嵌套 nav {a {color: red; header &amp; {color:green;}}} 属性嵌套 .box {border: {top: 1px solid red;bottom: 1px solid green;}} 伪类嵌套 .clearfix{&amp;:before,&amp;:after {content:””;display: table;}&amp;:after {clear:both;overflow: hidden;}} 编译出来的 CSS： clearfix:before, .clearfix:after {content: “”;display: table;}.clearfix:after {clear: both;overflow: hidden;} 混合宏 声明混合宏 @mixin border-radius{-webkit-border-radius: 5px;border-radius: 5px;} 使用“@mixin”来声明一个混合宏。 调用混合宏 button {@include border-radius;} 关键词“@include”来调用声明好的混合宏 混合宏的参数–传多个参数 @mixin center($width,$height){width: $width;height: $height;position: absolute;top: 50%;left: 50%;margin-top: -($height) / 2;margin-left: -($width) / 2;} .box-center {@include center(500px,300px);} 有一个特别的参数“…”。当混合宏传的参数过多之时，可以使用参数来替代 @mixin box-shadow($shadows…){@if length($shadows) &gt;= 1 {-webkit-box-shadow: $shadows;box-shadow: $shadows;} @else {$shadows: 0 0 2px rgba(#000,.25);-webkit-box-shadow: $shadow;box-shadow: $shadow;}} .box {@include box-shadow(0 0 1px rgba(#000,.5),0 0 2px rgba(#000,.2));} 混合宏的不足 混合宏在实际编码中给我们带来很多方便之处，特别是对于复用重复代码块。但其最大的不足之处是会生成冗余的代码块。 @mixin border-radius{-webkit-border-radius: 3px;border-radius: 3px;} .box {@include border-radius;margin-bottom: 5px;} .btn {@include border-radius;} 编译出来的 CSS： .box {-webkit-border-radius: 3px;border-radius: 3px;margin-bottom: 5px;} .btn {-webkit-border-radius: 3px;border-radius: 3px;} 不能智能的将相同的样式代码块合并在一起 Sass扩展/继承通过关键词 “@extend”来继承已存在的类样式块，从而实现代码的继承。 //SCSS.btn {border: 1px solid #ccc;padding: 6px 10px;font-size: 14px;} .btn-primary {background-color: #f36;color: #fff;@extend .btn;} .btn-second {background-color: orange;color: #fff;@extend .btn;} 编译出来之后： //CSS.btn, .btn-primary, .btn-second {border: 1px solid #ccc;padding: 6px 10px;font-size: 14px;} .btn-primary {background-color: #f36;color: #fff;} .btn-second {background-clor: orange;color: #fff;} Sass占位符%%placeholder 声明的代码，如果不被 @extend 调用的话，不会产生任何代码。 //SCSS%mt5 {margin-top: 5px;}%pt5{padding-top: 5px;} .btn {@extend %mt5;@extend %pt5;} .block {@extend %mt5; span {@extend %pt5;}} 编译出来的CSS //CSS.btn, .block {margin-top: 5px;} .btn, .block span {padding-top: 5px;} Sass插值#{}$properties: (margin, padding);@mixin set-value($side, $value) {@each $prop in $properties { #{$prop}-#{$side}: $value;}}.login-box {@include set-value(top, 14px);} 上面的代码编译成 CSS： .login-box {margin-top: 14px;padding-top: 14px;} #{}语法并不是随处可用，不能在 mixin 中调用可以使用 @extend 中使用插值 %updated-status {margin-top: 20px;background: #F00;}.selected-status {font-weight: bold;}$flag: “status”;.navigation {@extend %updated-#{$flag};@extend .selected-#{$flag};} 上面的 Sass 代码是可以运行的，代码编译出来的 CSS: .navigation {margin-top: 20px;background: #F00;}.selected-status, .navigation {font-weight: bold;} Sass数据类型 数字 字符串 颜色 布尔值 空值 值列表 Sass指令 @if //SCSS@mixin blockOrHidden($boolean:true) {@if $boolean {@debug “$boolean is #{$boolean}”;display: block;}@else {@debug “$boolean is #{$boolean}”;display: none;}} .block {@include blockOrHidden;} .hidden{@include blockOrHidden(false);} 编译出来的CSS: .block {display: block;} .hidden {display: none;} @for循环 @for $i from through @for $i from to $i 表示变量，start 表示起始值，end 表示结束值。关键字 through 表示包括 end 这个数，而 to 则不包括 end 这个数。 through:@for $i from 1 through 3{.item-#{$i}{width:2em * $i;}}编译出来的 CSS: .item-1 {width: 2em;} .item-2 {width: 4em;} .item-3 {width: 6em;} to:@for $i from 1 to 3{.item-#{$i}{width:2em * $i;}} 编译出来的 CSS: .item-1 {width: 2em;} .item-2 {width: 4em;} @while 只要 @while 后面的条件为 true 就会执行 @each 遍历一个列表，然后从列表中取出对应的值 @each $var in Sass函数 unquote()函数 删除字符串中的引号； quote()函数 给字符串添加引号。如果字符串包含引号，不论单引号还是双引号，会统一替换为双引号。字符串中间有单引号或者空格时，需要用单引号或双引号括起，否则编译的时候将会报错。quote() 碰到特殊符号，比如： !、?、&gt; 等，除中折号-和下划线_都需要使用双引号括起，否则编译器在进行编译的时候同样会报错。 .test2 {content: quote(“today is sunday!”)} To-upper-case() 函数将字符串小写字母转换成大写字母。 To-lower-case() 将字符串转换成小写字母 //SCSS.test {text: to-upper-case(aaaaa);text: to-lower-case(aA-aAAA-aaa);} percentage() 数字函数 将一个不带单位的数字转换成百分比形式 .footer{width : percentage(.2)}如果转换的值是一个带有单位的值，那么在编译的时候会报错 round()函数 将一个数四舍五入为一个最接近的整数 .footer1 {width:round(15.8px)}//CSS.footer1 {width: 16px;} ceil()函数向上取整 .footer1 { width:ceil(18.1px);} //CSS .footer1 { width:19px;} floor()函数向下取整 abs()函数取绝对值 .footer { width:abs(-8.9px);} //CSS.footer { width:8.9px;} min()函数、max()函数 函数中同时出现两种不同类型的单位，将会报错误 random()函数 获取一个0-1随机数 length()函数 列表函数 nth()函数 列表函数 nth(10px 20px 30px,1)10px//从1开始 join()函数 列表函数 join(10px 20px, 30px 40px)(10px 20px 30px 40px)只能将两个列表连接成一个列表，如果直接连接两个以上的列表将会报错 append()函数 列表函数 将某个值插入到列表中，并且处于最末位 append((blue green),red,comma)(#0000ff, #008000, #ff0000)append((blue green),red,space)(#0000ff #008000 #ff0000)append((blue, green),red,comma)(#0000ff, #008000, #ff0000)append((blue, green),red,space)(#0000ff #008000 #ff0000)append(blue,red,comma)(#0000ff, #ff0000)append(blue,red,space)(#0000ff #ff0000) zip()函数 列表函数将多个列表值转成一个多维的列表 使用zip()函数时，每个单一的列表个数值必须是相同的 zip(1px 2px 3px,solid dashed dotted,green blue red)((1px “solid” #008000), (2px “dashed” #0000ff), (3px “dotted” #ff0000)) index()函数 列表函数 index(1px solid red, 1px)1index(1px solid red, solid)2index(1px solid red, red)3 如果指定的值不在列表中（没有找到相应的值），那么返回的值将是 false，相反就会返回对应的值在列表中所处的位置。 type-of() Introspection 函数 判断一个值是属于什么类型： 返回值： number 为数值型。string 为字符串型。bool 为布尔型。color 为颜色型。 unit()函数 Introspection 函数 获取一个值所使用的单位 unit(100)“”unit(100px)“px”unit(20%)“%”unit(1em)“em”unit(10px 3em)“empx”unit(10px / 3em)“px/em”unit(10px * 2em / 3cm / 1rem)“em/rem” unitless()函数 Introspection 函数 判断一个值是否带有单位，如果不带单位返回的值为 true，带单位返回的值为 false代码实现：用户在调用混合宏时，如果用户没有给参数值加上单位，程序会自动加入单位。@mixin adjust-location($x, $y) {@if unitless($x) {$x: 1px $x;}@if unitless($y) {$y: 1px $y;}position: relative;left: $x;top: $y;} .botton{@include adjust-location(20px, 30);} comparable()函数 Introspection 函数 判断两个数是否可以进行“加，减”以及“合并”。如果可以返回的值为 true，如果不可以返回的值是 false comparable(2px,1%)falsecomparable(2px,1em)falsecomparable(2rem,1em)falsecomparable(2px,1cm)truecomparable(2px,1mm)true Miscellaneous函数 if($condition,$if-true,$if-false)当 $condition 条件成立时，返回的值为 $if-true，否则返回的是 $if-false 值。 if(true,1px,2px)1pxif(false,1px,2px)2px map-get($map,$key) Maps的函数返回 $key 在 $map 中对应的 value 值。如果 $key 不存在 $map中，将返回 null 值。 $social-colors: (dribble: #ea4c89,facebook: #3b5998,github: #171515,google: #db4437,twitter: #55acee);.btn-dribble{color: map-get($social-colors,facebook);}如果 $key 不在 $map 中，不会编译出 CSS map-has-key($map,$key) Maps的函数函数将返回一个布尔值。当 $map 中有这个 $key，则函数返回 true，否则返回 false。 @function colors($color){@if not map-has-key($social-colors,$color){@warn “No color found for #{$color} in $social-colors map. Property omitted.”;}@return map-get($social-colors,$color);} .btn-dribble {color: colors(dribble);}.btn-facebook {color: colors(facebook);}.btn-github {color: colors(github);} map-keys($map) Maps的函数返回 $map 中的所有 key map-keys($social-colors); map-values($map) Maps的函数获取的是 $map 的所有 value 值，可以说是一个列表。 map-values($social-colors) map-merge($map1,$map2) Maps的函数 map-merge($map1,$map2)将 $map1 和 $map2 合并，然后得到一个新的 $map。如果 $map1 和 $map2 中有相同的 $key 名，那么将 $map2 中的 $key 会取代 $map1 中的 $color: (text: #f36,link: #f63,border: #ddd,backround: #fff);$typo:(font-size: 12px,line-height: 1.6,border: #ccc,background: #000); $newmap: map-merge($color,$typo); $newmap:(text: #f36,link: #f63,font-size: 12px,line-height: 1.6,border: #ccc,background: #000); map-remove($map,$key) Maps的函数 map-remove($map,$key) 删除当前 $map 中的某一个 $key，从而得到一个新的 map。其返回的值还是一个 map。他并不能直接从一个 map 中删除另一个 map，仅能通过删除 map 中的某个 key 得到新 map。 keywords($args) RGBA()函数将一个颜色根据透明度转换成 rgba 颜色 rgba($red,$green,$blue,$alpha) //将一个rgba颜色转译出来，和未转译的值一样rgba($color,$alpha) //将一个Hex颜色转换成rgba颜色 @import引入 SCSS 和 Sass 文件。 所有引入的 SCSS 和 Sass 文件都会被合并并输出一个单一的 CSS 文件。 被导入的文件中所定义的变量或 mixins 都可以在主文件中使用。 @media在样式中使用 @media 指令，它将冒泡到外面 .sidebar {width: 300px;@media screen and (orientation: landscape) {width: 500px;}}编译出来： .sidebar {width: 300px; }@media screen and (orientation: landscape) {.sidebar {width: 500px; } } @extend Sass 中的 @extend 是用来扩展选择器或占位符。比如： .error {border: 1px #f00;background-color: #fdd;}.error.intrusion {background-image: url(“/image/hacked.png”);}.seriousError {@extend .error;border-width: 3px;}被编译为： .error, .seriousError {border: 1px #f00;background-color: #fdd; } .error.intrusion, .seriousError.intrusion {background-image: url(“/image/hacked.png”); } .seriousError {border-width: 3px; } @at-root跳出根元素 .a {color: red; .b {color: orange; .c {color: yellow; @at-root .d {color: green;}}}}编译出来的CSS .a {color: red;} .a .b {color: orange;} .a .b .c {color: yellow;} .d {color: green;} @debug @debug 在 Sass 中是用来调试的，当你的在 Sass 的源码中使用了 @debug 指令之后，Sass 代码在编译出错时，在命令终端会输出你设置的提示 Bug: @debug 10em + 12em;会输出： Line 1 DEBUG: 22em @warn @warn 和 @debug 功能类似，用来帮助我们更好的调试 Sass。如： @mixin adjust-location($x, $y) {@if unitless($x) {@warn “Assuming #{$x} to be in pixels”;$x: 1px $x;}@if unitless($y) {@warn “Assuming #{$y} to be in pixels”;$y: 1px $y;}position: relative; left: $x; top: $y;} @error@mixin error($x){@if $x &lt; 10 {width: $x * 10px;} @else if $x == 10 {width: $x;} @else {@error “你需要将#{$x}值设置在10以内的数”;} } .test {@include error(15);}","tags":[{"name":"sass","slug":"sass","permalink":"https://shleyz.github.io/tags/sass/"}]},{"title":"vue之模版","date":"2017-09-09T07:29:19.000Z","path":"2017/09/09/vue之模版/","text":"模版语法:1.使用Mustache语法(双大括号)的文本插值(将msg值解读为文本),只要绑定的对象上的msg值发生变化，插值处的内容都会变化。但是当使用v-once指令时，可以一次性使用插值，以后msg值发生变化，插值的内容也不会变化。 &lt;span&gt;Message:{{msg}}&lt;/span&gt; &lt;span v-once&gt;这里面的值不会变化{{msg}}&lt;/span&gt; 2.如果想解读为html代码的话，使用v-html指令： &lt;div v-html = &quot;rawHtml&quot;&gt;&lt;/div&gt; 这样这个div的内容就会被rawHtml的值给替换掉。（这样很容易导致xss攻击，最好不要对用户提供的内容进行插值） 4.使用v-bind指令给元素绑定属性。(id/class/…/自定义属性等) &lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt; 5.模版的双大括号中使用表达式(只能是单个表达式，不能是语句声明，不能是多个表达式，可以是三元表达式): {{ok?'YES':'NO'}} &lt;div v-bind:id=&quot;&apos;list&apos;+id&quot;&gt;&lt;/div&gt; 6.vue的指令(v-bind,v-once,v-html,v-if)的职责是:当表达式的值改变时，其产生的连带影响，响应式的作用到dom.指令的值一般为单个表达式，除v-for之外.一个指令只能接受一个参数。 &lt;p v-if=&quot;seen&quot;&gt;如果seen值为true，你就能看到我&lt;/p&gt; &lt;p v-on:click=&quot;dosomething&quot;&gt;点我有惊喜哦&lt;/p&gt; 7.缩写（Vue.js 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写): &lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt; &lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt; &lt;p v-on:click=&quot;dosomething&quot;&gt;点我有惊喜哦&lt;/p&gt; &lt;p @click=&quot;dosomething&quot;&gt;点我有惊喜哦&lt;/p&gt;","tags":[{"name":"Vue","slug":"Vue","permalink":"https://shleyz.github.io/tags/Vue/"}]},{"title":"正则表达式贪婪模式与非贪婪模式","date":"2017-09-04T15:43:04.000Z","path":"2017/09/04/正则表达式贪婪模式与非贪婪模式/","text":"源字符串： var url = ‘http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;d&amp;enabled&#39; 正则表达式一： url.match(/user=(\\S*)&amp;/)[1] 匹配结果一： “anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;d” 正则表达式二： url.match(/user=(\\S*?)&amp;/)[1] 匹配结果二： “anonymous”（这里指的是一次匹配结果，所以没包括&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;d”） 正则表达式一采用的是贪婪模式，在匹配到第一个“&amp;”时已经可以使整个表达式匹配成功，但是由于采用的是贪婪模式，所以仍然要向右尝试匹配，查看是否还有更长的可以成功匹配的子串，匹配到第五个“&amp;”后，向右再没有可以成功匹配的子串，匹配结束，匹配结果为“anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;d”。 正则表达式二采用的是非贪婪模式，在匹配到第一个“&amp;”时使整个表达式匹配成功，由于采用的是非贪婪模式，所以结束匹配，不再向右尝试，匹配结果为”anonymous”。","tags":[{"name":"正则","slug":"正则","permalink":"https://shleyz.github.io/tags/正则/"}]},{"title":"JSON长度","date":"2017-09-01T08:38:28.000Z","path":"2017/09/01/JSON长度/","text":"JSON没有length属性 var json = {name:&quot;xiaoming&quot;,sex:&quot;male&quot;} function getJsonLength(jsonData){ var jsonLength = 0; for(var item in jsonData){ jsonLength++; } return jsonLength; } getJsonLength(json); //2","tags":[{"name":"JSON","slug":"JSON","permalink":"https://shleyz.github.io/tags/JSON/"}]},{"title":"伪元素和伪类","date":"2017-08-28T06:54:18.000Z","path":"2017/08/28/伪元素和伪类/","text":"伪元素 :first-letter向文本的第一个字母添加特殊样式。 :first-line向文本的首行添加特殊样式。 :before在元素之前添加内容。 :after在元素之后添加内容。 伪类锚伪类 a:link a:visited a:hover a:active 在 CSS 定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。 在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。 伪类名称对大小写不敏感。 其他 :first-child 选择元素的第一个子元素 :lang 为不同的语言定义特殊的规则 &lt;html&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; q:lang(no) { quotes: &quot;~&quot; &quot;~&quot; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;文字&lt;q lang=&quot;no&quot;&gt;段落中的引用的文字&lt;/q&gt;文字&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;","tags":[{"name":"伪元素","slug":"伪元素","permalink":"https://shleyz.github.io/tags/伪元素/"}]},{"title":"CSS中的rem","date":"2017-08-28T06:06:49.000Z","path":"2017/08/28/CSS中的rem/","text":"rem是CSS3引进的一个新的单位，在W3C官网上是这样描述rem的——“font size of the root element” . rem相对于的是根元素html. 不能兼容IE6-8，可以px和rem同时使用。","tags":[{"name":"CSS","slug":"CSS","permalink":"https://shleyz.github.io/tags/CSS/"}]},{"title":"about","date":"2017-08-26T16:23:46.000Z","path":"2017/08/27/index/","text":"","tags":[]},{"title":"自动化测试工具","date":"2017-08-17T05:44:42.000Z","path":"2017/08/17/自动化测试工具/","text":"1.Web自动化测试： SeleniumRobot Framework 2.App移动端自动化测试 AppiumUiautomatorMonkeyrunner 3.PC客户端自动化测试 QTP 4.接口自动化测试 HttpUnitPostman - Chrome插件Python 5.云测平台 TestinTestBird","tags":[]},{"title":"jquery组件开发","date":"2017-08-15T07:12:20.000Z","path":"2017/08/15/jquery组件开发/","text":"jQuery插件就是用来扩展jQuery原型对象的一个方法，即是jQuery对象的一个方法。jQuery插件的使用方法就是jQuery对象方法的调用。 基础版jQuery插件知道了上面这些知识，我们就可以来写一个简单的jQuery插件。假如我现在需要一个jQuery插件用来改变标签内容颜色，就可以按下面的方式来实现这个插件： $.fn.changeStyle = function(colorStr){ this.css(&quot;color&quot;,colorStr); } 然后按下面的方式来使用插件： $(&quot;p&quot;).changeStyle(&quot;red&quot;); 插件调用的时候，插件内部的this就是当前调用插件的jQuery对象，这样的话每个使用$()方法选择的标签，在调用changeStyle()插件时都会使用css()方法重设color样式。 满足链式调用的jQuery插件链式调用时jQuery的一大特色，一个通用的插件应该遵循jQuery风格，满足链式调用要求。实现链式调用的方式也很简单： $.fn.changeStyle = function(colorStr){ this.css(&quot;color&quot;,colorStr); return this; } 然后使用的时候就可以链式调用其他方法了： $(&quot;p&quot;).changeStyle(&quot;red&quot;).addClass(&quot;red-color&quot;); 实现链式调用的关键点就一行代码return this，插件中加了这行代码，那么在插件执行完之后，就会把当前的jQuery对象返回，然后就可以在插件方法后面继续调用其它jQuery方法。 防止$符号污染的jQuery插件有很多js库都会使用$符号，虽然jQuery可以使用jQuery.noConflict()方法交出$符号的使用权，但是如果定义插件的时候，使用$.fn对象来定义的，那么这些插件使用的时候就会受到其它使用$变量的js库的影响。对于这种情况，我们可以使用立即执行函数通过传参的方式封装插件。形式如下： (function($){ $.fn.changeStyle = function(colorStr){ this.css(&quot;color&quot;,colorStr); return this; } }(jQuery)); 因为使用了立即执行函数，所以此时的$只属于这个立即执行函数的函数作用域，这样就可以避免$符号的污染。 可以接受参数的jQuery插件继续上面的例子，假如我还想为这个插件添加一个设置标签元素内容文字大小的功能，那么我可以这么来实现： (function($){ $.fn.changeStyle = function(colorStr，fontSize){ this.css(&quot;color&quot;,colorStr).css(&quot;fontSize&quot;,fontSize+&quot;px&quot;); return this; } }(jQuery)); 上面这种插件传参方式适用于参数比较少的情况，如果需要传给插件内部的参数比较多，我们可以定义一个参数对象，然后把需要传给插件的参数放在参数对象中。插件定义时如下： (function($){ $.fn.changeStyle = function(option){ this.css(&quot;color&quot;,option.colorStr).css(&quot;fontSize&quot;,option.fontSize+&quot;px&quot;); return this; } }(jQuery)); 使用方式：$(“p”).changeStyle({colorStr:”red”,fontSize:14});把参数放到一个对象中传给插件还有一个好处就是我们可以在插件内部为一些参数定义一些缺省值，例如： (function($){ $.fn.changeStyle = function(option){ var defaultSetting = { colorStr:&quot;green&quot;,fontSize:12}; var setting = $.extend(defaultSetting,option); this.css(&quot;color&quot;,setting.colorStr).css(&quot;fontSize&quot;,setting.fontSize+&quot;px&quot;); return this; } }(jQuery)); 上面的代码用到了$.extend方法，这个方法在这里的用法就是合并两个对象，即把后面一个对象的存在的属性值赋值给第一个对象。$.extend方法还有一种作用是用来扩展jQuery对象本身。 这样定义的插件，我们在使用时如果不传fontSize，那么使用这个插件的jQuery对象标签的内容会被设置成默认的12px。使用方式： $(&quot;p&quot;).changeStyle({colorStr:&quot;red&quot;}); 注意：在为插件定义默认参数时，一定要把默认参数写在插件方法内部，这样默认参数的作用域就在插件内部。 定义插件的方式除了上面说的用$.fn来定义，还有另外一种方式来定义插件，那就是使用$.fn.extend方法。类似下面的写法： (function($){ $.fn.extend({ changeStyle:function(option){ var defaultSetting = { colorStr:&quot;green&quot;,fontSize:12}; var setting = $.extend(defaultSetting,option); this.css(&quot;color&quot;,setting.colorStr).css(&quot;fontSize&quot;,setting.fontSize+&quot;px&quot;); return this; } }); }(jQuery)); PS:$.extend方法和$.fn.extend方法都可以用来扩展jQuery功能，通过阅读jQuery源码我们可以发现这两个方法的本质区别，那就是$.extend方法是在jQuery全局对象上扩展方法，$.fn.extend方法是在$选择符选择的jQuery对象上扩展方法。所以扩展jQuery的公共方法一般用$.extend方法，定义插件一般用$.fn.extend方法。 文章源自：留七七 http://www.jianshu.com/p/518d424d4994","tags":[{"name":"组件开发","slug":"组件开发","permalink":"https://shleyz.github.io/tags/组件开发/"}]},{"title":"seleniumIDE常用命令","date":"2017-07-13T08:15:53.000Z","path":"2017/07/13/seleniumIDE常用命令/","text":"1、open（URL）命令 1、作用：打开指定的URL，URL或者为相对或是绝对的URL 2、target：要打开的URL，value值为空 当target为空的时候，将要打开baseURL中填写的页面 当target不为空切值为相对路径，将打开baseURL+target页面，如，假设baseURL为：https://home.cnblogs.com 而target为/blog/all/，则执行open命令的时候，将打开：https://home.cnblogs.com/blog/all/ 3、当target以http://开头的时候，将忽略baseURL，直接打开target的网址 2、pause（暂停） 1、作用：暂停脚本运行 2、waittime：等待时间，单位ms 3、goBack() 1,作用：模拟单机浏览器的后退按钮，（2）由于没有参数，所以target和value可不填 4、refresh() 1、作用：刷新当前页面 2、由于没有参数，所以target和value可不填 5、click() 1、作用：单击一个按钮，链接，复选框或者单选按钮 2、如果该单击事件导致新的页面加载，命令将会加上后缀AndWait,即clickAndWait,或者waitForToLoad命令 6、type 1、作用：向指定输入域中输入指定的值，也可以为下拉框，复选框，和单选按钮赋值 2、target：元素的定位表达式 3、value：要输入的值 7、selec(selectLocator,optionLocator) 1、作用：模拟人工单击下拉列表框，selectLocator：指向指定选择元素的定位器optionLocator：选项的选择器，（默认为标签） 2、注意下：选项的定位方式和下拉框的定位方式有所不同， 选项的定位方式：label和Value label=文本值，基于选项的文本进行匹配（默认方式），如label=three Value=实际值，基于选项的真实进行匹配的，如：value=4 8、close() 1、用于模拟用户单击窗口上的关闭按钮 2、没有参数，target和value可以不填写","tags":[]},{"title":"html5特性","date":"2017-07-12T07:53:19.000Z","path":"2017/07/12/html5新特性/","text":"1.新的文档类型 xhtml1.0: &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; 在html5中上面的方法失效： &lt;!DOCTYPE html&gt; 2.脚本和链接无需type 在HTML4或XHTML中： &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/stylesheet.css&quot; type=&quot;text/css&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;path/to/script.js&quot;&gt;&lt;/script&gt; 在html5中： &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/stylesheet.css&quot; /&gt; &lt;script src=&quot;path/to/script.js&quot;&gt;&lt;/script&gt; 3.新增语义化标签Header,Footer ,nav,aside,article,section。 [&lt;article&gt;&lt;/article&gt;](http://www.w3school.com.cn/tags/tag_article.asp) ##article标签规定独立的自包含内容 [&lt;aside&gt;&lt;/aside&gt;](http://www.w3school.com.cn/tags/tag_aside.asp) ##aside 的内容应该与附近的内容相关,可用作文章的侧栏。 [&lt;audio src=&quot;&quot;&gt;提示&lt;/audio&gt;](http://www.w3school.com.cn/tags/tag_audio.asp) ##定义声音，比如音乐或其他音频流。 [&lt;bdi dir=&quot;&quot;&gt;&lt;/bdi&gt;](http://www.w3school.com.cn/tags/tag_bdi.asp) ##定义文本的文本方向，使其脱离其周围文本的方向设置。 [&lt;canvas&gt;&lt;/canvas&gt;](http://www.w3school.com.cn/tags/tag_canvas.asp) ##定义图形 [&lt;command&gt;&lt;/command&gt;](http://www.w3school.com.cn/tags/tag_command.asp) ##定义命令按钮，比如单选按钮、复选框或按钮。 [&lt;datalist&gt;&lt;/datalist&gt;](http://www.w3school.com.cn/tags/tag_datalist.asp) ##datalist 及其选项不会被显示出来，它仅仅是合法的输入值列表。 [&lt;details&gt;&lt;/details&gt;](http://www.w3school.com.cn/tags/tag_details.asp) ##用于描述文档或文档某个部分的细节。其内部搭配使用summary标签和p标签。 [&lt;summary&gt;&lt;/summary&gt;](http://www.w3school.com.cn/tags/tag_summary.asp) ##包含 details 元素的标题 [&lt;dialog&gt;&lt;/dialog&gt; ](http://www.w3school.com.cn/tags/tag_dialog.asp) ##定义对话框或窗口。 [&lt;embed src=&quot;&quot; type=&quot;&quot; /&gt;](http://www.w3school.com.cn/tags/tag_embed.asp) ##定义嵌入的内容，比如插件。 [&lt;figcaption&gt;&lt;/figcaption&gt;](http://www.w3school.com.cn/tags/tag_figcaption.asp) ##定义 figure 元素的标题 [&lt;figure&gt;&lt;/figure&gt;](http://www.w3school.com.cn/tags/tag_figure.asp) ##规定独立的流内容（图像、图表、照片、代码等等） [&lt;footer&gt;&lt;/footer&gt;](http://www.w3school.com.cn/tags/tag_footer.asp) ##页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等 [&lt;header&gt;&lt;/header&gt;](http://www.w3school.com.cn/tags/tag_header.asp) ##定义文档的页眉（介绍信息） [&lt;keygen&gt;&lt;/keygen&gt;](http://www.w3school.com.cn/tags/tag_keygen.asp) ##规定用于表单的密钥对生成器字段 [&lt;mark&gt;&lt;/mark&gt;](http://www.w3school.com.cn/tags/tag_mark.asp) ##定义带有记号的文本。 [&lt;meter&gt;&lt;/meter&gt;](http://www.w3school.com.cn/tags/tag_meter.asp) ##使用 meter 元素来度量给定范围（gauge）内的数据 [&lt;nav&gt;&lt;/nav&gt;](http://www.w3school.com.cn/tags/tag_nav.asp) ##定义导航链接的部分。 [&lt;output&gt;&lt;/output&gt;](http://www.w3school.com.cn/tags/tag_output.asp) ##定义不同类型的输出，比如脚本的输出。 [&lt;progress&gt;&lt;/progress&gt;](http://www.w3school.com.cn/tags/tag_progress.asp) ##标示任务的进度（进程） [&lt;rp&gt;&lt;/rp&gt;](http://www.w3school.com.cn/tags/tag_rp.asp) ##支持 &quot;ruby&quot; 元素的浏览器不会显示 &quot;rp&quot; 元素的内容。 [&lt;rt&gt;&lt;/rt&gt;](http://www.w3school.com.cn/tags/tag_rt.asp) ##定义字符（中文注音或字符）的解释或发音 [&lt;ruby&gt;&lt;/ruby&gt;](http://www.w3school.com.cn/tags/tag_ruby.asp) ##定义 ruby 注释（中文注音或字符） [&lt;section&gt;&lt;/section&gt;](http://www.w3school.com.cn/tags/tag_section.asp) ##文档中的区段 [&lt;source /&gt;](http://www.w3school.com.cn/tags/tag_source.asp) ##为媒介元素（比如video和audio）定义媒介资源 [&lt;time&gt;&lt;/time&gt;](http://www.w3school.com.cn/tags/tag_time.asp) ##定义公历的时间（24 小时制）或日期，时间和时区偏移是可选的。在任何浏览器中不会呈现任何特殊效果 [&lt;track&gt;&lt;/track&gt;](http://www.w3school.com.cn/tags/tag_track.asp) ##为诸如 video 元素之类的媒介规定外部文本轨道 [&lt;video src=&quot;&quot;&gt;&lt;/video&gt;](http://www.w3school.com.cn/tags/tag_video.asp) ##定义视频，比如电影片段或其他视频流 [&lt;wbr&gt;&lt;/wbr&gt;](http://www.w3school.com.cn/tags/tag_wbr.asp) ##规定在文本中的何处适合添加换行符 4.window.navigator.geolocation","tags":[{"name":"html","slug":"html","permalink":"https://shleyz.github.io/tags/html/"}]},{"title":"CSS之盒子模型","date":"2017-07-10T06:22:32.000Z","path":"2017/07/10/CSS之盒子模型/","text":"1.盒子的内部结构：在一个文档中，每个元素都被表示为一个矩形的盒子。确定这些盒子的尺寸, 属性像它的颜色，背景，边框方面和位置是渲染引擎的目标。 模型是对某种事物本质特性的抽象。 一个独立的盒子模型由：content（内容），padding（内边距），border（边框）和margin（外边距）组成。 一个盒子的宽度由“content + 2 x（padding+border+margin）”组成。 2.内容区域content包含元素的真实内容，它通常包含背景，颜色和图片等，它的宽度为content-box的宽度。 如果 box-sizing 为默认值， width, min-width, max-width, height, min-height 与 max-height 控制内容大小。 3.内边距区域padding作用域content的背景、颜色等会延伸到padding上。即元素的背景颜色等属性的作用范围是content+padding。 他的宽是padding-box的宽度 4.边框border包含了边框的区域，他的宽是border-box的宽度 5 外边距margin用空白区域扩展元素，以分开相邻的元素。 它的大小为 margin-box 的高宽。 6.外边距塌陷块的顶部外边距和底部外边距有时被组合(折叠)为单个外边距，其大小是组合到其中的最大外边距，这种行为称为外边距塌陷(margin collapsing)，有的地方翻译为外边距合并。 发生外边距塌陷的三种情况 1.相邻的兄弟元素 &lt;p style=&quot;margin-bottom: 30px;&quot;&gt;这个段落的下外边距被合并...&lt;/p&gt; &lt;p style=&quot;margin-top: 20px;&quot;&gt;...这个段落的上外边距被合并。&lt;/p&gt; 2.块级元素与它的第一个或最后一个子元素（前提是父元素与子元素中间没有border、padding、inline content、height、min-height、 max-height来分隔时）3.一个空的块级元素，其 border、padding、inline content、height、min-height 都不存在。那么此时它的上下边距中间将没有任何阻隔，此时它的上下外边距将会合并。 &lt;p style=&quot;margin-bottom: 0px;&quot;&gt;这个段落的和下面段落的距离将为20px&lt;/p&gt; &lt;div style=&quot;margin-top: 20px; margin-bottom: 20px;&quot;&gt;&lt;/div&gt; &lt;p style=&quot;margin-top: 0px;&quot;&gt;这个段落的和上面段落的距离将为20px&lt;/p&gt; 当有负边距存在时，合并后的外边距将是最大正边距加上最小负边距（即负边距中绝对值最大的一个）。 7.box-sizing用于更改用于计算元素宽度和高度的默认CSS盒子模型。box-sizing默认值：content-box。 默认是当设置元素的宽度width为100px时，实际是元素的content宽度是100px。 box-sizing设置为border-box时： 当设置元素的宽度width为100px时，其实是congtent+padding+border的宽度是100px。 box-sizing设置为padding-box时：(只有Firefox实现了这个值，它在Firefox 50中被删除。) 当设置元素的宽度width为100px时，其实是congtent+padding的宽度是100px。 因此box-sizing只有默认值content-box和border-box 实现兼容各个浏览器： Element { -moz-box-sizing: content-box; -webkit-box-sizing: content-box; -o-box-sizing: content-box; -ms-box-sizing: content-box; box-sizing: content-box; } Element { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; -o-box-sizing: border-box; -ms-box-sizing: border-box; box-sizing: border-box; } margin越界当父元素没有边框border时，设置第一个子元素的margin-top值的时候，会出现margin-top值加在父元素上的现象，解决方法有四个： （1）给父元素加边框border （副作用） （2）给父元素设置padding值 （副作用） （3）父元素添加 overflow：hidden （副作用） （4）父元素加前置内容生成。（推荐） 第四种方法的实现： .parent{ width: 300px; height: 300px; background-color: cadetblue; } .parent:before { content : &quot;&quot;; display : table; } .child{ width: 50px; height: 50px; margin: 20px; background-color: #9ea040; } 绘制三角形.child{ width: 0; height: 0; border: 100px solid transparent; border-right: 100px solid yellow; } 子元素浮动后父元素高度为0（父元素不设置高度）.parent{ width: 300px; background-color: cadetblue; } .child{ width: 50px; height: 50px; float:left; background-color: #4932ff; } css如上,这时parent高度为0，不显示。 要解决这个问题 （1）overflow：hidden，但是这样有副作用。（2）为父元素设置后置内容生成： .parent{ width: 300px; background-color: cadetblue; } .parent:after{ content:&apos; &apos;; display: table; clear: both; } .child{ width: 50px; height: 50px; float:left; background-color: #4932ff; }","tags":[{"name":"CSS","slug":"CSS","permalink":"https://shleyz.github.io/tags/CSS/"}]}]