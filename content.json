[{"title":"js路由跳转不刷新页面实现","date":"2021-02-02T05:18:39.000Z","path":"2021/02/02/interview-js路由跳转不刷新页面实现/","text":"利用 history API： state, pushState, replaceState。 history.state当前 url 的状态信息。如果当前 url 不是通过 pushState, replaceState 跳转过来的，那么 history.state 就是 null。 history.pushState(state, title, url)将当前 URL 和 history.state 加入到 history 中，并用新的 state 和 URL 替换当前。不会造成页面刷新。state：与要跳转到的URL对应的状态信息。title：当前大多数浏览器都忽略此参数，但是将来可能会使用它。 在此处传递空字符串应该可以防止将来对方法的更改。 或者，您可以为要跳转到的地址传递简短标题。 如果需要更改标题，可以使用document.title。url：要跳转到的URL地址，不能跨域。 history.replaceState用新的state和URL替换当前。不会造成页面刷新。state：与要跳转到的 URL 对应的状态信息。title：当前大多数浏览器都忽略此参数，但是将来可能会使用它。 在此处传递空字符串应该可以防止将来对方法的更改。 或者，您可以为要跳转到的地址传递简短标题。 如果需要更改标题，可以使用document.title。url：要跳转到的URL地址，不能跨域。 window.onpop","tags":[{"name":"js基础","slug":"js基础","permalink":"https://shleyz.github.io/tags/js基础/"}]},{"title":"antdPro","date":"2020-05-08T02:21:02.000Z","path":"2020/05/08/antdPro/","text":"作者是这样描述的：dva 是 react 和 redux 的最佳实践。 而 antd-pro 就是作者把 UI 工具 antd，打包工具 roadhog，路由 react-router，状态管理器 dva 整合在一起 dva 数据流 service：请求定义，并且按照 model 的维度进行拆分 utils/request.ts：统一的请求发送和错误处理 model: 处理数据逻辑部分，包含 state 初始值 和 reducers（相当于 redux 里面的 reducer，根据 action 来更新 state） 创建一个页面，除了需要配置相应的路由和权限，还需要两个部分，一个是 ui 组件，另一个就是 model 部分。在组件内部调用 dispatch 方法，根据传的 type 来执行 model 里面的对应的命名空间的 effects，进而可以修改 state 值。在 UI 组件内部使用高阶组件 connect 包裹组件，可以在组件内部使用 model 里面的 state。1. 组件内部调用 dispatch 一个 action，需要指定命名空间的 model 里面的 action： 2. model 部分 3. services 里面进行 请求的定义 一个 model 里面会有这些属性: state：model 的状态数据，一般是不可变的，只有 action 才能修改 state 值 action：改变 state 的唯一途径，需要 dispatch 来触发 action，需要传一个 type 值，来指定 state 的修改。 dispatch 一般在组件 connect 以后从 props 里面可以获取到 dispatch：触发 action 的函数，在组件 connect 以后从 props 里面可以获取到 dispatch reducers：是一个纯函数，接收 state 和 action，返回新的 state , 同步修改状态 effect：多用于异步修改状态，将异步操作转换成同步的写法，来实现纯函数 subscription：订阅一个数据源，根据条件来 dispacth 一个 action，一般用来监听路由变化 此外每个 model 还需要定义一个 namespace 命名空间，也是全局 state 里面的属性， 例如 connect 指定的 state 时会用到，dispatch 指定的命名空间的 effects 也会用到 model 里面的 effect 的使用: call 一般用来调用 api 接口，并可以获取到返回值 put 大致与 dispatch 相同，可让 effects 里的方法调用修改 state 的方法 select 用于获取 state 变量此外 antd-pro 引入了 typescript，对 js 代码进行的类型检测，配合 tslint，能够严格约束代码的编写，虽然有些时候遇到的一些类型警报，可以用 any 类型解决，但是非常不建议这样做。","tags":[{"name":"antdPro","slug":"antdPro","permalink":"https://shleyz.github.io/tags/antdPro/"}]},{"title":"js单线程和事件循环","date":"2020-04-02T06:06:14.000Z","path":"2020/04/02/interview-js单线程相关/","text":"js单线程javascript 作为一个浏览器端语言，最主要任务是处理用户的交互，而用户的交互主要就是对 dom 的增删改查。如果设计成多线程，一个线程在某个DOM节点上面新增内容，另一个线程删除了这个节点。那浏览器要怎么显示，以哪个为准。 单线程意味着，所有的任务都要排队，在一个队列里面。前一个任务结束，后一个任务才能开始。如果前一个任务耗时很长，后面的任务就得一直等待，例如一个接口请求等待读取数据时。 事件循环后面的任务完全可以在前一个任务没有完成前执行，也就是把等待中的任务暂时挂起，先运行排在后面的任务，等挂起的任务完成或有了返回，再继续执行挂起的任务。 因此有了两种任务： 同步任务： 立即执行的任务，同步任务一般会直接进入到主线程中执行。 异步任务： 例如 Ajax回调函数、DOM 事件回调函数、setTimeout/setInterval回调函数等, 通过任务队列来进行协调。 同步任务和异步任务分别进入不同的执行环境: 同步任务进入主线程，也就是主执行栈。 异步任务进入 Event Quene。 主执行栈内的任务执行完毕，会去 Event Quene 读取对应的任务，推入主程执行。上面的过程重复执行就是 Event Loop 事件循环。 在事件循环中，每进行一次循环成为一次 tick。每一次 tick 的任务处理模型都是很复杂的： 在此次 tick 中选择最先进入队列的任务（oldest）。如果有则执行。 检查是否存在 microtasks（微任务），如果存在则不停的执行，直至清空 microtasks 队列。 更新 Render 主线程重复执行上述步骤 宏任务：setTimeout、setInterval, Ajax，DOM事件微任务：Promise async/await 例子1 简单：12345678910111213console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);Promise.resolve().then(function() &#123; console.log('promise1');&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end'); 分析上面代码： 整体 script 作为第一个宏任务进入主线程，遇到 console.log(‘script start’), 输出 script start； 遇到 setTimeout， 其回调函数被分发到宏任务的 Event Quene中； 遇到 Promise, 其 then 函数被分到微任务 Event Quene 中，记为 then1, 之后又遇到了 then 函数，将其分到微任务 Event Quene 中，记为 then2； 遇到 console.log(‘script end’), 输出 script end； 现在 Event Quene 中存在三个任务： 宏任务 微任务 setTimeout then1 — then2 然后： 执行微任务， 首先执行 then1, 输出 promise1， 然后执行 then2, 输出 promise2；此时清空了所有的微任务； 执行 setTimeout，输出 setTimeout。 所以执行完输出顺序： 12345// script start// script end// promise1// promise2// setTimeout 例子2 复杂：123456789101112131415console.log('script start');setTimeout(function() &#123; console.log('timeout1');&#125;, 10);new Promise(resolve =&gt; &#123; console.log('promise1'); resolve(); setTimeout(() =&gt; console.log('timeout2'), 10);&#125;).then(function() &#123; console.log('then1')&#125;)console.log('script end'); 分析： 整体 script 作为第一个宏任务进入主线程，遇到 console.log(‘script start’), 输出 script start； 遇到 setTimeout， 其回调函数被分发到宏任务的 Event Quene中， 记为 setTimeout1； 遇到 Promise，new Promise 中代码立即执行， 输出 promise1 将 Promise 的 then 放到微任务中去，记为 then1 遇到 console.log(‘script end’)， 输出 script end 现在 Event Quene 中存在三个任务： 宏任务 微任务 setTimeout1 then1 setTimeout2 —– 依次执行微任务，直至清空微任务，输出： then1 依次执行宏任务，输出： timeout1， timeout2 所以执行完输出顺序： 123456// script start// promise1// script end// then1// timeout1// timeout2 总结：微任务优先于宏任务，所以有需要优先执行的逻辑，放入微任务队列会更早的执行。 最后：JS是单线程语言，所有的任务都放在事件循环队列里面，等待主执行栈来执行，并没有专门的异步线程。","tags":[{"name":"js基础","slug":"js基础","permalink":"https://shleyz.github.io/tags/js基础/"}]},{"title":"js实现图片懒加载","date":"2020-04-02T05:17:48.000Z","path":"2020/04/02/interview-js实现图片懒加载/","text":"主要原理是判断图片是否在可视区域内部，图片移动到可视区域内部，进行加载。 有三种判断方法： offsetTop &lt; clientHeight + scrollTop element.getBoundingClientRect().top &lt; clientHeight. 缺点是，由于 scroll 事件密集发生，计算量很大，容易造成性能问题。 IntersectionObserver, 使用方法： 1var io = new IntersectionObserver(callback, option); IntersectionObserver 是浏览器原生提供的构造函数，接受两个参数：callback 是可见性变化时的回调函数，option 是配置对象（该参数可选）。 使用方法三实现懒加载的例子： 12345678910111213141516const query = (selector) =&gt; &#123; return Array.from(document.querySelectorAll(selector));&#125;const observer = new IntersectionObserver((changes) =&gt; &#123; changes.forEach((change) =&gt; &#123; const container = change.target; const content = container.querySelector('template').content; container.appendChild(content); observer.unobserve(container) &#125;)&#125;)query('.lazy-load').forEach((item) =&gt; &#123; observer.observer(item)&#125;) 上面代码中，只有目标区域可见时，才会将模板内容插入真实 DOM，从而引发静态资源的加载。 注：clientHeight 表示页面可见区域的高度, 只包括 padding, 不包括 borderoffsetHeight 表示页面可见区域的高度，包括 borderscrollTop 表示网页被卷去的高，就是滚动条上滚的页面高度element.getBoundingClientRect() 表示获取某个元素 element 相对于视窗的位置集合。element.getBoundingClientRect().top 表示获取某个元素 element 相对于视窗的顶部的距离。window.screen.height 表示屏幕分辨率高","tags":[{"name":"js基础","slug":"js基础","permalink":"https://shleyz.github.io/tags/js基础/"}]},{"title":"dart学习","date":"2020-02-13T09:36:57.000Z","path":"2020/02/13/dart学习/","text":"Dart 要求以 main 函数作为执行的入口 变量的声明可以用 var 或者 具体的类型，当使用 var 定义变量时，编译器会推断决定变量的类型。 默认未初始化的变量都是 null Dart 是类型安全的语言，所有的类型都是对象，继承自 Object。一切类型的值都是对象的实例，包括数字，布尔，函数和 null Dart 内置数据类型: num num 只有两种子类： 64 位 int 和 64 位 double（符合 IEEE 754 标准的） 64 位 int 代表整数类型， 64 位 double 代表浮点数 继承自num的运算符有 +,-,*,/,%,abs()绝对值,round()取整,还有&lt;,&gt;等比较运算符 dart:math 库提供了诸如三角函数、指数、对数、平方根等高级函数 Dart 内置数据类型: bool 因为 Dart 类型是安全的，所以不能在 if 判断或者 assert 中使用非布尔类型。 Dart 内置数据类型: String 使用 ‘ 或者 “ 来表示字符串字面量 ${express} 可以在字符串中嵌入变量 ‘+’ 可以实现字符串的拼接 ‘’’jksdhk jashdkjas dgkhjas’’’可以实现多行字符输出 Dart 内置数据类型: List 声明方法一： var arr1 = [“Tom”, “Andy”, “Jack”]; 声明方法二： var arr2 = new List.of([1,2,3]); 数组添加元素： arr2.add(499); // 添加的元素类型必须与数组里面元素类型一致。 数组遍历： arr2.forEach((v) =&gt; print(‘${v}’)); Dart 内置数据类型: Map 声明方法一： var map1 = {‘name’: ‘Tom’,’sex’: ‘male’,};; 声明方法二： var map2 = new Map(); 数组添加元素： map2[‘name’] = ‘Tom’; // 添加的元素类型必须与Map里面元素类型一致。 数组遍历： map2.forEach((k,v) =&gt; print(‘${k}: ${v}’)); Dart 常量，使用 final 或者 const 声明 const，表示变量在编译期间即能确定的值； final 则不太一样，用它定义的变量可以在运行时确定值，而一旦确定后就不可再变。","tags":[{"name":"dart","slug":"dart","permalink":"https://shleyz.github.io/tags/dart/"}]},{"title":"前端安全问题-CSRF跨站请求伪造","date":"2020-02-04T09:10:19.000Z","path":"2020/02/04/interview-前端安全问题-CSRF跨站请求伪造/","text":"攻击者盗用了受害者的身份，以受害者的名义发送恶意请求。例如以受害者的名义发送邮件、发消息，盗取账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 CSRF 攻击必须具备两个流程： 用户访问了受信任网站A， 并在本地生成 cookie 在不登出 A 的情况下，访问危险网站 B, B 会在接收到请求后，返回一些攻击性代码，并发出请求访问网站 A 预防，一般由服务端来解决： 服务端同源策略，设置受信任网站白名单，禁止外域访问 只允许同源网站提交请求携带 cookie 尽量使用 POST 请求 请求携带 tooken 通过请求头中的 Referer，来识别请求来源是否合法","tags":[{"name":"js基础","slug":"js基础","permalink":"https://shleyz.github.io/tags/js基础/"}]},{"title":"前端安全问题-XSS跨站脚本攻击","date":"2020-02-04T06:37:33.000Z","path":"2020/02/04/interview-前端安全问题-XSS跨站脚本攻击/","text":"XSS（Cross Site Scripting）跨站脚本攻击攻击者在 WEB 页面插入恶意 script 代码，在用户浏览页面时，被执行，从而达到某些目的。 例如攻击者在输入框内输入 1&lt;script&gt;alert('hey, you are attacked!')&lt;/script&gt; 这样这段代码很可能会在浏览器解析的时候被执行，今天弹出信息框。 在实际情况中，攻击者不会简单的这样操作，恶意植入代码的作用有很多，例如： 窃取用户信息，cookie 或者本地 用户认证 劫持流量实现恶意跳转等 XSS种类分为： 反射型 XSS： 通过在访问的 url 中加入恶意脚本传递给服务器 存储型 XSS： 攻击者将恶意代码提交到服务器中，普通用户访问时服务器将恶意代码返回，浏览器默认执行。 REACT 本身对 XSS攻 击的处理： 在React中，React 虚拟 DOM 会在渲染所有输入内容之前，进行转义(‘’，””, &amp;, &lt;, &gt;)，所有内容在渲染之前都变成了字符串，因此恶意代码无法注入，从而有效防止了 XSS 攻击。 1234// 一段恶意代码&lt;img src=\"empty.png\" onerror =\"alert('xss')\"&gt; // 转义后输出到 html 中&amp;lt;img src=&amp;quot;empty.png&amp;quot; onerror =&amp;quot;alert(&amp;#x27;xss&amp;#x27;)&amp;quot;&amp;gt; React 的 JSX 语法， 在经过babel 编译后变成 React.createElement() 调用： 1234567891011121314151617181920212223// JSXconst element = ( &lt;h1 className=\"greeting\"&gt; Hello, world! &lt;/h1&gt;);// 通过 babel 编译后的代码const element = React.createElement( 'h1', &#123;className: 'greeting'&#125;, 'Hello, world!');// React.createElement() 方法返回的 ReactElementconst element = &#123; $$typeof: Symbol('react.element'), type: 'h1', key: null, props: &#123; children: 'Hello, world!', className: 'greeting' &#125; ...&#125; REACT 中可能引起漏洞的写法： 使用 dangerouslySetInnerHTML dangerouslySetInnerHTML 是 React 为浏览器 DOM 提供的直接修改 innerHTML 的替换方案。 使用代码直接设置 HTML 会有风险，如果一定要使用，需要手动设置过滤、转义等。 通过用户设置图片的 src 值，或者链接的 href。 12const site = \"javascript:alert('xss');\";&lt;a href=&#123;site&#125;&gt;&lt;/a&gt; 如果没有对 URL 进行 javascript: 和 data: 过滤， 就可能会造成 XSS 攻击。 服务器需要做的对 XSS攻 击的处理： 接收浏览器端数据进行过滤处理，移除特殊的 HTML 标签，和 JS 关键字。 返回数据时针对类型，进行转义","tags":[{"name":"js基础","slug":"js基础","permalink":"https://shleyz.github.io/tags/js基础/"}]},{"title":"https的对称加密和非对称加密","date":"2020-02-04T06:02:49.000Z","path":"2020/02/04/interview-https的对称加密和非对称加密/","text":"加密类型： 对称加密， 加密解密用的是同样的钥匙 非对称加密， 加密解密用的是不同的钥匙 对称加密A 把一个箱子锁上， 用钥匙AY.然后把箱子寄给BB 用同样的钥匙 AY, 可以打开箱子，同样可以锁上箱子，寄给 A. 对称加密分为两种，一种是一个一个加密，一种是分块加密。 非对称加密B 有钥匙（私钥），B 把开着的箱子（和公钥）寄给 A;A 把信息放在箱子里， 然后锁上（用公钥加密），寄给 B;B 拿自己的钥匙（私钥）把箱子打开。 这种方式的好处是，不需要你不需要别人的钥匙。也就避免了出现在钥匙发送过程中复制钥匙，窃取信息。信息接受者有两把钥匙：一把“公匙”，一把“私匙”。公匙是给信息发送者用来加密的，私匙是自己用来解密的。这样最大的好处是：不必通过不安全的渠道发送私密的东西。公匙本来就是给别人用的，不用藏好。你的私匙在你产生私匙的电脑里保存着 https 的 SSL 加密(运用了对称加密和非对称加密)SSL (Secure Sockets Layer) 是用来保障浏览器和网站服务器之间安全通信，免受网络“中间人”窃取信息。 SSL原理： 当你的浏览器向服务器请求一个安全的网页(通常是 https://)； 服务器返回证书和公钥 浏览器检测证书是否有效，是否属于访问的域名 浏览器确认证书有效后，使用公钥加密 URL 和 一个随机对称密钥， 发送到服务器。URL + 随机生成的对称密钥A ==》 公钥加密 ==》 发送到服务器 服务器用私钥解密了收到的信息服务器私钥解密 ==》 得到 URL + 随机生成的对称密钥 ==》 对称密钥A解密 URL ==&gt; 得到解密后的 URL 服务器把整合的需要的资源 用对称密钥加密，发送给浏览器。需要返回的资源 ==》 对称密钥A加密 ==》 浏览器接收 浏览器使用对称密钥解密资源接收的加密资源 ==》 对称密钥A解密 ==》 得到解密后的信息","tags":[{"name":"js基础","slug":"js基础","permalink":"https://shleyz.github.io/tags/js基础/"}]},{"title":"js性能优化相关","date":"2020-02-03T10:05:05.000Z","path":"2020/02/03/interview-js性能优化相关/","text":"性能优化有：nginx 开启 gzip 压缩。非核心代码异步加载:123&lt;script src=\"script.js\"&gt;&lt;/script&gt; // 正常加载脚本&lt;script async src=\"script.js\"&gt;&lt;/script&gt; // 使用 async 异步加载&lt;script defer src=\"myscript.js\"&gt;&lt;/script&gt; // 使用 defer 异步加载 async 和 defer 的区别： 两者的读取都是在加载其他后续文档和渲染时一起加载，都是异步加载。但是执行的时间不同： async 是异步加载完成后立即异步执行 defer 要等其他元素解析完成之后才能执行 按需加载webpack 3/4 自带按需加载 对于 import 的内容进行处理，新建一个chunk。 当代码执行到 import 才会加载对应的 chunk 内容。 import 返回的是一个 Promise， 只有加载成功才能获取到加载的内容。 提取公共 chunk对于 webpack 的chunks, 可能出现公用的组件，如果不进行处理，会出现： 相同的资源被重复的加载，浪费用户的流量和服务器的成本； 每个页面需要加载的资源太大，导致首次加载缓慢，影响用户体验； 这里就需要用到 提取公共 chunks。 （要知道这样并不会降低页面首次加载的资源大小，反而有可能加大资源的大小。但是对于后面子页面资源的加载性能会有显著性提升。） 公共组件提取的实现： 使用 webpack3 内置的 CommonsChunkPlugin， 需要说明哪些chunk需要单独提取出来，以及拆分出来 chunks 的命名； 使用 webpack4 的 optimization.splitChunks: 需要在 缓存组 cacheGroups 里面定义拆分规则： 1234567891011121314151617// webpack.config.jsoptimization: &#123; minimize: true, splitChunks: &#123; chunks: 'all', minSize: 30000, // 提取出的 chunk 的最小大小 minChunks: 3, // 模块被引用 3 次以上的才抽离 automaticNameDelimiter: '.', cacheGroups: &#123; vendor: &#123; name: `vendors`, // chunk 名 test: /[\\\\/]node_modules[\\\\/]/, // 提取所有 node_modules 里面的引用 priority: 10, &#125;, &#125;, &#125;,&#125;, 使用 CDN 加载浏览器第一次打开页面时，缓存是起不了作用的。这个时候，CDN就上场了。 DNS预解析： http-equiv12&lt;meta http-equiv=\"x-dns-prefetch-control\" content=\"on\"&gt; &lt;!-- 强制打开 DNS 预解析 --&gt;&lt;link rel=\"dns-prefetch\" href=\"http://www.smyhvae.com/\"&gt; &lt;!-- 对指定的域名（第三方资源）进行DNS预解析 --&gt; 需要说明的是在一些高级浏览器里面对于超链接标签， 默认开启了DNS预解析， 但是如果是 https 协议，很多浏览器是关闭了DNS预解析， 如果加上 meta 会强制打开 DNS 预解析。","tags":[{"name":"js基础","slug":"js基础","permalink":"https://shleyz.github.io/tags/js基础/"}]},{"title":"js/css实现持续动画,以及对比","date":"2020-02-03T06:06:23.000Z","path":"2020/02/03/interview-js实现持续动画/","text":"使用 window.requestAnimationFrame()告诉浏览器你希望执行一个动画， 并且要求浏览器在下次重绘之前调用指定的回调函数执行动画。 123456789101112131415161718192021222324252627282930313233343536373839404142import &#123; Button &#125; from 'antd';import React, &#123; useState &#125; from 'react';const Animate: React.FC&lt;&#123;&#125;&gt; = () =&gt; &#123; // const ele = document.getElementById('animal'); const [translateX, settranslateX] = useState(0); var start = undefined as any; const step = (timestamp: number) =&gt; &#123; if(start === undefined) &#123; start = timestamp; &#125; const elapsed = timestamp - start; settranslateX(Math.min(0.1*elapsed, 200)) if(elapsed &lt; 2000) &#123; window.requestAnimationFrame(step) &#125; &#125; const onBegin = () =&gt; &#123; window.requestAnimationFrame(step) &#125; return ( &lt;div style=&#123;&#123;width: '100%', textAlign: 'center'&#125;&#125;&gt; &lt;div id=\"animal\" style=&#123;&#123; width: 100, height: 100, borderRadius: '50%', backgroundColor: '#000', transform: `translateX($&#123;translateX&#125;px)` &#125;&#125; /&gt; &lt;Button onClick=&#123;onBegin&#125;&gt; 开始 &lt;/Button&gt; &lt;/div&gt; )&#125;;export default Animate; 使用css3来实现动画:123456789101112131415161718192021.animal&#123; width: 100px; height: 100px; border-radius: 50%; background-color: black; margin-top: 300px; /* position: absolute; */ animation: horizonMove 5s linear infinite; -moz-animation: horizonMove 5s linear infinite; /* Firefox */ -webkit-animation: horizonMove 5s linear infinite; /* Safari 和 Chrome */ -o-animation: horizonMove 5s linear infinite;&#125;@keyframes horizonMove &#123; form &#123; transform: translateX(0px); &#125; to &#123; transform: translateX(500px); &#125;&#125; 1&lt;div id=\"animal\" className=&#123;style.animal&#125; /&gt; 对比使用 js 动画：会频繁操作 js，进而频繁对 dom/css 进行操作，浏览器会频繁重绘和重排，这是一个很大的开销，使得 js 的执行效率很低。使用 css3 进行动画： 不占用主线程， 可以利用硬件加速， 浏览器本身对动画的优化（不可见时不进行动画，减少每秒传输帧数fps） css3 比较适用于 2D 动画，3D以上的动画的执行效率会比js要低。","tags":[{"name":"js基础","slug":"js基础","permalink":"https://shleyz.github.io/tags/js基础/"}]},{"title":"js类型检测","date":"2020-02-02T09:23:20.000Z","path":"2020/02/02/interview-js类型检测/","text":"typeof 用来判断大部分基础数据类型和Function： Number String Boolean Null // 使用 typeof 返回的是 “object”, 并不能准确分辨 Undefined Symbol (本质上是一种唯一标识符) 但是对于下面的部分引用类型： Array Object Function // 使用 typeof 返回的是 “function”， 可以分辨 Date RegExp typeof 返回都是 “object”, 无法直接得到类型。。 1234567891011typeof 123 // \"number\"typeof '123' // \"string\"typeof false // \"boolean\"typeof undefined // \"undefined\"typeof Symbol() // \"symbol\"typeof () =&gt; &#123;&#125; // \"function\"typeof null // \"object\"typeof [] // \"object\"typeof &#123;&#125; // \"object\"typeof /w/g // \"object\"typeof new Date() // \"object\" 因此对于引用类型的数据判断类型的话，可以用 instanceof instanceof 可以来检测主要的引用类型,即判断一个对象是否在另一个对象的原型链上。12345678910let obj = &#123;&#125;obj instanceof Object // trueobj = []obj instanceof Array // trueobj = new Date()obj instanceof Date // trueobj = /w/gobj instanceof RegExp // trueobj = function() &#123;&#125;obj instanceof Function // true 但是下面这种也都成立：12345678910let obj = &#123;&#125;obj instanceof Object // trueobj = []obj instanceof Object // trueobj = new Date()obj instanceof Object // trueobj = /w/gobj instanceof Object // trueobj = function() &#123;&#125;obj instanceof Object // true 因为所有引用类型其实都是继承自 Object 对象的 下面这个例子：12345let str = new String('123')typeof str // \"object\"obj = []obj instanceof Object // trueobj instanceof String // true 这就尴尬了，这到底是什么类型？ Object.prototype.toString.call()直接看例子： 12345678910111213141516171819202122let obj = &#123;&#125;Object.prototype.toString.call(obj) // \"[object Object]\"obj = []Object.prototype.toString.call(obj) // \"[object Array]\"obj = new Date()Object.prototype.toString.call(obj) // \"[object Date]\"obj = /w/gObject.prototype.toString.call(obj) // \"[object RegExp]\"obj = () =&gt; &#123;&#125;Object.prototype.toString.call(obj) //\"[object Function]\"obj = nullObject.prototype.toString.call(obj) //\"[object Null]\"obj = undefinedObject.prototype.toString.call(obj) //\"[object Undefined]\"obj = 123Object.prototype.toString.call(obj) // \"[object Number]\"obj = 'abc'Object.prototype.toString.call(obj) // \"[object String]\"obj = falseObject.prototype.toString.call(obj) // \"[object Boolean]\"obj = Symbol()Object.prototype.toString.call(obj) // \"[object Symbol]\"","tags":[{"name":"js基础","slug":"js基础","permalink":"https://shleyz.github.io/tags/js基础/"}]},{"title":"@bigtest/react","date":"2020-01-08T05:14:24.000Z","path":"2020/01/08/bigtest-react/","text":"进行大型测试的 React DOM 助手：@bigtest/react github 地址： https://github.com/bigtestjs/react 这个软件包的目的是提供一套帮助程序，使得能够更加容易的测试 React 程序 mount 方法在一个新的 DOM 节点异步加载一个组件，返回 promise， 一连串的使用将清除所有先前安装的组件。 1234567891011import &#123; mount &#125; from '@bigtest/react';import Button from '../src/components/button';describe('My button', () =&gt; &#123; // `mount` 返回Promise: 渲染后resolves beforeEach(() =&gt; mount(() =&gt; &lt;Button /&gt;)); it('renders', () =&gt; &#123; expect(document.querySelector('.button')).to.exist; &#125;);&#125;); setupAppForTestingsetupAppForTesting 不仅会 mount 应用程序组件，还将使用该组件的实例进行解析，并提供一个内存重的 history 对象，供 React Router 在测试期间使用。 123456789101112131415161718import &#123; setupAppForTesting &#125; from '@bigtest/react';import App from '../src/app';describe('My Application', () =&gt; &#123; let app; beforeEach(async () =&gt; &#123; app = await setupAppForTesting(App); &#125;); it('renders', () =&gt; &#123; expect(document.querySelector('#app')).to.exist; &#125;); if('has a history prop', () =&gt; &#123; // this prop is only provided if defined in `propTypes` expect(app.props).to.have.property('history'); &#125;)&#125;) visit只有在使用 setupAppForTesting，并与应用程序的 history 属性进行交互以在路由之间导航后，才会起作用。（visit, goBack, goForward, and location 都是这样） 1234567891011121314151617import &#123; setupAppForTesting, visit, location &#125; from '@bigtest/react';import App from '../src/app';describe('My Application', () =&gt; &#123; let app; beforeEach(async () =&gt; &#123; app = await setupAppForTesting(App); &#125;); describe('navigating', () =&gt; &#123; beforeEach(() =&gt; visit('/some-route')); it('is at the new route', () =&gt; &#123; expect(location()).to.have.property('pathname', '/some-route'); &#125;); &#125;);&#125;); cleanup在每次 mount 和 setupAppForTesting 调用开始时都会调用 cleanup，以清除以前安装的任何组件或应用程序。 如果您需要自己清理以前安装的组件，也可以单独使用它。 123456789import &#123; mount, cleanup &#125; from '@bigtest/react';import Button from '../src/components/button';describe('My Button', () =&gt; &#123; beforeEach(() =&gt; mount(&lt;Button /&gt;)); // 为了可以在测试运行后调查并使用组件进行调试，最好不要这样做 afterEach(() =&gt; cleanup());&#125;); 注意mount 和 setupAppForTesting 都有第二个参数： 一个对象包含一系列的参数。 1234567mount(&lt;Button /&gt;, &#123; mountId: 'testing-root', // 作为加载的DOM节点的id rootElement: document.body, // 加载的DOM节点的位置 setup: () =&gt; &#123;&#125;, // 在组件加载好之前调用， 如果返回的是promise，则组件会在resolve之后加载 teardown: () =&gt; &#123;&#125; // 在下一个 cleanup 调用时调用，或者在下一个mount或setupAppForTesting开始时调用，或者在直接调用 cleanup 时调用。 和“ setup”一样，如果返回的是promise，则组件会在resolve之后加载&#125;)&#125;); 此外， setupAppForTesting 接受一个 props 选项， 该选项将与所有用户定义的 props 一起传递给应用程序组件。 1234567setupAppForTesting(App, &#123; props: &#123; store: createStore(), // you can provide your own history object as well history: createHistory(historyOptions) &#125;&#125;); 可重用性为了在测试应用程序时获得最佳体验，任何不属于组件生命周期中的必需的逻辑，都应该是可重用的。通过提供必要的 setup 和 teardown 选项，或者将逻辑移入组件生命周期挂钩中。 除此之外，在您自己的 test helper 中使用 setupAppForTesting 可能很有意义，因为它可以处理任何其他必要的设置。 这也使我们不必导入应用程序并在每个测试文件中重复设置逻辑。 123456789101112131415// test/helper.jsimport &#123; setupAppForTesting &#125; from '@bigtest/react';export &#123; visit, goBack, goForward, location &#125; from '@bigtest/react';import App from '../src/app';import createServer from './mocks/server';export function setupApplicationForTesting() &#123; beforeEach(async function () =&gt; &#123; this.app = await setupAppForTesting(App, () =&gt; &#123; setup: () =&gt; this.server = createServer(), teardown: () =&gt; this.server.shutdown() &#125;); &#125;);&#125; 更好的测试这些 helpers 使您可以反复安装应用程序进行测试，而与应用程序进行交互也可能会很麻烦。 @bigtest/interactor 提供了一个更简单的方法，通过任何浏览器与应用的各个部分进行交互。就好像是用户在和你的 app 进行交互。实际上，可组合的 interactors 是测试使用可组合 components 制作的 app 的完美伴侣。 1234567891011121314import &#123; setupAppForTesting &#125; from '@bigtest/react';import App from '../src/app';import HomePageInteractor from './interactors/home';describe('My Applicaion', () =&gt; &#123; const home = new HomePageInteractor(); beforeEach(() =&gt; setupAppForTesting(App)); it('has a fancy button', () =&gt; &#123; except(home.button.isPresent).to.be.true; except(home.button.isFancy).to.be.true; &#125;);&#125;);","tags":[{"name":"bigtest","slug":"bigtest","permalink":"https://shleyz.github.io/tags/bigtest/"}]},{"title":"@bigtest/convergence","date":"2020-01-08T03:21:48.000Z","path":"2020/01/08/bigtest-convergence/","text":"Convergence 是强大,不可变，可重用和可组合的断言，使您可以立即知道何时达到期望的状态。简而言之：它每 10 毫秒检查一次 DOM（默认情况下为 2 秒），以查看您要检查的状态是否存在。 Convergence 是 BigTest 中所有事物的基础。这就是使 interactors 可靠的原因。CLI 中甚至将 Convergence 用于等待浏览器连接状态。 12345import Convergence from '@bigtest/convergence';setTimeout(() =&gt; (foo = 'bar'), 100);await new Convergence().when(() =&gt; foo === 'bar');console.log(foo); // =&gt; \"bar\" 默认情况下，Convergence 将在 2000ms 之前或之后 converge，具体取决于定义的断言类型。这可以通过在初始化 convergence 时提供超时或使用 #timeout() 方法来配置。 12new Convergence(100);new Convergence().timeout(5000); 使用 #when()，断言将运行多次直到通过。同样，#always() 确保断言在一段时间内保持通过状态。 1234// converges when `foo` is equal to `'bar'` within 100msnew Convergence(100).when(() =&gt; foo === 'bar');// converges after `foo` is equal to `'bar'` for at least 100msnew Convergence(100).always(() =&gt; foo === 'bar'); convergence 是不可变的，因此，它的方法将返回新实例。 这使您可以组合多个 convergence，并使用各自的 #run() 方法分别启动每个 convergence。 123456789101112131415let converge = new Convergence(300);let convergeFoo = converge.when(() =&gt; foo === 'foo');let convergeFooBar = convergeFoo.when(() =&gt; foo === 'bar');let convergeFooBarBaz = convergeFooBar.when(() =&gt; foo === 'baz');setTimeout(() =&gt; (foo = 'foo'), 100);setTimeout(() =&gt; (foo = 'bar'), 200);setTimeout(() =&gt; (foo = 'baz'), 150);// resolves after 100msconvergeFoo.run();// resolves after 200msconvergeFooBar.run();// rejects after 300ms since it wasn't `baz` _after_ `bar`convergeFooBarBaz.run(); Convergences 会立即调用#run（）。这使它们能够在大多数情况下可以使用的地方使用。 12345async function onceBarAlwaysBar() &#123; await new Convergence().when(() =&gt; foo === 'bar').always(() =&gt; foo === 'bar');&#125;Promise.race([onceBarAlwaysBar(), new Convergence().when(() =&gt; foo === 'baz')]); MethodsisConvergence(obj) 返回布尔值如果对象具有正确类型的 convergence 属性，则返回 true。 1234567let result = maybeConvergence();if (isConvergence(result)) &#123; await result.do(something).timeout(100);&#125; else &#123; something(result);&#125; always(assertion, timeout)传入的参数： assertion： Function 需要 converge 的断言 timeout：Number 使用的超时时间，以剩余的超时时间为上限。 返回一个新的 convergence 返回带有附加断言的新 convergence 实例。重复运行此断言以确保它在整个超时时间内通过。如果在超时期间的任何时候断言失败，那么 convergence 将失败。 12// would converge after `foo` remains `'foo'` for at least 100msnew Convergence(100).always(() =&gt; foo === 'foo'); 当 convergence 结束时遇到 always 断言时，超时默认为当前正在运行的实例的剩余时间。最少 20ms。如果不在 convergence 范围内，则默认为总超时时间的十分之一。 123let convergeFooThenBar = new Convergence(1000) .always(() =&gt; foo === 'foo') // would continue after `foo` remains `'foo'` for at least 100ms .when(() =&gt; foo === 'bar'); // then have any time remaining to converge on `foo` being `'bar'` 给定一个超时时间，则将其限制为当前运行实例的剩余超时时间。 1234let convergeFooThenBar = new Convergence(100) .always(() =&gt; foo === 'foo', 50) // 当在50ms内foo持续等于'foo'，则继续 .when(() =&gt; foo === 'bar') // 然后还剩下50ms .always(() =&gt; foo === 'bar', 100);","tags":[{"name":"bigtest","slug":"bigtest","permalink":"https://shleyz.github.io/tags/bigtest/"}]},{"title":"@bigtest/interactor开箱即用的方法和属性","date":"2020-01-07T09:36:46.000Z","path":"2020/01/07/bigtest-interactor开箱即用的方法和属性/","text":"以下是 interactor 开箱即用可用的各种交互的简要说明。 Default Interactions这些默认的交互属性和方法在所有 interactor 上都可用，但是在定义自己的自定义 interactor 时可以安全地覆盖它们。 Properties如果元素不能位于 Interactions 的根元素中，则所有属性（isPresent 除外）都将引发错误。 #text： 返回元素 trimmed 后的 textContent 属性 1new Interactor('p').text; #value: 返回元素的 value 属性 1new Interactor('input').value; #isVisible: 如果元素在文档中可见，则返回 true 否则 false 12new Interactor('#foo').isVisible; //=&gt; truenew Interactor('#bar').isVisible; //=&gt; false #isHidden： 如果元素存在于文档中但在视觉上被隐藏，则返回 true 否则 false 12new Interactor('#foo').isHidden; //=&gt; falsenew Interactor('#bar').isHidden; //=&gt; true #isPresent： 如果可以在文档中找到一个元素，则返回 true 否则 false。 12new Interactor('#foo').isPresent; //=&gt; truenew Interactor('#bar').isPresent; //=&gt; false Methods所有默认的交互方法都接受一个可选的选择器作为第一个参数。给定一个选择器，将在父交互器的根元素内的匹配元素上进行交互。 注意：交互方法将返回交互器的新实例，并且在新实例上调用#run（）方法之前不会进行任何交互。 #click([selector]) 触发元素上的点击事件。 12await new Interactor('button').click();await new Interactor('form').click('[type=\"submit\"]'); #fill([selector], value) 更改元素的值并触发输入和更改事件。 12await new Interactor('input').fill('value');await new Interactor('form').fill('input#name', 'value'); #select([selector], option) 通过文本值选择一个选项并触发输入和更改事件。 12await new Interactor('select').select('February');await new Interactor('form').fill('select#month', 'March'); #focus([selector]) 在元素上触发焦点事件。 12await new Interactor('input').focus();await new Interactor('form').focus('input[type=\"email\"]'); #blur([selector]) 在元素上触发失去焦点事件 12await new Interactor('input').blur();await new Interactor('form').blur('input[type=\"email\"]'); #scroll([selector], { top, left }) 设置元素的 scrollTop 和 scrollLeft 属性并触发滚动事件。顶部和左侧的值指定在该方向上滚动到多少像素；必须至少指定一个方向。 12await new Interactor('#page').scroll(&#123; top: 100 &#125;);await new Interactor('#page').scroll('.nested-view', &#123; left: 100 &#125;); #trigger([selector], name[, options]) 使用任何指定的事件选项在元素上触发任意事件，名称。默认情况下，气泡和可取消选项设置为 true。 1234await new Interactor('#foo').trigger('customEvent');await new Interactor('#foo').trigger('customEvent', &#123; ... &#125;);await new Interactor('#foo').trigger('#bar', 'customEvent');await new Interactor('#foo').trigger('#bar', 'customEvent', &#123; ... &#125;); Property Creators使用 @interactor 类装饰器创建自己的自定义 interactors 时，可以利用 Property creators。就像默认方法一样，creator 函数接受一个可选的选择器。但是，生成的实例方法没有可选的 selector 参数。 Propertiesinteractor Property creators 返回一个 getter。就像默认属性一样，除了 isPresent 之外，如果元素不能位于 interactor 的根元素中，则所有属性都会引发错误。 text([selector]) 返回元素 trimmed 后的 textContent 属性 123456@interactorclass PageInteractor &#123; heading = text('h1');&#125;new PageInteractor().heading; //=&gt; \"Hello World!\" value([selector]) 返回元素的 value 属性。 123456@interactorclass FormInteractor &#123; name = value('input#name');&#125;new FormInteractor('form').name; //=&gt; \"Foo Bar\" isVisible([selector]) 如果元素在文档中可见，则返回 true 否则 false 12&lt;div id=\"foo\"&gt;...&lt;/div&gt;&lt;div id=\"bar\" style=\"display: none\"&gt;...&lt;/div&gt; 12345678@interactorclass PageInteractor &#123; isFooVisible = isVisible('#foo'); isBarVisible = isVisible('#bar');&#125;new PageInteractor().isFooVisible; // =&gt; truenew PageInteractor().isBarVisible; // =&gt; false isHidden([selector]) 如果元素存在于文档中但在视觉上被隐藏，则返回 true 否则 false。 12&lt;div id=\"foo\"&gt;...&lt;/div&gt;&lt;div id=\"bar\" style=\"display: none\"&gt;...&lt;/div&gt; 12345678@interactorclass PageInteractor &#123; isFooHidden = isHidden('#foo'); isBarHidden = isHidden('#bar');&#125;new PageInteractor().isFooHidden; // =&gt; falsenew PageInteractor().isBarHidden; // =&gt; true isPresent([selector]) 如果可以在文档中找到一个元素，则返回 true 否则 false。 1&lt;div id=\"foo\"&gt;...&lt;/div&gt; 12345678@interactorclass PageInteractor &#123; isFooPresent = isPresent('#foo'); isBarPresent = isPresent('#bar');&#125;new PageInteractor().isFooPresent; // =&gt; truenew PageInteractor().isBarPresent; // =&gt; false attribute([selector], attr) 通过 getAttribute 返回元素的指定属性。 1234&lt;div class=\"card\" id=\"foo\"&gt; ... &lt;a class=\"card-link\" href=\"https://example.com\"&gt;...&lt;/a&gt;&lt;/div&gt; 12345678@interactorclass CardInteractor &#123; id = attribute('id'); url = attribute('.card-link', 'href');&#125;new CardInteractor('.card').id; //=&gt; \"foo\"new CardInteractor('.card').url; //=&gt; \"https://example.com\" property([selector], prop) 返回元素的指定属性值。 1234&lt;div class=\"card\" style=\"height: 100px\"&gt; ... &lt;button class=\"card-cta\" disabled&gt;...&lt;/button&gt;&lt;/div&gt; 12345678@interactorclass CardInteractor &#123; height = property('offsetHeight'); isDisabled = property('button.card-cta', 'disabled');&#125;new CardInteractor('.card').height; //=&gt; 100new CardInteractor('.card').isDisabled; //=&gt; true hasClass([selector], className) 如果元素的 classList 包含指定的类名，则返回 true 否则 false。 1234&lt;form class=\"error\" ...&gt; &lt;input id=\"name\" class=\"error\" /&gt; &lt;input type=\"email\" id=\"email\" /&gt;&lt;/form&gt; 12345678910@interactorclass FormInteractor &#123; hasErrors = hasClass('error'); // applies to the root hasNameError = hasClass('input#name', 'error'); hasEmailError = hasClass('input#email', 'error');&#125;new FormInteractor('form').hasErrors; //=&gt; truenew FormInteractor('form').hasNameError; //=&gt; truenew FormInteractor('form').hasEmailError; //=&gt; false is([selector], match) 如果指定的匹配选择器可以通过 Element.matches（）选择一个元素，则返回 true 否则 false。 12345&lt;ul class=\"list\"&gt; &lt;li id=\"foo\"&gt;...&lt;/li&gt; &lt;li id=\"bar\"&gt;...&lt;/li&gt; &lt;li id=\"baz\"&gt;...&lt;/li&gt;&lt;/ul&gt; 12345678910@interactorclass ListInteractor &#123; isList = is('.list'); isFooFirst = is('#foo', ':first-child'); isBarLast = is('#bar', ':last-child');&#125;new FormInteractor('form').hasErrors; //=&gt; truenew FormInteractor('form').hasNameError; //=&gt; truenew FormInteractor('form').hasEmailError; //=&gt; false Methodsinteractor methods Creators 返回链式函数，这些函数随后返回具有添加到其队列中的特定交互的新实例。直到调用交互程序的 #run() 方法或使用 async/await 语法时，interactions 才会运行。 clickable([selector]) =&gt; click() 触发元素的 click 事件。 1234&lt;div class=\"card\"&gt; ... &lt;a class=\"card-link\" href=\"https://example.com\"&gt;...&lt;/a&gt;&lt;/div&gt; 123456@interactorclass CardInteractor &#123; clickThrough = clickable('.card-link');&#125;await new CardInteractor('.card').clickThrough(); fillable([selector]) =&gt; fill(value) 更改元素的 value 值并触发 input 和 change 事件 1234&lt;form ...&gt; &lt;input id=\"name\" /&gt; ...&lt;/form&gt; 123456@interactorclass FormInteractor &#123; fillName = fillable('input#name');&#125;new FormInteractor('form').fillName('value'); selectable([selector]) =&gt; select(option) 通过 text 值选择一个选项并触发 input 和 change 事件。 123456789&lt;form ...&gt; &lt;select id=\"month\"&gt; &lt;option value=\"1\"&gt;January&lt;/option&gt; &lt;option value=\"2\"&gt;February&lt;/option&gt; &lt;option value=\"3\"&gt;March&lt;/option&gt; ... &lt;/select&gt; ...&lt;/form&gt; 123456@interactorclass FormInteractor &#123; selectMonth = selectable('select#month');&#125;new FormInteractor('form').selectMonth('February'); focusable([selector]) =&gt; focus() 在元素上触发 focus 事件。 1234&lt;form ...&gt; &lt;input type=\"email\" /&gt; ...&lt;/form&gt; 123456@interactorclass FormInteractor &#123; focusEmail = focusable('input[type=\"email\"]');&#125;await new FormInteractor('form').focusEmail(); blurrable([selector]) =&gt; blur() 在元素上触发 blur 事件。 1234&lt;form ...&gt; &lt;input type=\"email\" /&gt; ...&lt;/form&gt; 123456@interactorclass FormInteractor &#123; blurEmail = blurrable('input[type=\"email\"]');&#125;await new FormInteractor('form').blurEmail(); scrollable([selector]) =&gt; scroll({ top, left }) 置元素的 scrollTop 和 scrollLeft 属性并触发 scroll 事件。top 和 left 的值指定在该方向上滚动到多少像素；必须至少指定一个方向 123&lt;div id=\"page\"&gt; &lt;div class=\"scrollview\"&gt;&lt;/div&gt;&lt;/div&gt; 123456@interactorclass PageInteractor &#123; scrollSection = scrollable('.scrollview');&#125;new PageInteractor('#page').scrollSection(&#123; top: 100 &#125;); triggerable([selector], name[, options]) =&gt; trigger([options]) 使用任何指定的事件 options 在元素上触发任意事件，名称。默认情况下，bubbles 和 cancelable 选项设置为 true。运行交互程序时，两个 options 参数将合并。 12345678910@interactorclass PageInteractor &#123; triggerEvent = triggerable('customEvent', &#123; ... &#125;); triggerFooEvent = triggerable('#foo', 'customEvent');&#125;await new PageInteractor().triggerEvent();await new PageInteractor().triggerEvent(&#123; ... &#125;);await new PageInteractor().triggerFooEvent();await new PageInteractor().triggerFooEvent(&#123; ... &#125;); Interactors嵌套的 interactor creators 返回范围为父 interactor 根元素的 interactor 实例。第二个参数是要添加到返回的 interactor 中的可选的参数。第二个参数也可能是一个 interactor class，在创建嵌套的，作用域的 interactor 时会使用它自己的方法和属性。 scoped(selector[, properties]) 单个嵌套 interactor 的 Interactor creator。 12345&lt;form class=\"login-form\"&gt; &lt;input type=\"text\" name=\"username\" /&gt; &lt;input type=\"email\" name=\"email\" /&gt; &lt;button type=\"submit\"&gt;Login&lt;/button&gt;&lt;/form&gt; 1234567891011121314151617@interactorclass LoginFormInteractor &#123; username = scope('input[name=\"username\"]'); email = scope('input[name=\"email\"]'); submit = clickable('button[type=\"submit\"]');&#125;await new LoginFormInteractor('form') .username.fill('darklord1926') .email.fill('tom.riddle@hogwarts.edu') .email.blur() .submit();await new LoginFormInteractor('form') .username.fill('h4x0r') .email.only().fill('not@an@email') .blur(); collection(selector[, properties]) =&gt; fn([index]) 一组嵌套 interactor 的 Interactor creator。集合 interactor 将索引作为参数，并返回作用域为该元素的 interactor。没有索引，将返回相应的 interactor 数组 12345&lt;ul class=\"checkboxes\"&gt; &lt;li&gt;&lt;input type=\"checkbox\" .../&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\" .../&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\" .../&gt;&lt;/li&gt;&lt;/ul&gt; 1234567891011121314@interactorclass CheckboxGroupInteractor &#123; items = collection('input[type=\"checkbox\"]');&#125;await checkboxGroup .items(0).click() .items(1).click();)await checkboxGroup .items(0).click() .items(1).only() .focus() .trigger('keydown', &#123; which: 32 &#125;) HelpersProperty creator 可用于定义您自己的自定义 interactions。支持直接在 interactor class上定义 methods 和 getters。但是，使用这些帮助程序可以让您创建可重复使用的Property creator ，例如上述交互。 computed(getter) 返回 Interactor Property 的 property descriptor。 12345678910function data(key, selector) &#123; return computed(function() &#123; return this.$(selector).dataset[key]; &#125;)&#125;@interactor class PageInteractor &#123; username = data('user', '#user-info');&#125; action(method) 返回一个交互方法的 property descriptor。 123456789101112function check(selector) &#123; return action(function(name) &#123; return this.click(`$&#123;selector&#125;[name=\"$&#123;name&#125;\"]`); &#125;)&#125;@interactor class CheckboxGroupInteractor &#123; check = check('input[type=\"checkbox\"]');&#125;new CheckboxGroupinteractor('.checkboxes').check('option-1');","tags":[{"name":"bigtest","slug":"bigtest","permalink":"https://shleyz.github.io/tags/bigtest/"}]},{"title":"@bigtest/interactor使用","date":"2020-01-07T08:42:05.000Z","path":"2020/01/07/bigtest-interactor使用/","text":"自定义 interactor虽然使用默认的 Interactor 对于简单和较小的组件可能很好，但是使用类装饰器和 interactor interaction creators 很容易创建自定义 interaction。 自定义 Interactor 使我们能够将所有选择器都放在一个位置，并具有与其他 Interactor 可组合以与更多复杂结构交互的好处。 12345678910111213141516171819202122import &#123; interactor, text, value, property, fillable, focusable, blurrable&#125; from '@bigtest/interactor';@interactorclass FiledInteractor &#123; // custom properties are lazy like the default properties label = text('[data-test-label]'); value = value('[data-test-input]'); type = property('[data-test-input]', 'type'); // `*able` property creators create chainable interactor methods focus = focusable('[data-test-input]'); fill = fillable('[data-test-input]'); blur = blurrable('[data-test-input]');&#125; 默认的属性和方法集具有相应的 interactor creators。还有其他几个可用的 interactor creators 可供选择。 自定义方法和属性也可以在修饰的类上直接定义其他方法和获取属性的方法。但是，请谨慎使用 property initializers 和 this，因为它会引用未修饰的类实例，而不是您可能期望的 interactor 实例。 12345678910111213141516@interactorclass FieldInteractor &#123; // methods that return new instances of itself will be chainable with other methods fillIn(value) &#123; return this.focus() .fill(value) .blur(); &#125; // using getters ensures that properties will not be invoked until necessary get isPassword() &#123; return this.type === 'password'; &#125; // the following will not work because `this` references the undecorated class // foo = () =&gt; this.doesntWork()&#125; 自定义 Interaction Creators对于常用的自定义属性和方法，存在两个 helpers，可用于定义自己的可重用 interaction creators： 针对属性的 computed 针对方法的 action 除了默认方法外，interaction 还具有一些自己的辅助方法。 this.\\$(selector) 使用 interaction 的根元素和 querySelector 查找嵌套元素。当找不到元素时，将引发错误。如果未定义选择器，则返回根元素。 this.\\$\\$(selector) 也使用 interaction 的根元素，但使用 querySelectorAll 并返回匹配元素的数组。仅当找不到根元素时才会引发错误。 123456789101112131415import &#123; computed &#125; from '@bigtest/interactor';// returns a specific data attribute of an elementexport function data(selector, key) &#123; // to align with other interaction creators, `selector` is optional if (!key) &#123; key = selector; selector = null; &#125; // the `computed` helper creates a getter return computed(function() &#123; return this.$(selector).dataset[key]; &#125;);&#125; Interactor methods: #find（selector）和#findAll（selector）的行为与上述方法相同，只是它们返回用于链式调用的新实例。找到的元素将传递到链中的下一个函数。 1234567891011121314151617181920212223import &#123; action &#125; from '@bigtest/interactor';// triggers a keypress event for each character in a given stringexport function typeable(selector) &#123; // the `action` helper returns an interactor method return action(function(string) &#123; return ( this.find(selector) // `#do` executes a callback within the queue .do($node =&gt; &#123; for (let char of string) &#123; $node.dispatchEvent( new Event('keypress', &#123; charChode: char.charCodeAt(), cancelable: true, bubbles: true &#125;) ); &#125; &#125;) ); &#125;);&#125; 使用自定义 interactor可以像使用普通 interactor 一样使用自定义 interactor。 123456789let username = new FieldInteractor('[data-test-username-field]');let password = new FieldInteractor('[data-test-password-field]');// focuses, fills, and blurs the field inputawait username.fillIn('bigtester');// property access could trigger \"element not found\" errors like default propertiesexpect(username.type).to.equal('text');expect(password.isPassword).to.be.true; 如果一个 interactor 通常只属于一个元素，则定义一个静态的 defaultScope 属性使我们不必每次都使用范围选择器初始化该 interactor。 12345678@interactorclass HomePageInteractor &#123; static defaultScope = '[data-test-home-page]'; // ...&#125;// defaults scope to \"[data-test-home-page]\"let homePage = new HomePageInteractor(); 自定义 interactor 也可以通过相互嵌套来构成其他 interactor。诸如 scoped 和 collection 之类的帮助程序还允许您将一个或一组 interactor 范围限定于父 interactor 中的特定元素。 Interactors 组合在定义自定义 Interactors 时，可以通过组合较小的 Interactors 来创建更复杂的 Interactors。默认情况下，嵌套 Interactors 的作用域不限于其父 Interactors。这是因为在某些情况下，例如模式或弹出窗口，元素已被附加到文档的不同部分。 123456789101112131415@interactorclass ModalInteractor &#123; // ...&#125;@interactorclass SignUpFormInteractor &#123; // the default scope is used when a new instance's selector is omitted static defaultScope = '[data-test-sign-up-form]'; // the modal element exists outside of the form confirmation = new ModalInteractor('[data-test-modal]'); // ...&#125; Scoped Interactors 范围交互器使用 scoped 属性创建器，您可以创建在父 Interactors 范围内的嵌套 Interactors。第二个参数允许我们完全指定其他嵌套属性或甚至另一个 Interactors 类。 123456789101112131415@interactorclass SignUpFormInteractor &#123; // ... // scoped interactors look for an element within the parent element submit = scoped('[data-test-submit]'); // a hash of other properties may be provided as the second argument email = scoped('[data-test-email-field] input', &#123; placeholder: property('placeholder') &#125;); // using a class is preferred for maximum composability password = scoped('[data-test-password-field]', FieldInteractor);&#125; collection 属性创建器返回一个函数，该函数接受一个索引，并将为该索引处的元素返回一个嵌套的 Interactors。就像普通的 Interactors 一样，此 Interactors 是惰性的，在交互运行或访问属性之前，它不会尝试在索引处查找元素。如果不提供任何参数，则 collection 函数将返回一个 Interactors 数组；调用时找到的每个匹配元素都会添加一个。 12345678910@interactorclass SignUpFormInteractor &#123; // ... // collections also accept additional properties or a class as the second argument interests = collection('[data-test-interests-item]\"]', &#123; toggle: click('input[type=\"checkbox\"]'), label: text('[data-test-label]') &#125;);&#125; 嵌套方法和属性嵌套的 Interactors 方法（无论是否作用域）都会返回根 Interactors 的实例以进行其他链接。嵌套属性在访问时仍会延迟计算。 1234567891011121314151617181920212223let signUp = new SignUpFormInteractor();// `await` will immediately invoke `#run()`, we could also save a reference// to this specific interaction to re-use elsewhereawait signUp.email .fill('foo@bar.baz') .password.fillIn('53cr3t') .interests(3) .toggle() .submit();// nested interactors may be broken from the parent chain using `#only()`await signUp.email .only() .focus() .fill('foo@bar') .blur();// nested properties may throw one of a few \"element not found\" errorssignUp.interests(10).label;// =&gt; Error: unable to find \"[data-test-label]\"// =&gt; Error: unable to find \"[data-test-interest-item]\" at index 10// =&gt; Error: unable to find \"[data-test-sign-up-form]\"","tags":[{"name":"bigtest","slug":"bigtest","permalink":"https://shleyz.github.io/tags/bigtest/"}]},{"title":"@bigtest/interactor介绍","date":"2020-01-07T08:20:57.000Z","path":"2020/01/07/bigtest-interactor/","text":"在生物学中，interactor 被定义为自然选择所作用的有机体的一部分。 BigTest interactor 定义了要对其进行测试的应用程序的一部分。您可以将 interactor 视为现代组件的可组合页面对象。 1234import &#123; interactor &#125; from '@bigtest/interactor';// an interactor can be scoped directly to an elementlet input = new interactor('[data-test-input]');let submit = new interactor('[data-test-submit]'); Interactor PropertiesInteractor 属性是惰性的，在访问之前不查找元素或属性。如果找不到该元素，则会引发错误。这比典型的期望失败更有用，因为我们知道期望失败的原因，而不仅仅是知道期望值不正确而失败了。 1234567// when the elements do not exist in the DOMinput.value; //=&gt; Error: unable to find \"[data-test-input]\"submit.text; //=&gt; Error: unable to find \"[data-test-submit]\"// when the elements do exist in the DOMinput.value; //=&gt; \"foo\"submit.text; //=&gt; \"Submit\" Immutable MethodsInteractor 是不可变的。方法返回 Interactor 的新实例，并在队列中附加一个 interaction。然后您可以通过调用 #run() 方法来在 Interactor 的队列中运行所有 Interactor。 12345678910// this does not actually focus the input yetlet focusInput = input.focus();// chaining additional interactions will add to the new instance queuelet focusAndFill = focusInput.fill('some value');// an interactor will wait until the element exists before interacting with itfocusAndFill.run().then(...) // the input was succesfully focused and filled with \"some value\".catch(...) // something went wrong, likely the input was not found Interactor 也可以相互组合以产生更复杂的交互。而且由于它们是不可变的，因此可以反复使用它们。 12345678910111213141516// remember, this does not actually interact with the elements yetlet fillInput = input .focus() .fill('some value') .blur();let submitForm = submit.click();// when this is run, it will focus, fill, and blur the input// before finally clicking on the submit buttonlet fillAndSubmit = fillInput.append(submitForm);// in one test...fillAndSubmit.run();// ... in anotherfillAndSubmit.run(); 默认的 interaction 方法可以选择接受一个选择器作为它们的第一个参数，以便您可以与作用域内的 interaction 中的元素进行交互。 interaction 也是可异步的，它可以立即调用#run（），从而允许 interaction 使用 async/await 语法。 123await new Interactor('[data-test-form]') .fill('[data-test-input]', 'some value') .click('[data-test-submit]'); 有关可用的默认属性和方法，请参阅Available Interactions。您可以通过创建自定义 interaction 来覆盖或定义自己的 interaction。这可以通过直接扩展 Interactor 类或使用@interactor 类装饰器和 interaction creators 来完成。","tags":[{"name":"bigtest","slug":"bigtest","permalink":"https://shleyz.github.io/tags/bigtest/"}]},{"title":"@bigtest使用","date":"2020-01-07T07:44:08.000Z","path":"2020/01/07/bigtest使用/","text":"假设您的应用程序正在使用以下技术： React Mocha Webpack or Parcel Installing Dependencies首先，安装 BigTest 所需的软件包： 1yarn add --dev @bigtest/cli @bigtest/interactor @bigtest/react @bigtest/cli 将使你能够访问文章内使用的 bigtest 命令。 @bigtest/interactor 允许您的测试以类似人与应用交互的方式与应用进行交互。 他们将等待元素出现，然后再与他们进行交互，这意味着您不必担心正确地安排测试时间以与任何运行循环同步。 （谁还有时间这样做？） @bigtest/react：React DOM helper，用于设置您的应用程序以进行验收测试。 初始化 BigTest现在已经安装了所有依赖项，然后转到项目根目录并运行 1npx bigtest init 这将创建一个新的 bigtest 目录： bigtest/├── bigtest.opts├── index.js├── helpers/│ └── setup-app.js├── interactors/│ └── app.js└── tests/└── app-test.js 导入你的应用您需要将应用程序根组件导入到 bigtest/helpers/setup-app.js 文件中。导入根组件： 12345678import &#123; setupAppForTesting &#125; from '@bigtest/react';import YourApp from '../../src/YourApp';export async function setupApplicationForTesting() &#123; await setupAppForTesting(YourApp, () =&gt; &#123; mountId: 'bigtesting-container'; &#125;);&#125; 启动和服务BigTest 通过将您的应用程序与您编写的测试文件捆绑在一起来工作。创建的所有测试都需要导入到 bigtest/index.js。您需要通过将捆绑器的入口点更改为 bigtest/index.js 来告诉捆绑器如何将测试与应用捆绑在一起。 bigtest CLI 会设置 NODE_ENV 为您测试。以 Webpack 为例，您可以检查 NODE_ENV 是否等于 test 并根据需要更改入口点： 12345// in your webpack.config.jslet isTesting = process.env.NODE_ENV === 'test';module.exports = &#123; entry: isTesting ? '.bigtest/index.js' : './src/index.js'&#125;; bigtest runbigtest run 处理启动不同的浏览器并实际运行测试的过程。将脚本添加到 package.json： 123\"scripts\": &#123; \"test\": \"bigtest run\"&#125; 因此，我们使用的是 package.json 中指定的@bigtest/cli 项目版本，而不是全局安装。 bigtest.optsbigtest.opts 文件使启动器（bigtest 运行）知道： 如何启动您的应用服务器（–serve） 应用服务的位置（–serve-url） 您正在使用什么测试框架（–adapter），目前最大的启动器仅适用于 mocha，但我们正在努力添加更多的适配器。 bigtest.opts 文件是一个配置文件，其中包含可以作为标志传递给 BigTest CLI 的各种选项。从 CLI 传递的参数优先于 opts 文件中指定的参数。 bigtest.opts 应该看起来像这样： 123--serve \"yarn start\"--serve-url \"http://localhost:3000\"--adapter mocha 运行测试现在，所有内容都已设置好，可以通过运行我们之前设置的测试命令进行检查： 1yarn test","tags":[{"name":"bigtest","slug":"bigtest","permalink":"https://shleyz.github.io/tags/bigtest/"}]},{"title":"@bigtest介绍","date":"2020-01-07T06:40:06.000Z","path":"2020/01/07/bigtest/","text":"知道应用程序是否正常运行的最可靠方法是实际运行它。大型测试会在每个测试用例之前启动整个应用程序。 您的应用程序是否在浏览器中运行？然后，如果测试要衡量其是否有效，它还需要在真实用户可能使用的真实浏览器中运行，并且应该针对真实 DOM 分配真实的 UI 事件。 进行大型测试很困难，因为在您的应用程序中可能同时发生数百甚至数千个事情。包括用户互动。 BigTest 是一个旨在简化和快速接受所有单页应用程序（SPA）的框架，无论框架或库如何。 当我们在网络上构建应用时，我们希望能够在接近用户的地方对其进行测试。 真实用户将使用真实的浏览器来访问你的应用；那么测试是否是在真实的浏览器中进行的呢？并非每个人都使用相同的浏览器，那么测试是否可以在多个不同的浏览器和设备上进行呢？网络呢？您的应用可能会与网络进行对话，而您的测试也应该考虑到这一点，对吧？更不用说一个人不会在组件级别上与您的应用进行交互。他们正在一起使用整个应用程序。 您的所有组件相互协作以创造一种体验。 如果测试无法以与人使用应用程序相同的方式测试应用程序，那么你会对自己的 app 有信心吗？ 在开始寻找最适合 SPA 的测试工具时，我们有一些要求： 快速 构建组件（包括可组合的组件） 跨浏览器（Firefox，IE，Safari 等 跨设备（Windows，macOS，iOS，Android 等） 跨框架（React，Vue，Ember，Angular 等） 跨测试框架（Mocha，Jasmine 等） 目前已经有类似的工具，如 Jest，但是这些测试无法在真正的浏览器中运行。还有赛普拉斯（Cypress），但截至本文撰写之时，您目前无法在 Chrome 之外使用它（其他不久将通过 webdriver 推出），并且还没有在组件中进行编写。 下面的对比： Test Framework Fast Cross Browser Cross Device Cross Test Runner Cross Framework Composable BigTest 🏎 ✅ ✅ ✅ ✅ ✅ Cypress 🚗 ❌ ❌ ❌ ✅ ❌ Selenium 🚌 ✅ ❌ ✅ ✅ ❌ Jest 🏎 ❌ ❌ ❌ ✅ ❌ 大多数现有框架都选中了其中一些（或部分选中了它们），但不是全部。随着移动浏览在当今世界变得如此普遍，我们需要一种可以轻松地在我们手边的任何设备上运行测试（通过访问 URL）的工具。 测试理念使用 BigTest 编写测试时，务必像用户将使用您的应用程序一样编写测试。当某人与您的应用进行交互时，他们使用的鼠标和键盘将转换为您的应用响应的浏览器事件。他们正在点击事物，期望取得成果。 这也是我们应用程序的测试所要做的：发送浏览器事件并断言有反馈。我们都知道存在跨浏览器的错误！ 如果是要访问组件或控制状态的测试，那不是适当的 BigTest。 所有互动都应来自用户群。需要注意的另一件事是，确保您断言的是用户在应用中看到或交互的状态。 目的是进行交互，并观察由交互引发的页面上的正确变更。 BigTest 如何运作？BigTest 会将您的应用程序安装并呈现到浏览器中。然后将执行您编写的测试。Interactor 驱动应用程序，它位于浏览器内部，带有 tests 和 render 的应用程序。这是 BigTest 与其他测试框架之间的主要区别，BigTest 没有控制浏览器的单独过程。 这就是为什么您只需访问 URL 即可运行 BigTests 的原因。 在高层的 BigTest 中： 启动您的应用程序服务器（捆绑测试和应用程序） 启动浏览器 开始运行测试运行器 Interactor 驱动应用程序（单击此处，访问路由等） 结果报告回 CLI 组成 BigTest 的软件包BigTest 框架由几个小程序包组成，这些程序包也可以单独使用。了解这些软件包及其在 BigTest 框架中的作用是有帮助的。 ConvergenceConvergence 是不可变，可重用和可组合的断言，使您可以立即知道何时达到期望的状态。简而言之：它每 10 毫秒检查一次 DOM（默认情况下为 2 秒），以查看您要检查的状态是否存在。 Convergence 是 BigTest 中所有事物的基础。这就是使 interactors 可靠的原因。CLI 中甚至将 Convergence 用于等待浏览器连接状态。 Interactor在生物学中， interactor 被定义为自然选择所作用的有机体的一部分。BigTest interactor 定义了要对其进行测试的应用程序的一部分。您可以将 interactor 视为现代组件的可组合页面对象。 interactor 是 BigTest 的灵魂，简而言之，我们将应用程序呈现到浏览器中，而交互器将其驱动。他们使用 Convergence 来确保元素存在并且可以在执行所需的交互之前与之交互。 interactor 还与您使用现代组件获得的可组合性相匹配。这意味着您可以以类似于编写 UI 的方式来编写测试。 要了解有关 interactor 的更多信息，请务必查看interactor guides。 CLIBigTest CLI 旨在简化 SPA 中的验收测试设置（例如 setup，build tool integration 和浏览器启动） 您可以将 CLI 视为 Karma 或 Testem，但更易于设置并包含其他可与 BigTest 框架配合使用的有用 CLI 命令（例如 bigtest init）。","tags":[{"name":"bigtest","slug":"bigtest","permalink":"https://shleyz.github.io/tags/bigtest/"}]},{"title":"LRU 缓存淘汰算法","date":"2019-12-19T09:02:43.000Z","path":"2019/12/19/LRU-缓存淘汰算法/","text":"","tags":[]},{"title":"在移动端浏览器中避免使用100vh","date":"2019-12-06T02:21:55.000Z","path":"2019/12/06/在移动端避免使用100vh/","text":"CSS中如果要设置元素的样式占据整个屏幕的高度，则可以设置height: 100vh。这样可以实现根据屏幕的高度而改变元素的高度，可以填充整个屏幕。 然而在实际中并非如此，100vh实现的功能在移动设备的浏览器中基本被破坏，使它基本没用。 核心原因就在于移动设备的浏览器中的地址栏，有时可见，有时隐藏，从而导致改变了视口的可见大小。但浏览器的可见高度改变时，并不是把可见高度的部分自适应为100vh，反而是：这些浏览器将100vh设置为浏览器的高度，地址栏隐藏。导致的结果是，当地址栏可见时，屏幕的底部将被切断，从而从一开始就破坏了100vh的目的。 如下所示： 当地址栏可见时，屏幕底部被切断，因为移动浏览器错误的将100vh设置为屏幕的高度，因此没有显示地址栏。在上图，本应该在屏幕底部被显示的按钮被隐藏了。 更糟糕的是，当用户第一次访问移动网站时，地址栏将显示在顶部，因此默认体验到的时错误的体验。 更好的解决方案：window.innerhight解决此问题的一种方法是依靠javascript而不是CSS。页面加载时，将高度设置为window.innerHeight，这样可以正确的将高度设置为视口的高度。如果地址栏可见，window.innerHeight则将是全屏的高度。如果地址栏是隐藏的，window.innerHeight则将是屏幕上可见部分的高度，这正是我们所期望的。 遗憾的是，在不依赖JavaScript的情况下，仍然没有一种简单的方法来使元素占据整个视口高度。height: 100vh 非常接近，但给它在移动端浏览器上有局限性，最好避免这样使用它。","tags":[{"name":"移动端开发","slug":"移动端开发","permalink":"https://shleyz.github.io/tags/移动端开发/"}]},{"title":"display:flex和position:absolute/fixed一起用产生的问题","date":"2019-11-26T05:40:09.000Z","path":"2019/11/26/display：flex和position-absolute-fixed/","text":"在开发中遇到这样的问题 123456789101112131415.layout &#123; position: absolute; width: 100%; height: 100%; display: flex; flex-direction: row;&#125;.layout .block1 &#123; width: 12em;&#125;.layout .block2 &#123; flex: 1;&#125; 发现 layout 下面的 block2 并不是占用 block1 剩余的空间的，flex 布局没有生效 所以，被绝对定位与固定定位的盒子不参与 flex 布局。 解决办法，可以在要 flex 布局的盒子外面套一层盒子： 1234567891011121314151617181920.layout &#123; position: absolute; width: 100%; height: 100%;&#125;.layout .container &#123; display: flex; flex-direction: row; width: 100%; height: 100%;&#125;.layout .container .block1 &#123; width: 12em;&#125;.layout .container .block2 &#123; flex: 1;&#125; 完美解决问题","tags":[]},{"title":"将callback转换为Promise","date":"2019-11-08T12:02:02.000Z","path":"2019/11/08/将callback转换为Promise/","text":"与回调函数相比，使用 Promises（或 Async / await）更容易。 在基于 Node 的环境中工作时尤其如此。 不幸的是，大多数 Node API 都是使用回调编写的。 下面，我们来看看如何将回调转换成 Promise 。 在这之前我们需要详细了解 Promise 将 Node 样式的回调转换为 PromiseNode API 的回调具有相同的模式。 它们作为最后一个参数传递给函数。 这是 fs.readFile 的示例。 12const fs = require('fs');fs.readFile(filePath, options, callback); 另外，每个回调至少包含两个参数。 第一个参数必须是一个错误对象 err。 1234567fs.readFile('some-file', (err, data) =&gt; &#123; if (err) &#123; // Handle Error &#125; else &#123; // Handle Data &#125;&#125;); 如果遇到这种模式的回调，则可以使用 Node 的 util.promisify 将其转换为 Promise。 1234const fs = require('fs');const util = require('util');const readFilePromise = util.promisify(fs.readFile); 将回调转换为 Promise 后，便可以像使用其他 Promise 一样使用它: 1234567readFilePromise(filePath, options) .then(data =&gt; &#123; // Handle Data &#125;) .catch(err =&gt; &#123; // Handle Error &#125;); 有时，您可能会遇到不符合 Node 的错误优先回调格式的 API。 对于这些情况，您不能使用 util.promisify。 您需要写下自己的 Promise。 来写自己的 Promise:要将回调转换为 Promise，需要返回 Promise。 12345const readFilePromise = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // ... &#125;);&#125;; 你可以在 promise 中使用回调运行代码。 1234567const readFilePromise = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(filePath, options, (err, data) =&gt; &#123; // ... &#125;); &#125;);&#125;; 如果有错误，reject。 这使用户可以处理 catch 中的错误。 如果没有错误，resolve。 这使用户可以决定接下来要做什么。 12345678910const readFilePromise = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(filePath, options, (err, data) =&gt; &#123; if (err) &#123; return reject(err); &#125; resolve(data); &#125;); &#125;);&#125;; 接下来，您需要为 promise 中的代码提供诸如 filePath 之类的参数和选项。 为此，您可以使用 rest 和 spread 运算符。 12345678910const readFilePromise = (...args) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(...args, (err, data) =&gt; &#123; if (err) &#123; return reject(err); &#125; resolve(data); &#125;); &#125;);&#125;; 然后，你就可以将 readFilePromise 用作 Promise。 123readFilePromise(filePath, options) .then(data =&gt; &#123;&#125;) .catch(err =&gt; &#123;&#125;); 将非 Node 样式的回调转换为 Promise一旦你知道如何构造 Promise，就可以轻松地将非 Node 样式的回调转换为 Promise。 它们遵循相同的步骤： 如果有错误则 reject否则 resolve 假设您有一个 API，该 API 返回数据作为第一个参数，而 err 作为第二个参数。 我们是这样做的： 1234567891011const shootPeasPromise = (...args) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // 这不是一个 Node 样式的回调（），这里回调的第一个参数不是 err shootPeas(...args, (data, err) =&gt; &#123; if (err) &#123; reject(err); &#125; resolve(data); &#125;); &#125;);&#125;; 多个参数的回调假设你有一个包含三个参数的回调： 错误对象 err一些数据 location另一条数据 size 1grewTrees(oprions, (err, location, size) =&gt; &#123;&#125;); 我们不能这样写： 1234567891011// 这样做是不对的, 因为 Promise 只返回一个参数const growTreesPromise = (...args) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; growTrees(...args, (err, location, size) =&gt; &#123; if (err) &#123; reject(err); &#125; resolve(location, size); &#125;); &#125;);&#125;; 如果想要 Promise 返回多个参数，可以返回一个数组或对象 12345// 返回数组resolve([location, size]);// 返回对象resolve(&#123; location, size &#125;); 然后，您可以在 then 调用中解构数组或对象。 1234567891011growTreesPromise(options) .then(([location, size]) =&gt; &#123; // 解构处理数组 &#125;) .catch(err =&gt; &#123;&#125;);growTreesPromise(options) .then((&#123; location, size &#125;) =&gt; &#123; // 解构处理对象 &#125;) .catch(err =&gt; &#123;&#125;); 文章参考自 zellwk","tags":[{"name":"javascript","slug":"javascript","permalink":"https://shleyz.github.io/tags/javascript/"}]},{"title":"stripes 问题汇总","date":"2019-10-31T01:01:35.000Z","path":"2019/10/31/stripes-问题汇总/","text":"自定义的组件库需要放在@folio 文件夹下面 platform-complete 里面的 stripes 版本必须大于各个模块的 stripes 版本 启动或者打包报内存溢出的问题，启动或者打包的时候需要添加参数–max-old-space-size 自定义组件的国际化语言包找不到的问题： 自定义组件的包名以 stripes 开头，要和 package.json 里面的包名一致，也要和 tranlations 文件夹下面的文件夹名称一致。在 local 启动的时候单个模块需要额外配置 stripes.config.js.local 和.stripesclirc 以使得 stripes-core 模块内部能够找到语言包。 文件 stripes.config.js.local 如下： 1234567891011121314151617module.exports = &#123; okapi: &#123; url: 'https://folio-testing-okapi.aws.indexdata.com', tenant: 'diku' &#125;, config: &#123; logCategories: 'core,path,action,xhr', logPrefix: '--', showPerms: false, hasAllPerms: false, languages: ['en'] &#125;, modules: &#123; '@folio/stripes-your-components': &#123;&#125;, '@folio/users': &#123;&#125; &#125;&#125;; 文件 .stripesclirc 如下: 1234567&#123; \"configFile\": \"stripes.config.js.local\", \"port\": 3000, \"aliases\": &#123; \"@folio/stripes-smart-components-jt\": \"../@folio/stripes-your-components\" &#125;&#125; svgo 报错： 方法一： 可以在 package.json 锁定， “svgo”: “1.3.0” 方法二： svgo 1.3.2 已经发布，应该也可以解决该问题。","tags":[{"name":"FOLIO","slug":"FOLIO","permalink":"https://shleyz.github.io/tags/FOLIO/"}]},{"title":"webpack构建多页面打包","date":"2019-10-17T11:02:14.000Z","path":"2019/10/17/webpack构建多页面打包/","text":"极客时间版权所有: https://time.geekbang.org/dailylesson/detail/100028427 我们通常说的多页面应用，就是由多个完整页面构成的，它的优势是首屏时间快，SEO 效果好。多页面应用特别常见，因此针对多页面应用提供一个通用的 webpack 打包方案，就显得很重要了。 实现多页面应用的核心就是 webpack 多个 entry 配置 但是如果我们总是去操作 webpack 来添加删除 entry 就会不是很方便，那么怎样实现不把多个 entry 值暴露给开发者，而是自动配置呢。 那就是设置一个合理的 entry 匹配规则，让 webpack 的 entry 的值自动计算出来。还有一个关键点就是 html-webpack-plugin 的数量，多个页面就会需要多个数量的 html-webpack-plugin（根据 HTML 模版自动生成 HTML 页面,同时会把 js 和 css 注入进去） 总结起来就是： 设置一个合理的 entry 匹配规则 自动计算 entry 值 根据 entry 的 key 值增加对应的 html-webpack-plugin 首先我们要规范目录结构，可以用脚手架，也可以自定义，如下 . ├── node_modules├── src│ ├── pages│ ├── page1│ │ ├── index.js│ │ └── index.html│ ├── page2│ │ ├── index.js│ │ └── index.html│ ││ └── page3│ ├── index.js│ └── index.html├── package-lock.json├── package.json└── webpack.config.js 这样我们只要找出 src/pages 下面的文件夹","tags":[]},{"title":"package.json 中的 Peer Dependencies","date":"2019-10-17T00:55:36.000Z","path":"2019/10/17/package-json中的peerDependencies/","text":"假设我们当前的项目是 MyProject，项目中有一些依赖，比方其中有一个依赖包 PackageA，该包的 package.json 文件指定了对 PackageB 的依赖： 12345&#123; \"dependencies\": &#123; \"PackageB\": \"1.0.0\" &#125;&#125; 如果我们在我们的 MyProject 项目中执行 npm install PackageA, 我们会发现我们项目的目录结构会是如下形式： 12345MyProject└──┬─ node_modules └──┬─ PackageA └──┬─ node_modules └── PackageB 那么在我们的项目中，我们能通过下面语句引入”PackageA”： 1var packageA = require('PackageA'); 但是，如果你想在项目中直接引用 PackageB: 12var packageA = require('PackageA');var packageB = require('PackageB'); 这是不行的，即使 PackageB 被安装过；因为 Node 只会在“MyProject/node_modules”目录下查找 PackageB，它不会在进入 PackageA 模块下的 node_modules 下查找。所以，为了解决这个问题，在 MyProject 项目 package.json 中我们必须直接声明对 PackageB 的依赖并安装。 但是，有时我们不用在当前项目中声明对 PackageB 的依赖就可以直接引用，尤其是，PackageA 是一个类似于 grunt 的插件，例如 grunt-contrib-jshint。 为什么在项目中不用声明就可以直接使用呢？这就不得不说说 peerDependencies 的作用了。 peerDependencies 的引入为了解决这种问题： 1如果你安装我，那么你最好也安装X,Y和Z. 于是 peerDependencies 就被引入了。例如上面 PackageA 的 package.json 文件如果是下面这样： 12345&#123; \"peerDependencies\": &#123; \"PackageB\": \"1.0.0\" &#125;&#125; 那么，它会告诉 npm：如果某个 package 把我列为依赖的话，那么那个 package 也必需应该有对 PackageB 的依赖。 也就是说，如果你 npm install PackageA，你将会得到下面的如下的目录结构： 1234MyProject└─┬─node_modules ├─ PackageA └─ PackageB 你可能注意到： 在 npm2 中，即使当前项目 MyProject 中没有直接依赖 PackageB，该 PackageB 包依然会安装到当前项目的 node_modules 文件夹中。 下面的代码现在可以正常工作了，因为两个包在”MyProject/node_modules”中被安装了： 12var packageA = require('PackageA');var packageB = require('PackageB'); 总结一句话，peerDependencies 的具体作用： peerDependencies 的目的是提示宿主环境去安装满足插件 peerDependencies 所指定依赖的包，然后在插件 import 或者 require 所依赖的包的时候，永远都是引用宿主环境统一安装的 npm 包，最终解决插件与所依赖包不一致的问题。 举个例子，就拿目前基于 react 的 ui 组件库 ant-design@3.x 来说，因该 ui 组件库只是提供一套 react 组件库，它要求宿主环境需要安装指定的 react 版本。具体可以看它 package.json 中的配置： 1234\"peerDependencies\": &#123; \"react\": \"&gt;=16.0.0\", \"react-dom\": \"&gt;=16.0.0\"&#125; 它要求宿主环境安装 react@&gt;=16.0.0 和 react-dom@&gt;=16.0.0 的版本，而在每个 antd 组件的定义文件顶部： 12import * as React from 'react';import * as ReactDOM from 'react-dom'; 组件中引入的 react 和 react-dom 包其实都是宿主环境提供的依赖包。 文章来源","tags":[{"name":"webpack","slug":"webpack","permalink":"https://shleyz.github.io/tags/webpack/"}]},{"title":"05 索引：下","date":"2019-10-10T09:15:42.000Z","path":"2019/10/10/05-索引：下/","text":"在开始这篇文章之前，我们先来看一下这个问题： 在下面这个表 T 中，如果我执行 select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？下面是这个表的初始化语句。 12345678mysql&gt; create table T (ID int primary key,k int NOT NULL DEFAULT 0, s varchar(16) NOT NULL DEFAULT '',index k(k))engine=InnoDB;insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg'); 现在，我们一起来看看这条 SQL 查询语句的执行流程： 在 k 索引树上找到 k=3 的记录，取得 ID = 300； 再到 ID 索引树查到 ID=300 对应的 R3； 在 k 索引树取下一个值 k=5，取得 ID=500； 再回到 ID 索引树查到 ID=500 对应的 R4； 在 k 索引树取下一个值 k=6，不满足条件，循环结束。 在这个过程中，回到主键索引树搜索的过程，我们称为回表。可以看到，这个查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。 在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？ 覆盖索引如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。 由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。 需要注意的是，在引擎内部使用覆盖索引在索引 k 上其实读了三个记录，R3~R5（对应的索引 k 上的记录项），但是对于 MySQL 的 Server 层来说，它就是找引擎拿到了两条记录，因此 MySQL 认为扫描行数是 2。 基于上面覆盖索引的说明，我们来讨论一个问题：在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？ 假设这个市民表的定义是这样的： 1CREATE TABLE `tuser` ( `id` int(11) NOT NULL, `id_card` varchar(32) DEFAULT NULL, `name` varchar(32) DEFAULT NULL, `age` int(11) DEFAULT NULL, `ismale` tinyint(1) DEFAULT NULL, PRIMARY KEY (`id`), KEY `id_card` (`id_card`), KEY `name_age` (`name`,`age`)) ENGINE=InnoDB 我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？ 如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://shleyz.github.io/tags/MySQL/"}]},{"title":"04 索引：上","date":"2019-10-09T04:51:42.000Z","path":"2019/10/09/04-索引：上/","text":"提到数据库索引，我想你并不陌生，在日常工作中会经常接触到。比如某一个 SQL 查询比较慢，分析完原因之后，你可能就会说“给某个字段加个索引吧”之类的解决方案。但到底什么是索引，索引又是如何工作的呢？今天就让我们一起来聊聊这个话题吧。 一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。 索引的常见模型索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，这里我先给你介绍三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。 下面我主要从使用的角度，为你简单分析一下这三种模型的区别。 1. 哈希表哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。 不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。 假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示： 图中，User2 和 User4 根据身份证号算出来的值都是 N，但没关系，后面还跟了一个链表。假设，这时候你要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。 需要注意的是，图中四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。 你可以设想下，如果你现在要找身份证号在 [ID_card_X, ID_card_Y] 这个区间的所有用户，就必须全部扫描一遍了。 所以，哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。 2. 有序数组而有序数组在等值查询和范围查询场景中的性能就都非常优秀。还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示： 这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查 ID_card_n2 对应的名字，用二分法就可以快速得到，这个时间复杂度是 O(log(N))。 同时很显然，这个索引结构支持范围查询。你要查身份证号在 [ID_card_X, ID_card_Y] 区间的 User，可以先用二分法找到 ID_card_X（如果不存在 ID_card_X，就找到大于 ID_card_X 的第一个 User），然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证号，退出循环。 如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。 所以，有序数组索引只适用于静态存储引擎，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。 3. 二叉搜索树二叉搜索树也是课本里的经典数据结构了。还是上面根据身份证号查名字的例子，如果我们用二叉搜索树来实现的话，示意图如下所示： 二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&gt; UserC -&gt; UserF -&gt; User2 这个路径得到。这个时间复杂度是 O(log(N))。 当然为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O(log(N))。 树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。 你可以想象一下一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。 为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。 以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。 N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。 总结不管是哈希还是有序数组，或者 N 叉树，它们都是不断迭代、不断优化的产物或者解决方案。数据库技术发展到今天，跳表、LSM 树等数据结构也被用于引擎设计中，这里我就不再一一展开了。 你心里要有个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。 截止到这里，我用了半篇文章的篇幅和你介绍了不同的数据结构，以及它们的适用场景，你可能会觉得有些枯燥。但是，我建议你还是要多花一些时间来理解这部分内容，毕竟这是数据库处理数据的核心概念之一，在分析问题的时候会经常用到。当你理解了索引的模型后，就会发现在分析问题的时候会有一个更清晰的视角，体会到引擎设计的精妙之处。 实战在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。由于 InnoDB 存储引擎在 MySQL 数据库中使用最为广泛，所以下面我就以 InnoDB 为例，和你分析一下其中的索引模型。 InnoDB 的索引模型在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。 每一个索引在 InnoDB 里面对应一棵 B+ 树。 假设，我们有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。 这个表的建表语句是： 12345mysql&gt; create table T(id int primary key, k int not null, name varchar(16),index (k))engine=InnoDB; 表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。 从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。 主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。 根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区别？ 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树； 如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。 也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。 索引维护B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。 而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。 除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。 当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。 基于上面的索引维护过程说明，我们来讨论一个案例： 你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。 自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。 插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。 也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。 而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。 除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？ 由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。 显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。 所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。 有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的： 只有一个索引； 该索引必须是唯一索引。 你一定看出来了，这就是典型的 KV 场景。 由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。 这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://shleyz.github.io/tags/MySQL/"}]},{"title":"03 事务隔离：为什么你改了我还看不见","date":"2019-10-09T04:30:55.000Z","path":"2019/10/09/03-事务隔离：为什么你改了我还看不见/","text":"提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转账，你要给朋友小王转 100 块钱，而此时你的银行卡只有 100 块钱。 转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，你这 100 块钱，完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念了。 简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。 今天的文章里，我将会以 InnoDB 为例，剖析 MySQL 在事务支持方面的特定实现，并基于原理给出相应的实践建议，希望这些案例能加深你对 MySQL 事务原理的理解。 隔离性与隔离级别提到事务，你肯定会想到 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天我们就来说说其中 I，也就是“隔离性”。 当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。 在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释： 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 其中“读提交”和“可重复读”比较难理解，所以我用一个例子说明这几种隔离级别。假设数据表 T 中只有一列，其中一行的值为 1，下面是按照时间顺序执行两个事务的行为。 12mysql&gt; create table T(c int) engine=InnoDB;insert into T(c) values(1); 我们来看看在不同的隔离级别下，事务 A 会有哪些不同的返回结果，也就是图里面 V1、V2、V3 的返回值分别是什么。 若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。 若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。 若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。 若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。 在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。 在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。 我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle 数据库的默认隔离级别其实就是“读提交”，因此对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，你一定要记得将 MySQL 的隔离级别设置为“读提交”。 配置的方式是，将启动参数 transaction-isolation 的值设置成 READ-COMMITTED。你可以用 show variables 来查看当前的值。 123456789101112mysql&gt; show variables like 'transaction_isolation';+-----------------------+----------------+| Variable_name | Value |+-----------------------+----------------+| transaction_isolation | READ-COMMITTED |+-----------------------+----------------+ 总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。我想你可能会问那什么时候需要“可重复读”的场景呢？我们来看一个数据校对逻辑的案例。 假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。 这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。 事务隔离的实现理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。 在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。 假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。 当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。 同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。 你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。 什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 read-view 的时候。 基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。 长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。 在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。 除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。 事务的启动方式如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL 的事务启动方式有以下几种： 显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。 set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。 有些客户端连接框架会默认连接成功后先执行一个 set autocommit=0 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。 因此，我会建议你总是使用 set autocommit=1, 通过显式语句的方式来启动事务。 但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你使用 commit work and chain 语法。 在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。 你可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。 1select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60 总结介绍了 MySQL 的事务隔离级别的现象和实现，根据实现原理分析了长事务存在的风险，以及如何用正确的方式避免长事务。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://shleyz.github.io/tags/MySQL/"}]},{"title":"02 日志系统：一条SQL更新语句是如何执行的","date":"2019-10-09T02:40:29.000Z","path":"2019/10/09/02-日志系统：一条SQL更新语句是如何执行的/","text":"一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。 那么，一条更新语句的执行流程又是怎样的呢？ 之前你可能经常听 DBA 同事说，MySQL 可以恢复到半个月内任意一秒的状态，惊叹的同时，你是不是心中也会不免会好奇，这是怎样做到的呢？ 我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键 ID 和一个整型字段 c： 1mysql&gt; create table T(ID int primary key, c int); 如果要将 ID=2 这一行的值加 1，SQL 语句就会这么写： 1mysql&gt; update T set c=c+1 where ID=2; 前面介绍过 SQL 语句基本的执行链路，这里再把那张图拿过来，你也可以先简单看看这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。 你执行语句前要先连接数据库，这是连接器的工作。 前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。 接下来，分析器会通过词法和语法解析知道这是一条更新语句。 优化器决定要使用 ID 这个索引。 然后，执行器负责具体执行，找到这一行，然后更新。 与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）。如果接触 MySQL，那这两个词肯定是绕不过的，我后面的内容里也会不断地和你强调。不过话说回来，redo log 和 binlog 在设计上有很多有意思的地方，这些设计思路也可以用到你自己的程序里。 重要的日志模块-物理日志：redo log不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。 如果有人要赊账或者还账的话，掌柜一般有两种做法： 一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉； 另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。 在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。 这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？ 同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。 而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。 具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。 如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。 与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。 write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。 write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。 有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。 要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。 重要的日志模块-逻辑日志：binlog前面我们讲过，MySQL 整体来看，其实就有两块： 一块是 Server 层，它主要做的是 MySQL 功能层面的事情； 还有一块是引擎层，负责存储相关的具体事宜。 上面我们聊到的粉板 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。 我想你肯定会问，为什么会有两份日志呢？ 因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。 这两种日志有以下三点不同。 redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。 redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。 redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 有了对这两个日志的概念性理解，我们再来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。 这里我给出这个 update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。 你可能注意到了，最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是”两阶段提交”。 两阶段提交为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起：怎样让数据库恢复到半个月内任意一秒的状态？ 前面我们说过了，binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。 当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做： 首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库； 然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。 这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。 好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。 由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。 仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？ 先写物理日志 redo log 后写逻辑日志 binlog。 假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。 先写逻辑日志 binlog 后写物理日志 redo log。 如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。 可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？ 其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用 binlog 来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。 简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。 总结redo log 用于保证 crash-safe 能力 innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数建议设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。 sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数也建议设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。 本文介绍了与 MySQL 日志系统密切相关的“两阶段提交”。两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案，即使你不做数据库内核开发，日常开发中也有可能会用到。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://shleyz.github.io/tags/MySQL/"}]},{"title":"01 基础架构：一条SQL查询语句是如何执行的","date":"2019-10-09T01:55:13.000Z","path":"2019/10/09/01-基础架构：一条SQL查询语句是如何执行的/","text":"来自 丁奇的MySQL基础课 https://time.geekbang.org/column/article/115537 最简单的一条查询语句： 1mysql&gt; select * from T where ID=10; 这条语句在 MySQL 内部的执行过程是怎样的呢？ 大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。 Server 层包括连接器、查询缓存、分析器、优化器、执行器等。涵盖了 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期，时间，数学和加密函数等），所有跨存储引擎的功能都在这一层实现。比如存储过程、触发器、视图等。 存储引擎负责数据的存和取，其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。 也就是说，你执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table 语句中使用 engine=memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同。 从图中不难看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来我们结合开头提到的那条 SQL 语句，带你走一遍整个执行流程，依次看下每个组件的作用。 连接器第一步，先连接到这个数据库上，连接器负责与客户端建立连接、获取权限、维持和管理连接。连接命令： 1mysql -h$ip -P$port -u$user -p 输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在 -p 后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。 连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。 如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。 这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。 连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。 客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒：1Lost connection to MySQL server during query。 这时候如果你要继续，就需要重连，然后再执行请求了。 数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。 但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。怎么解决这个问题呢？你可以考虑以下两种方案。定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。 查询缓存连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。 MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。 key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。 如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。 但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。 好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样： 1mysql&gt; select SQL_CACHE * from T where ID=10； 需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。 分析器如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。 分析器先会做词法分析。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。 做完了这些识别以后，就要做语法分析。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。 如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。 1234mysql&gt; elect * from t where ID=1;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'elect * from t where ID=1' at line 1 一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。 优化器经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。 优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join： 1mysql&gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20; 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。 这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。 优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单独展开说明优化器的内容。 执行器MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。 开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。 1234mysql&gt; select * from T where ID=10;ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T' 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。 比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的： 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中； 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 至此，这个语句就执行完成了。 对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。 你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。 在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://shleyz.github.io/tags/MySQL/"}]},{"title":"nginx 启用websocket连接","date":"2019-09-02T06:11:22.000Z","path":"2019/09/02/nginx-启用websocket连接/","text":"nginx配置ws代理12345678910111213141516171819server &#123; listen 8888; server_name XXXXXXXX; location /api &#123; proxy_pass http://XXX.XXX.XX.XX:XXXX/; &#125; // 启用支持websocket连接 location /ws &#123; proxy_pass http://XXX.XXX.XX.XX:XXXX/; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; &#125; location / &#123; root /root/www/XXX; index index.html index.htm; try_files $uri $uri/ /index.html; &#125;&#125; 本地webpack配置ws代理:1234567\"/ws\": &#123; changeOrigin: true, ws: true, pathRewrite: &#123; \"/ws\": \"/\" &#125;&#125;,","tags":[{"name":"nginx","slug":"nginx","permalink":"https://shleyz.github.io/tags/nginx/"}]},{"title":"前端优化总结","date":"2019-08-21T12:10:04.000Z","path":"2019/08/21/前端优化总结/","text":"dns 预解析 DNS 全称为 Domain Name System，即域名系统，是域名和 IP 地址相互映射的一个分布式数据库。 浏览器对网站第一次的域名 DNS 解析查找流程依次为：浏览器缓存 - 系统缓存 - 路由器缓存 - ISP DNS 缓存 - 递归搜索 DNS 预解析是浏览器试图在用户访问链接之前解析域名，这是计算机的正常 DNS 解析机制。 x-DNS-Prefetch-Control 头控制着浏览器的 DNS 预解析功能 X-DNS_prefetch-Control: on|off on：启用 DNS 预解析。在浏览器支持 DNS 预解析的特性时及时不适用该标签浏览器依然会进行预解析。off：关闭 DNS 预解析。这个属性在页面上的链接并不是由你控制的或是你根本不想向这些域名引导数据时非常有用。 12// 打开和关闭DNS预读取&lt;meta http-equiv=\"x-dns-prefetch-control\" content=\"on\"&gt; 12// 强制查询特定主机名&lt;link ref=\"dns-prefetch\" href=\"//hm.baidu.com\"&gt; 服务端避免返回重定向（不是缓存重定向） 如果服务器返回了跳转重定向（非缓存重定向），那么浏览器端就会向新的 URL 地址重新走一遍 DNS 解析和建立连接。所以应该避免不必要的重定向 静态资源服务器 cdn 减少页面中的请求数量 gzip 对响应体进行压缩，可减少 70%大小数据 减少 cookie 的使用 图片格式 合理使用缓存 简化 dom 结构 减少 DOM 树和渲染树构建成本，减少页面元素个数 js 脚本放在 body 最后面，不要阻塞其他过程 减少不必要的 dom 操作， 例如修改 classname 而不是修改 style，减少对重排和重绘的触发 将 css 放入 head 中，提前加载 使用更高性能的 css 样式，例如 flex 替代 float 合理使用 absolute 等脱离文档流 对页面某些数据 storage 存储 加载进度、骨架图、占位图等类似让用户感觉好一点的措施","tags":[]},{"title":"Restful API总结","date":"2019-07-22T02:54:40.000Z","path":"2019/07/22/Restful-API总结/","text":"Restful 是目前最流行的 API 设计规范， 用于 web 接口设计。 1 URL 设计Restful 的核心就是客户端发出的数据操作指令都是 “动词 + 宾语” 的形式 1.1 动词通常是五种 http 方法，对应 curd 操作 GET：读取（Read） POST：新建（Create） PUT：更新（Update） PATCH：更新（Update），通常是部分更新 DELETE：删除（Delete） 1.2 动词的覆盖有些客户端只能使用 GET 和 POST 这两种方法，服务器必须接受 POST 模拟其他三个方法（PUT、PATCH、DELETE）。 这时，客户端发出的 HTTP 请求，要加上 X-HTTP-Method-Override 属性，告诉服务器应该使用哪一个动词，覆盖 POST 方法。 12POST /api/Person/4 HTTP/1.1X-HTTP-Method-Override: PUT 上面代码中，X-HTTP-Method-Override 指定本次请求的方法是 PUT，而不是 POST。 1.3 宾语必须是名词宾语就是 API 的 URL，是 HTTP 动词作用的对象。 1.4 复数 URL建议都使用复数 url 1.5 避免多级 url比如获取某个作者的某一类文章： GET /authors/12/categories/2 这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。 更好的做法是: 除了第一级，其他级别都用查询字符串表达。 GET /authors/12?categories=2 2 状态码，状态码必须精确HTTP 状态码就是一个三位数，分成五个类别： 1xx：相关信息 2xx：操作成功 3xx：重定向 4xx：客户端错误 5xx：服务器错误 2.1 API 不需要 1xx 状态码2.2 2XX 状态码GET 200 表示操作成功POST 201 表示生成了新的资源DELETE 204 表示资源已经不存在 2.3 3XX 状态码，重定向API 用不到的（浏览器会自动跳转）： 301 永久重定向 302 暂时重定向， 用于 GET 请求 API 用得到的： 303 表示参考另一个 URL， 主要用于 POST、PUT 和 DELETE 请求， 浏览器不会自动跳转 2.4 4XX 状态码, 表示客户端错误 400 Bad Request: 服务器不理解客户端的请求，未做任何处理. 401 Unauthorized: 用户未提供身份验证凭据，或者没有通过身份验证. 403 Forbidden: 用户通过了身份验证，但是不具有访问资源所需的权限. 404 Not Found: 所请求的资源不存在，或不可用. 405 Method Not Allowed: 用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内. 等等 2.5 5XX 状态码, 表示服务端错误。一般来说，API 不会向用户透露服务器的详细信息 500 Internal Server Error：客户端请求有效，服务器处理时发生了意外 503 Service Unavailable：服务器无法处理请求，一般用于网站维护状态 3. 服务器回应3.1 返回对象应该是 json 对象3.2 发生错误时，不要返回 200 状态码3.3 提供链接","tags":[{"name":"RestfulAPI","slug":"RestfulAPI","permalink":"https://shleyz.github.io/tags/RestfulAPI/"}]},{"title":"react typescript项目搭建-2优化开发体验","date":"2019-07-21T02:20:14.000Z","path":"2019/07/21/react-typescript项目搭建-3优化/","text":"集成 antdnpm install -S antd 修改 antd 的主题配色 antd 的样式使用 less 进行编写, 首先要安装 less 和 less-loader 注意 less 版本要小于 3.0，否则会报错 npm install -D less less-loader 在根目录下添加一个 theme.js 文件 1234module.exports = &#123; \"primary-color\": \"red\", \"border-radius-base\": \"20px\"&#125;; 在 build/rules/styleRules 中添加针对 less 文件的 loader 123456789101112131415161718192021const &#123; resolve &#125; = require(\"../utils\");const theme = require(\"./../../theme\");module.exports = [ &#123; test: /\\.less$/, include: [resolve(\"node_modules\")], use: [ \"style-loader\", \"css-loader\", &#123; loader: \"less-loader\", options: &#123; // 禁用内联js代码 javascriptEnable: false, // 根据antd官网进行主题修改 modifyVars: theme &#125; &#125; ] &#125;]; 全局引入 antd 的样式文件 在 src/index.tsx 中 import “antd/dist/antd.less”; antd 按需加载import { Button } from ‘antd’; 这样的引入方式存在一个很大的弊端，就是在引入其中某个组件的同时会把整个 antd 文件都引入进来，影响构建速度，而且打包后体积会变大， 因此需要做 antd 的按需加载: 123456//tsconfig.json&#123; ... \"module\": \"ESNext\", ...&#125; 1npm install -D ts-import-plugin 修改 build/rules/jsRule.js 12345678910111213141516171819202122232425262728const &#123; resolve &#125; = require(\"../utils\");const tsImportPluginFactory = require(\"ts-import-plugin\");module.exports = [ &#123; // 匹配要解析的文件 test: /\\.ts(x?)$/, use: [ &#123; loader: \"awesome-typescript-loader\", options: &#123; transpileOnly: true, useCache: true, cacheDirectory: resolve(\".cache-loader\"), getCustomTransformers: () =&gt; (&#123; before: [ tsImportPluginFactory(&#123; libraryName: \"antd\", libraryDirectory: \"lib\", style: true // 填写 true 使用组件的 less 文件， 填写 css 使用css文件但是同时不能定制主题 &#125;) ] &#125;) &#125; &#125; ] &#125;]; 热加载npm install -D react-hot-loader 集成 mobxnpm install -S mobx npm install -S mobx-react","tags":[{"name":"typescript","slug":"typescript","permalink":"https://shleyz.github.io/tags/typescript/"}]},{"title":"react typescript项目搭建-2优化开发体验","date":"2019-07-20T05:24:34.000Z","path":"2019/07/20/react-typescript项目搭建-2优化开发体验/","text":"在前面的基础搭建之后，如何提升开发体验呢，例如 sass，css module 等 支持 sass12npm install -D node-sass sass-loadernpm install -D style-loader css-loader scss 代码的编译过程： sass-loader 将 sass 代码编译为 css css-loader 将编译出来的代码再次编译成为符合 CommonJS 的代码 style-loader 将第二步编译出来的代码转为 js 代码从上面这三个步骤看出： webpack 进行 loader 编译的顺序是从下到上的 进行配置 webpack（在 module.rules 下面加上.scss 文件类型的编译配置）： 12345&#123; test: /\\.scss$/, include: [path.join(__dirname, \"./../\", \"src\")], use: [\"style-loader\", \"css-loader\", \"sass-loader\"]&#125; 解决模块声明问题在根目录下创建 typings 文件夹，里面的 .d.ts 文件进行声明 配置公共 sass自定义： 根目录/src/styles/var.scss 内编写公共的 sass在其他样式文件里面直接导入使用 @import 优化路径1import Test from \"../../../../components/Test\"; 改成为这样写： 1import Test from \"@comonents/Test\"; 在 tsconfig 中进行配置: 1234\"baseUrl\": \"./src\"\"paths\": &#123; \"@components/*\": [\"components/*\"]&#125; 安装 tsconfig-paths-webpack-plugin 将 tsconfig 中对路径的设置映射到 webpack 配置 1npm install -D tsconfig-paths-webpack-plugin 修改 webpack 配置： 12345678resolve: &#123; extensions: [\".ts\", \".tsx\", \".js\", \".jsx\"], plugins: [ new TsconfigPathsPlugin(&#123; configFile: path.join(__dirname, \"./../\", \"tsconfig.json\") &#125;) ] &#125;, 构建缓存我们一般会使用 webpack-dev-server 来进行项目开发，当我们运行 webpack-dev-server 的时候它会在内存中进行项目的构建，但是当使用了 babel 之类的代码转换工具后，会对项目构建产生较大的性能影响，这是因为每一次的构建都会对代码进行重新转换。而构建缓存就是将构建的公用代码缓存在磁盘上，这样做的效果就是第一次构建的时间花销会比不用缓存的构建大，但是在之后每次构建的时间花销都会大大减少。 在设置构建缓存之前我们首先要考虑的是那些地方需要进行设置： 对 ts(x)的转换 babel 转换 scss 转换 1. 对 ts(x)的转换用的是 awesome-typescript-loader，这个库本身自带了开启缓存的选项 useCache，然后我们需要指定一个保存缓存文件的地方 cacheDirectory，所以 webpack 配置改为如下:12345678910111213&#123; // 匹配要解析的文件 test: /\\.ts(x?)$/, use: [ &#123; loader: \"awesome-typescript-loader\", options: &#123; useCache: true, cacheDirectory: path.join(__dirname, \"./../\", \".cacahe-loader\") &#125; &#125; ]&#125;, 2. scss 转换构建缓存，需要用到 cache-loader1npm install -D cache-loader 然后在对.scss 文件类型的转换配置中使用它，在这里我们主要是针对转换出来的 css 进行缓存，所以需要写在 css-loader 配置的前面: 123456789101112131415&#123; test: /\\.scss$/, include: [path.join(__dirname, \"./../\", \"src\")], use: [ \"style-loader\", &#123; loader: \"cache-loader\", options: &#123; cacheDirectory: path.join(__dirname, \"./../\", \".cache-loader\") &#125; &#125;, \"css-loader\", \"sass-loader\" ]&#125; 这样就配置好当前的构建缓存了,在进行 npm run dev 的时候会发现根目录多了.cache-loader 文件夹","tags":[{"name":"typescript","slug":"typescript","permalink":"https://shleyz.github.io/tags/typescript/"}]},{"title":"react typescript项目搭建-1基础","date":"2019-07-20T03:19:10.000Z","path":"2019/07/20/react-typescript项目搭建-1基础/","text":"最近公司有了新的项目，所以为开发做准备，并且提供一个普适的模版，自己搭建一个 react+ typescript 项目 起步安装1234567891011121314151617// 全局安装 typescriptnpm install -g typescript// 创建项目文件夹mkdir iot-back &amp;&amp; cd iot-back// 项目初始化，生成package.json和tsconfig.jsonnpm init -y &amp;&amp; tsc --init// 安装webpacknpm install -D webpack webpack-cli webpack-dev-server// 安装react相关和ts包npm install -S react react-dom npm install -D @types/react @types/react-dom// 安装ts-loadernpm install -D awesome-typescript-loader 这时候，起步安装基本上就完成了。 项目配置 项目根目录创建 build 文件夹，在 build 下创建 webpack.config.js 项目根目录创建 src 文件夹，在 src 下创建 index.js 作为项目入口 编写 webpack 配置文件 webpack.config.js，添加 entry 和 output 1234567891011const path = require(\"path\");module.exports = &#123; entry: &#123; app: path.join(__dirname, \"./../\", \"src/index.tsx\") &#125;, output: &#123; path: path.join(__dirname, \"./../\", \"dist\"), filename: \"[name].js\" &#125;&#125;; webpack.config.js 内继续编写 awesome-typescript-loader 的配置，解析.tsx 文件,也就是 module 模块 1234567891011121314module: &#123; rules: [ &#123; // 匹配要解析的文件 test: /\\.ts(x?)$/, use: [ &#123; loader: \"awesome-typescript-loader\", options: &#123;&#125; &#125; ] &#125; ];&#125; webpack.config.js 配置导入文件类型,这样以后引入文件就不需要带扩展名 123resolve: &#123; extensions: [\".ts\", \".tsx\", \".js\", \".jsx\"]&#125;, 在 tsconfig 里面没有指定 JSX 的版本 compilerOptions 中添加”jsx”: “react” src/index.tsx 中编辑入口文件 1234567import * as React from \"react\";import * as ReactDOM from \"react-dom\";const render = () =&gt; &#123; ReactDOM.render(&lt;div&gt;123&lt;/div&gt;, document.querySelector(\"#app\"));&#125;;render(); 添加页面模板 根目录 &gt; build &gt; tpl &gt; index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 将页面模板和打包出来的 js 文件关联起来, 因为考虑到以后打包出来的 js 的文件不会是一个固定的名称，所以这里需要使用一个 webpack 的插件 html-webpack-plugin 1npm install -D html-webpack-plugin 然后在 webpack 的 plugins 配置项下进行一些简单配置 123456const HtmlWebpackPlugin = require(\"html-webpack-plugin\");plugins: [ new HtmlWebpackPlugin(&#123; template: \"build/tpl/index.html\" &#125;)]; 配置完成后就可以启动项目了 package.json 中添加启动命令 1\"dev\": \"webpack-dev-server --config build/webpack.config.js --mode development\" 启动命令： npm run dev","tags":[{"name":"typescript","slug":"typescript","permalink":"https://shleyz.github.io/tags/typescript/"}]},{"title":"rn调试中遇到的问题","date":"2019-06-27T07:30:06.000Z","path":"2019/06/27/rn调试中遇到的问题/","text":"1.Could not connect to development server（Android）解决方法 解决办法： 1adb reverse tcp:8081 tcp:8081 如果提示 adb 找不到什么的，需要在环境变量中添加以下并重新 source ： 打开文件：vi ~/.bash_profile 添加： 1export PATH=$&#123;PATH&#125;:/Users/******/Library/Android/sdk/platform-tools 保存以后：source ~/.bash_profile 执行完以上后重新 react-native run-android 2. android 不用摇晃手机，即可调出 Reload 等选项1adb shell input keyevent 82 3.","tags":[{"name":"react-native","slug":"react-native","permalink":"https://shleyz.github.io/tags/react-native/"}]},{"title":"flutter安装使用遇到的问题","date":"2019-06-18T06:10:34.000Z","path":"2019/06/18/flutter安装使用遇到的问题/","text":"按照https://flutter.dev/docs/get-started/test-drive?tab=vscode依次安装使用，过程中遇到的问题： 1.执行 flutter doctor 出现：12345[!] Android toolchain - develop for Android devices (Android SDK version 29.0.0) ✗ Android license status unknown. Try re-installing or updating your Android SDK Manager. See https://developer.android.com/studio/#downloads or visit https://flutter.dev/setup/#android-setup for detailed instructions. 解决办法： 执行： flutter doctor –android-licenses 可能出现的问题： A newer version of the Android SDK is required. To update, run:/Users/xxxx/Library/Android/sdk/tools/bin/sdkmanager –update 执行：/Users/xxxx/Library/Android/sdk/tools/bin/sdkmanager –update 出现问题： 1234567891011Exception in thread \"main\" java.lang.NoClassDefFoundError: javax/xml/bind/annotation/XmlSchema at com.android.repository.api.SchemaModule$SchemaModuleVersion.&lt;init&gt;(SchemaModule.java:156) at com.android.repository.api.SchemaModule.&lt;init&gt;(SchemaModule.java:75) at com.android.sdklib.repository.AndroidSdkHandler.&lt;clinit&gt;(AndroidSdkHandler.java:81) at com.android.sdklib.tool.sdkmanager.SdkManagerCli.main(SdkManagerCli.java:73) at com.android.sdklib.tool.sdkmanager.SdkManagerCli.main(SdkManagerCli.java:48)Caused by: java.lang.ClassNotFoundException: javax.xml.bind.annotation.XmlSchema at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:582) at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:190) at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:499) ... 5 more 这个问题是因为 java jdk 版本导致的，解决办法：修改 java jdk 为 jdk1.8.0_201.jdk。 12345brew cask uninstall java# 卸載 java9brew tap caskroom/versionsbrew cask install java8# 安裝 java8沒有這裡文件的touch ~/.android/repositories.cfg #，將在下一步中出現錯誤brew cask install android-sdk 记得修改 JAVA_HOMRE 环境变量 然后一次执行： 12/Users/xxxx/Library/Android/sdk/tools/bin/sdkmanager --updateflutter doctor --android-licenses // 提示y/n都选择y 再次执行 1flutter doctor 出现成功提示 1[✓] Android toolchain - develop for Android devices (Android SDK version 29.0.0) 2.执行 flutter doctor 出现：12345✗ Xcode installation is incomplete; a full installation is necessary for iOS development. Download at: https://developer.apple.com/xcode/download/ Or install Xcode via the App Store. Once installed, run: sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer 解决办法： 打开 xcode -&gt; 首选项(preference) -&gt; 位置(locations) 选择 command line tools 的值原来是空的，选择 xcode11.0(安装的版本) 然后执行 flutter doctor 123456789101112131415161718[!] iOS toolchain - develop for iOS devices (Xcode 11.0) ✗ libimobiledevice and ideviceinstaller are not installed. To install with Brew, run: brew update brew install --HEAD usbmuxd brew link usbmuxd brew install --HEAD libimobiledevice brew install ideviceinstaller ✗ ios-deploy not installed. To install: brew install ios-deploy ✗ CocoaPods not installed. CocoaPods is used to retrieve the iOS platform side's plugin code that responds to your plugin usage on the Dart side. Without resolving iOS dependencies with CocoaPods, plugins will not work on iOS. For more info, see https://flutter.dev/platform-plugins To install: brew install cocoapods pod setup 按提示进行安装就行了。 12345678910Doctor summary (to see all details, run flutter doctor -v):[✓] Flutter (Channel stable, v1.5.4-hotfix.2, on Mac OS X 10.14.5 18F132, locale zh-Hans-CN)[✓] Android toolchain - develop for Android devices (Android SDK version 29.0.0)[✓] iOS toolchain - develop for iOS devices (Xcode 11.0)[✓] Android Studio (version 3.4)[✓] Connected device (1 available)• No issues found!","tags":[{"name":"flutter","slug":"flutter","permalink":"https://shleyz.github.io/tags/flutter/"}]},{"title":"非设计师的基本设计原则","date":"2019-05-14T05:16:19.000Z","path":"2019/05/14/非设计师的基本设计原则/","text":"翻译自 Fundamental design principles for non-designers 这篇文章面向没有专业设计师的所有内容创作者，以及设计师总是很忙因此无法提供帮助的团队。 如果您可以按照这些简单的步骤进行操作，我保证您的设计会更好看。 这份名单源于对我的朋友，家人和同事这些非设计师，在日常生活中努力设计事物的多年的观察。 包括个人通讯，简历和投资组合，Facebook或Instagram上的帖子图片，YouTube的视频缩略图等。 所有这些人都向我寻求帮助和建议，使得使事情看起来更好。 相较于对他们提供设计，我坚信“授人以渔”的想法，所以我试图给他们提供有价值的建议，以帮助解决未来类似问题。 随着时间的推移，我意识到我一直在给人们所有相同的提示。 我每次都用不同的措辞，但我的所有建议都可以提炼出这四个原则。 我知道有数千个列表就像这样的列表，但我发现这些列表太过分了。 作为非设计师，你不能真正地遵循25个步骤的“简单”的列表。 这会帮助你创造闪亮美丽的设计吗？ 不会。这会帮助您创建出色，清晰且易于理解的设计，每个人都可以轻松理解和互动吗？ 绝对。 所以，不用多说，我向你们展示： 4个基本设计原则，任何人都可以遵循它以取得好成绩对比确保所有元素之间有足够的对比度。 为什么呢？ 因为那些略有不同但又不够不同的东西，创造了一种神秘的山谷。 他们会使得人眼感到怪异和厌恶，和难以理解。 因此我们不希望这些出现在我们的设计中。 您的设计元素应该完全相同或显著不同。 对比问题主要表现在4种不同的方面： color：浅色使用深色，反之亦然。 示例：切勿在浅蓝色或浅粉红色上使用灰色等组合 - 它们极难阅读/交互。 size：仅将元素放在彼此相邻的大小完全相同或大小不同的情况下。 示例：不要将32pt和36pt文本行放在一起。 另一方面，18pt和36pt将一起工作。 weight: 与尺寸相同，只是将元素放在彼此相邻的weight完全相同或weight相当不同的地方。 示例：不要将相同字体的“bold”和“black”放在一起，因为它们看起来太相似了。 另一方面，“light”和“bold”将能很好地协同工作。 style: 不要将一个斜体类型放在另一个斜体类型旁边，或者在另一个衬线字体旁边放置一个衬线字体。 不要结合不同的东西。 示例：不要将“Times New Roman”和“Georgia”放在一起 - 它们看起来太相似了。 组合具有相当不同样式的字体。 一致性确保类似的元素以类似的方式出现。 为什么？ 首先，通过保持事物的一致性，您可以让人们将注意力集中在设计的重要方面，而不是被一直在变化的事物分散注意力。 其次，一致性增加了信任，使事物看起来实际上是设计的，而不是简单地拼凑在一起。 一旦你选择它们就要坚持下去： 字体 颜色/色调 表格 排列 装饰元素的风格 等等 当您处理彼此相邻的许多不同部分时（例如，YouTube频道的视频缩略图或中型文章的封面），请为所有部分选择一种整体风格并坚持使用。 Occam’s Razor 又名 减少视觉噪音您在设计中使用的元素数量越少越好。 为什么？ 人类的大脑很难在输入过载的情况下处理信息并做出决策。 因此使用尽可能少的装饰元素（字体，颜色，阴影，框架，笔画，图标，图案等）。 将Occam’s Razor的设计版本应用于所有内容： 如果只用2个元素可以实现某些功能，请不要使用3个.如果可以使用10个元素实现某些功能，请不要使用20. 如果你不喜欢古老的英国学术哲学家，而是喜欢你在Netflix上看到的东西，那么：成为你自己设计的Marie Kondo（日本组织顾问和作家）， 无论这是否会激发快乐（或者不是设计的有用部分）。 空间事物的定位方式会发送关于其含义的元级别消息。 为什么这很重要？ 因为了解你如何定位事物以及你在它们周围添加了多少空间有助于降低设计的复杂性，因此，它不仅会令人愉悦，而且更容易与之交互。 在设计中使用空间来传达这三个方面的意义： 接近=相关性 与其他元素相比彼此更接近的事物被认为彼此更多地相互关联而不是与其他元素相关。 这个是最重要的，因为我觉得它经常被忽视（甚至是被专业设计师）。 它可以以多种不同的方式应用，例如： 行之间应该比行内字间距有更多的空间，而不是一行中每个单词之间的空间 - 同样，不同段落之间的空间也比段落内的行之间的空间要大。 元素的设计，应该在彼此之间具有较小的空间，而不是在这些元素和组合物的边缘之间。 标签和支持信息应位于其描述/相关的元素附近。 negative space 留白 结合 Occam’s Razor，尽可能地为您的设计提供留白空间，使它们整齐并使其意义更加明显。 将太多元素放入有限的空间就像试着一次听三首不同的歌。 很难理解所说的内容。 重要性和秩序 这个是非常常见的，但我觉得我还是要在这里提一下。 最重要的事情，放在首位，或让它们占用最多的空间。 使用一系列事物来传达秩序。 等等。 你绝对可以弄明白其余的。 The End恭喜！ 如果您按照所有这些步骤进行制作，那么按照行业标准，它很可能看起来非常好。 对于其他一切，总有一位设计师。 我的名字是Mészáros Anna，我是一名图形/用户界面设计师，成为UX / UI设计师，具有哲学学术背景和对所有设计伦理的兴趣。 我很想与更多志同道合的人联系，所以请随时给我留言，并在媒体或Twitter上关注我。","tags":[{"name":"设计","slug":"设计","permalink":"https://shleyz.github.io/tags/设计/"}]},{"title":"使用getusermedia后关闭网络摄像头","date":"2019-05-08T06:02:02.000Z","path":"2019/05/08/使用getusermedia后关闭网络摄像头/","text":"使用js 的navigator.getUserMedia打开了摄像头，应该怎样关闭呢下面是摄像头的开启和关闭需要注意的是浏览器调用摄像头必须是安全访问的情况下才可以，即localhost或者https访问的页面才可以，否则不能获取到浏览器的getUserMedia方法。 1234567891011121314151617181920212223242526272829303132333435&lt;html&gt; &lt;head&gt; &lt;script&gt; var localstream; if (navigator.mediaDevices.getUserMedia !== null) &#123; var options = &#123; video:true, audio:false &#125;; navigator.webkitGetUserMedia(options, function(stream) &#123; vid.src = window.URL.createObjectURL(stream); localstream = stream; vid.play(); console.log(\"streaming\"); &#125;, function(e) &#123; console.log(\"background error : \" + e.name); &#125;); &#125; function vidOff() &#123; vid.pause(); vid.src = \"\"; localstream.getTracks()[0].stop(); console.log(\"Vid off\"); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;video id=\"vid\" height=\"120\" width=\"160\" muted=\"muted\" autoplay&gt;&lt;/video&gt;&lt;br&gt; &lt;button onclick=\"vidOff()\"&gt;vidOff!&lt;/button&gt;&lt;br&gt; &lt;div id=\"div\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; localstream.stop() 已被弃用，不再有效实际上将 localstream.stop() 更改为 localstream.getTracks()[0].stop(); 就可以用了","tags":[{"name":"调用摄像头","slug":"调用摄像头","permalink":"https://shleyz.github.io/tags/调用摄像头/"}]},{"title":"vscode 备份","date":"2019-04-11T07:14:21.000Z","path":"2019/04/11/vscode-备份/","text":"使用Visual Studio Code需要安装一些常用插件及根据个人的喜好进行一些设置,但如果换电脑,或者重装了系统,那么又要重新安装及设置,所以最好还是备份一下 使用Setting Sync插件将目前配置保存到GitHub上，以后只需要从GitHub上获取，就可以一次性安装插件配置信息 1.首先在VSCode里面搜索Setting Sync插件，安装好后重新加载激活l Upload Key : Shift + Alt + U 快捷键备份(上传) l Download Key : Shift + Alt + D快捷键恢复(下载) 2.打开编辑器按下快捷键 Shift + Alt + U快捷键备份(上传)这一步要有文件打开时才有用 3. 跳转到github, Generate new tooken(要先登录哦)token description: vscode-async备注一下 select scopes: 选择gist—create gists 点击Generate token 生成一串key 将生成的key输入vscode命令框里 回车 弹出控制台提示备份(上传)插件成功 上传完成后会生成一个ID, setting-&gt;用户设置-&gt;&apos;sync.gist&apos;:&quot;一串字符串组成的ID&quot; 4.key和ID都要记下来 下载(恢复)插件需要用到5.下载(恢复)插件Shift + Alt + D 输入ID 即可开始同步配置 将上传(备份)好插件的key和ID输入vscode命令框里 回车 备份一下我自己的 github key: 3036e7cdffd1ff62b80e69be10a9753797a54cda vscode ID: 3b3adac00ea2bb6100d53c932c15fa18","tags":[{"name":"vscode","slug":"vscode","permalink":"https://shleyz.github.io/tags/vscode/"}]},{"title":"ios overflow:scroll 不顺畅的问题","date":"2019-04-02T09:28:35.000Z","path":"2019/04/02/ios-overflow-scroll-不顺畅的问题/","text":"overflow:scroll 在 iOS上滑动会有卡的感觉，不是很顺畅 解决办法： 在overflow：scroll处同时添加1-webkit-overflow-scrolling: touch; 这行代码启用了硬件加速特性，所以滑动很流畅。","tags":[{"name":"ios卡顿","slug":"ios卡顿","permalink":"https://shleyz.github.io/tags/ios卡顿/"}]},{"title":"微信公众号iOS时间显示NAN不兼容问题","date":"2019-03-11T05:29:46.000Z","path":"2019/03/11/微信公众号iOS时间显示NAN不兼容问题/","text":"因为在IOS浏览器下，new Date(“2019-03-10 23:59:59”)会返回invalid data,所以会造成时间显示为1NAN-NAN-NAN NAN:NAN:NAN 只要避免这种情况就行，在代码中可以使用正则替换1new Date(\"2019/03/10 23:59:59\") 来解决这种问题","tags":[]},{"title":"前端处理批量上传图片的解压缩","date":"2019-02-26T10:08:51.000Z","path":"2019/02/26/前端处理批量上传压缩图片/","text":"一般前端对于批量图片压缩包只进行上传，后台进行文件处理但是前端也实现解压并验证之后进行上传，多用在批量添加人员时，人脸验证/图片处理，进而进行人员的创建与提示。这样可以加速上传的过程，也可以实现前端的定制化的验证。 解压缩123456789101112import JsZip from 'jszip';var newZip = new JsZip();// 获取解压缩的文件newZip .loadAsync(file, &#123; base64: true &#125;) .then(function(file) &#123; console.log(file) &#125;) .then(function(content) &#123; console.log(content); &#125;); 遍历对象 处理解压过后的ZipObjectObject.keys(content).forEach(key =&gt; { content[key].async('base64').then(async function(base64) { basicInfo.face = 'data:image/jpeg;base64,' + base64; content[key].face = 'data:image/jpeg;base64,' + base64; let tempArr = content[key].name.split('-'); // 0姓名-1性别-2手机号.jpg if (tempArr.length &lt; 3) { // 命名不规范 uploadUser.push({ face: base64, name: content[key].name, msg: '命名不规范', }); _vm.showUploadUser = true; _vm.$notify.error(`${content[key].name}命名不规范`); return; } else if ( tempArr[0] === '' || tempArr[1] === '' || tempArr[2] === '' ) { uploadUser.push({ face: base64, name: content[key].name, msg: '姓名性别和手机号不能为空', }); _vm.showUploadUser = true; _vm.$notify.error(`${content[key].name}姓名性别和手机号不能为空`); return; } else if (!/^1[345789]\\d{9}$/.test(tempArr[2].split('.')[0])) { uploadUser.push({ face: base64, name: content[key].name, msg: '手机号码有误', }); _vm.showUploadUser = true; _vm.$notify.error(`${content[key].name}手机号码有误`); return; } basicInfo.userName = tempArr[0]; basicInfo.gender = tempArr[1] === '男' ? 1 : 2; basicInfo.phone = tempArr[2].split('.')[0]; _vm.batchLoading = true; await _vm .$post('/api/basics/sysUser', basicInfo) .then(response =&gt; { if (response.code == 200) { uploadUser.push({ face: base64, name: content[key].name, msg: '上传成功', status: 'success', }); _vm.getUserManageData(); _vm.batchLoading = false; } else { uploadUser.push({ face: base64, name: content[key].name, msg: response.msg, }); _vm.batchLoading = false; _vm.$notify.error({ message: response.msg, }); } }) .catch(error =&gt; { uploadUser.push({ face: base64, name: content[key].name, msg: error, }); _vm.batchLoading = false; _vm.$notify.error({ message: this.$error2message(error), }); }); }); _vm.uploadUser = uploadUser; console.log(uploadUser); });","tags":[{"name":"批量上传图片","slug":"批量上传图片","permalink":"https://shleyz.github.io/tags/批量上传图片/"}]},{"title":"动态设置favicon以及禁用favicon","date":"2019-02-26T00:57:38.000Z","path":"2019/02/26/动态设置favicon以及禁用favicon/","text":"最近项目有一个需求就是在企业管理后台一键登录到对应的企业时，需要实现不同的企业显示不同的favicon图标。当然这个企业的信息包括favicon是已经从后台获取到了的。 动态加载企业logo和全名12345678910111213141516171819202122232425262728293031323334353637383940(function() &#123; var link = document.querySelector(\"link[rel*='icon']\") || document.createElement('link'); link.type = 'image/x-icon'; link.rel = 'shortcut icon'; // 从localstorage里面获取客户信息 let customerInfo = JSON.parse(localStorage.getItem('userInfo')); // 客户logo let customerIcon = customerInfo &amp;&amp; customerInfo.platformCustomerModel &amp;&amp; customerInfo.platformCustomerModel.customerIcon ? customerInfo.platformCustomerModel.customerIcon : null; // 客户全名 let customerTitle = customerInfo &amp;&amp; customerInfo.platformCustomerModel &amp;&amp; customerInfo.platformCustomerModel.fullName ? customerInfo.platformCustomerModel.fullName : '城市盾牌企业门户系统'; let path0 = window.location.pathname.split('/')[1]; if (path0.indexOf('login') !== -1) &#123; //如果是登陆页面 link.href = 'static/favicon.ico'; &#125; else &#123; //如果不是登陆页面 link.href = customerIcon ? '/cityshield-pic/' + customerIcon : 'static/favicon.ico'; &#125; document.getElementsByTagName('head')[0].appendChild(link); document.title = customerTitle;&#125;)(); 禁止favicon&lt;link rel=\"icon\" href=\"data:;base64,=\"&gt; // 或者详细一点 &lt;link rel=\"icon\" href=\"data:image/ico;base64,aWNv\"&gt;","tags":[{"name":"favicon","slug":"favicon","permalink":"https://shleyz.github.io/tags/favicon/"}]},{"title":"nodejs模块crypto","date":"2019-01-20T05:25:51.000Z","path":"2019/01/20/nodejs模块crypto/","text":"crypto 提供通用的加密和哈希算法(用 C/C++实现的算法)哈希算法：MD5 和 SHA1用于给任意数据一个“签名” 1234567891011121314151617\"use strict\";var crypto = require(\"crypto\");// md5加密--32 个字符的字符串const hash = crypto.createHash(\"md5\");// sha1加密--40 个字符的字符串// const hash = crypto.createHash(\"sha1\");// sha256加密--64 个字符的字符串// const hash = crypto.createHash(\"sha256\");// sha512加密--128 个字符的字符串// const hash = crypto.createHash(\"sha512\");hash.update(\"hello world\");// hash.update(\"hello nodejs\");console.log(hash.digest(\"hex\")); 随机数“增强”的哈希算法：Hmac比哈希算法多了一个密钥字符串，这个字符串是自己定义的 1234567891011121314151617\"use strict\";var crypto = require(\"crypto\");// md5加密--32 个字符的字符串const hmac = crypto.createHash(\"md5\", \"nodejs\");// sha1加密--40 个字符的字符串// const hmac = crypto.createHash(\"sha1\", \"nodejs\");// sha256加密--64 个字符的字符串// const hmac = crypto.createHash(\"sha256\", \"nodejs\");// sha512加密--128 个字符的字符串// const hmac = crypto.createHash(\"sha512\", \"nodejs\");hmac.update(\"hello world\");// hash.update(\"hello nodejs\");console.log(hmac.digest(\"hex\")); 对称加密算法：AES加解密都用同一个密钥，crypto 模块提供了 AES 支持，但是需要自己封装好函数，便于使用 12345678910111213141516171819202122232425262728293031\"use strict\";var crypto = require(\"crypto\");function aesEncrpt(data, key) &#123; const cipher = crypto.createCipher(\"aes192\", key); var crypted = cipher.update(data, \"utf8\", \"hex\"); crypted += cipher.final(\"hex\"); return crypted;&#125;function aesDecrypt(encrypted, key) &#123; const decipher = crypto.createDecipher(\"aes192\", key); var decrypted = decipher.update(encrypted, \"hex\", \"utf8\"); decrypted += decipher.final(\"utf8\"); return decrypted;&#125;var data = \"hello, this is a secrete message\";var key = \"Password!\";var encryptd = aesEncrpt(data, key);var decryptd = aesDecrypt(encryptd, key);console.log(\"Plain text: \" + data);console.log(\"encryptd text: \" + encryptd);console.log(\"decryptd text: \" + decryptd);// 执行结果：// Plain text: hello, this is a secrete message// encryptd text: 1d19941e8612ca5d3b08c1d47db31ce7669c40e22c345804b3034ed233d91d73dd5221be4d3d37ebbcc8d18416c340cd// decryptd text: hello, this is a secrete message Diffie-Hellman, DH 算法是一种密钥交换协议.它可以让双方在不泄漏密钥的情况下协商出一个密钥来。RSA 非对称加密算法由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密。","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://shleyz.github.io/tags/nodejs/"}]},{"title":"gitlab-jenkins自动构建","date":"2019-01-17T05:49:25.000Z","path":"2019/01/17/jenkins自动构建/","text":"在部门的测试环境中，开发人员一旦向gitlab仓库提交成功代码，gitlab就会自动触发jenkins构建项目。当然在构建后还可以添加项目部署或者自动化测试的脚本。这里只针对测试环境。 jenkins 依赖java,首先安装java sdk 安装jenkins: brew install jenkins 启动 jenkins 开机自启动： ln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents 登录： http://localhost:8080 安装插件 安装Gitlab Hook Plugin插件： Gitlab Hook Plugin Build Authorization Token Root Plugin 创建用户登陆进行构建","tags":[{"name":"jenkins","slug":"jenkins","permalink":"https://shleyz.github.io/tags/jenkins/"}]},{"title":"nodejs基本模块","date":"2019-01-13T01:36:56.000Z","path":"2019/01/13/nodejs基本模块/","text":"nodejs 中少数几个同步 I/O 操作：require 基本模块1.global: 在 Node.js 环境中，唯一的全局对象2.process: 也是 Node.js 提供的一个对象，它代表当前 Node.js 进程。通过 process 对象可以拿到许多有用信息：1234567891011121314&gt; process === global.process;true&gt; process.version;'v8.11.4'&gt; process.platform;'darwin'&gt; process.arch;'x64'&gt; process.cwd(); //返回当前工作目录'/Users/michael'&gt; process.chdir('/private/tmp'); // 切换当前工作目录undefined&gt; process.cwd();'/private/tmp' JavaScript 和 Node.js 是由事件驱动执行的单线程模型，Node.js 不断执行响应事件的 JavaScript 函数，直到没有任何响应事件的函数可以执行时，Node.js 就退出了。 process.nextTick()如果想要在下一次事件响应中执行代码，可以调用 process.nextTick()： 12345process.nextTick(() =&gt; &#123; console.log(\"nextTick callback!\");&#125;);console.log(\"nextTick was set!\"); 输出是： 12nextTick was set!nextTick callback! 这说明传入 process.nextTick()的函数不是立刻执行，而是要等到下一次事件循环。 process 的 exit 事件在程序即将退出时执行某个回调函数 123process.on(\"exit\", code =&gt; &#123; console.log(\"about to exit with code: \" + code);&#125;); 常用内置模块fs 文件系统模块,负责读写文件和所有其它 JavaScript 模块不同的是，fs 模块同时提供了异步和同步的方法。 异步读取文件:123456789101112131415fs.readFile(\"base_module.js\", \"utf-8\", (err, data) =&gt; &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); &#125;&#125;);fs.readFile(\"1.jpeg\", (err, data) =&gt; &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); console.log(data.length + \" bytes\"); &#125;&#125;); 123// Buffer -&gt; Stringvar text = data.toString(\"utf-8\");console.log(text); 123// String -&gt; Buffervar buf = Buffer.from(text, \"utf-8\");console.log(buf); 同步读文件1234const data = fs.readFileSync(\"1.jpeg\");const data1 = fs.readFileSync(\"base_module.js\", \"utf-8\");console.log(data); // 读取图片console.log(data1); // 读取js文件 如果同步读取文件发生错误，需要用 try…catch 来捕获 12345678try &#123; const data = fs.readFileSync(\"1.jpeg\"); const data1 = fs.readFileSync(\"base_module.js\", \"utf-8\"); console.log(data); console.log(data1);&#125; catch (err) &#123; console.log(err);&#125; 写文件 fs.writeFile()12345678910\"use strict\";var fs = require(\"fs\");var data = \"console.log('aaa')\";// 异步写入fs.writeFile(\"writeInFile.js\", data, err =&gt; &#123; console.log(err);&#125;);// 同步写入fs.writeFileSync(\"writeInFileAsync.js\", data); stat 获取文件大小，创建时间等信息12345678910111213141516171819202122\"use strict\";var fs = require(\"fs\");fs.stat(\"base_module.js\", (err, stat) =&gt; &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(\"isFile:\" + stat.isFile()); console.log(\"isDir:\" + stat.isDirectory()); if (stat.isFile) &#123; console.log(\"File size:\" + stat.size); console.log(\"create time:\" + stat.birthtime); console.log(\"modify time:\" + stat.mtime); &#125; &#125;&#125;);// isFile:true// isDir:false// File size:465// create time:Thu Jun 20 2019 09:52:21 GMT+0800 (CST)// modify time:Thu Jun 20 2019 10:13:35 GMT+0800 (CST) stream 支持“流”数据结, 仅在服务端可用的模块流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像 Array 那样随机定位。 在 Node.js 中，流也是一个对象，我们只需要响应流的事件就可以了：data 事件表示流的数据已经可以读取了，end 事件表示这个流已经到末尾了，没有数据可以读取了，error 事件表示出错了。 从文件流读取文本内容：1234567891011121314151617\"use strict\";var fs = require(\"fs\");var rs = fs.createReadStream(\"aaa.text\", \"utf-8\");rs.on(\"data\", chunk =&gt; &#123; console.log(\"DATA:\"); console.log(chunk);&#125;);rs.on(\"end\", chunk =&gt; &#123; console.log(\"END\");&#125;);rs.on(\"error\", err =&gt; &#123; console.log(\"ERROR:\" + err);&#125;); 以流的形式写入文件:123456789101112131415\"use strict\";var fs = require(\"fs\");var ws = fs.createWriteStream(\"in.text\", \"utf-8\");ws.write(\"增加段落1\\n\");ws.write(\"增加段落2\\n\");ws.write(\"增加段落3\\n\");ws.end();var ws1 = fs.createWriteStream(\"in1.text\", \"utf-8\");ws1.write(new Buffer(\"使用Stream写入二进制数据...\\n\"), \"utf-8\");ws1.write(new Buffer(\"END \\n\"), \"utf-8\");ws1.end(); pipe 两个流串联起来一个 Readable 流和一个 Writable 流串起来后，所有的数据自动从 Readable 流进入 Writable 流，这种操作叫 pipe。 在 Node.js 中，Readable 流有一个 pipe()方法，就是用来干这件事的。 1234567\"use strict\";var fs = require(\"fs\");var rs = fs.createReadStream(\"in.text\");var ws = fs.createWriteStream(\"copied.text\");rs.pipe(ws); http要开发 HTTP 服务器程序，直接操作 http 模块提供的 request 和 response 对象。 request 对象封装了 HTTP 请求，我们调用 request 对象的属性和方法就可以拿到所有 HTTP 请求的信息； response 对象封装了 HTTP 响应，我们操作 response 对象的方法，就可以把 HTTP 响应返回给浏览器。 一个简单的 HTTP 服务器：1234567891011\"use strict\";var http = require(\"http\");const server = http.createServer((req, res) =&gt; &#123; console.log(req.method + \":\" + req.url); res.writeHead(200, &#123; \"Content-type\": \"text/html\" &#125;); res.end(\"&lt;h1&gt;hell nodejs&lt;/h1&gt;\");&#125;);server.listen(9090);console.log(\"server is runnig at http://127.0.0.1:9090/\"); 一个简单的 文件 服务器：123456789101112131415161718192021222324252627282930313233343536373839\"use strict\";var fs = require(\"fs\");var url = require(\"url\");var path = require(\"path\");var http = require(\"http\");// 从命令行参数获取root目录，默认是当前目录:var root = path.resolve(process.argv[2] || \".\");console.log(\"Static root dir: \" + root);var server = http.createServer((req, res) =&gt; &#123; // 获得URL的path，类似 '/css/bootstrap.css': var pathname = url.parse(req.url).pathname; // 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css': var filePath = path.join(root, pathname); // 获取文件状态: fs.stat(filePath, (err, stat) =&gt; &#123; if (!err &amp;&amp; stat.isFile()) &#123; // 没有出错并且文件存在: console.log(\"200\" + req.url); // 发送200响应: res.writeHead(200); // 将文件流导向response: fs.createReadStream(filePath).pipe(res); &#125; else &#123; // 出错了或者文件不存在: console.log(\"404\" + req.url); // 发送404响应: res.writeHead(404); res.end(\"404 not found\"); &#125; &#125;);&#125;);server.listen(9090);console.log(\"server is running at http://127.0.0.1:9090/\");","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://shleyz.github.io/tags/nodejs/"}]},{"title":"单元测试","date":"2018-12-14T01:03:05.000Z","path":"2018/12/14/react单元测试/","text":"Jest 被 Facebook 用来测试包括 React 应用在内的所有 JavaScript 代码。Jest 的一个理念是提供一套完整集成的 “零配置” 测试体验。jsdomEnzyme 模拟react浅rendernock.js模拟请求返回的数据sinon 用于做函数的跟踪，集成在jest里面Istanbul 检测覆盖率mocha Mocha的作用是运行测试脚本，首先必须学会写测试脚本。所谓”测试脚本”，就是用来测试源码的脚本。 待测试的源码 // add.js function add(x, y) { return x + y; } module.exports = add; 测试脚本 // add.test.js var add = require(&apos;./add.js&apos;); // 引入待测试函数 var expect = require(&apos;chai&apos;).expect; // 引入断言库 describe(&apos;加法函数的测试&apos;, function() { it(&apos;1 加 1 应该等于 2&apos;, function() { // it是一个最小的测试单元，测试用例 expect(add(1, 1)).to.be.equal(2); // 断言 }); }); 运行测试脚本 mocha --recursive Mocha默认运行test子目录里面的测试脚本。所以，一般都会把测试脚本放在test目录里面，然后执行mocha就不需要参数了。 Mocha默认只执行test子目录下面第一层的测试用例，不会执行更下层的用例。 加上--recursive参数，这时test子目录下面所有的测试用例----不管在哪一层----都会执行。 命令行指定测试脚本时，可以使用通配符，同时指定多个文件。 mocha spec/{my,awesome}.js mocha test/unit/*.js mocha --reporters 可以查看生成的测试报告格式 mocha --reporter tap //默认形式 mocha --reporter spec mocha --reporter markdown 监视测试脚本 mocha --watch --watch参数用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha。","tags":[]},{"title":"react性能优化","date":"2018-12-03T06:33:10.000Z","path":"2018/12/03/react性能优化/","text":"shouldComponentUpdate 组件是否需要被更新shouldComponentUpdate函数是重渲染时render()函数调用前被调用的函数，它接受两个参数：nextProps和nextState，分别表示下一个props和下一个state的值。并且，当函数返回false时候，阻止接下来的render()函数的调用，阻止组件重渲染，而返回true时，组件照常重渲染。 PureComponent纯组件，自动有一个shouldComponentUpdate，如果你只是单纯地想要避免state和props不变下的冗余的重渲染，那么react的pureComponent可以非常方便地实现这一点 避免在render里面使用箭头函数和bind&lt;button onClick={() =&gt; this.handleClick()} style={this.state}&gt; 确定 &lt;/button&gt; handleClick(){ ...... } 浏览器每执行一次 =&gt;，就需要创建一个 新的函数对象，这其实是一个比较耗费性能的操作， 如果你在 render 中使用箭头函数，那么每次调用 render 时都会去创建一个新的函数对象，此时，即使使用 PureComponent 和 shouldComponentUpdate 也起不到优化作用 所以我们应该避免在 render 中使用箭头函数和绑定。否则会打破 shouldComponentUpdate 和 PureComponent 的性能优化。 应该这样： &lt;button onClick={this.handleClick} style={this.state}&gt; 确定 &lt;/button&gt; handleClick = () =&gt; { ...... } 不使用箭头函数，和bind，改为对handleClick函数的引用 尽量避免使用array的索引值作为其key值react的diff算法是以key来唯一标识组件的，当发现update前和update后key值没有变化，react就会认为update前后组件是同一个，如果以数组索引为key值，可能引发删除一个数据时，导致渲染出错。 应该将key设置为一个特殊字段，保证其唯一性","tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://shleyz.github.io/tags/性能优化/"}]},{"title":"用免费SSL证书实现一个HTTPS站点","date":"2018-11-22T08:29:35.000Z","path":"2018/11/22/用免费SSL证书实现一个HTTPS站点/","text":"环境阿里云centOS服务器 1.安装python2-certbot-nginxyum install python2-certbot-nginx 安装python2-certbot-nginx，会报错没有找到安装包可以先执行 epel-release yum install epel-release yum install python2-certbot-nginx 2.certbot工具配置certbot --nginx --nginx-server-root=/etc/nginx/nginx.conf -d 域名 (申请证书的域名) 可能会出现问题： ImportError: No module named &apos;requests.packages.urllib3&apos; 解决方法： pip install –upgrade –force-reinstall ‘requests==2.6.0’ urllib3 然后在进行certbot配置会出现： 1: No redirect - Make no further changes to the webserver configuration. 2: Redirect - Make all requests redirect to secure HTTPS access. Choose this for new sites, or if you&apos;re confident your site works on HTTPS. You can undo this change by editing your web server&apos;s configuration. - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Select the appropriate number [1-2] then [enter] (press &apos;c&apos; to cancel): 1 选择1不重定向选择2则所有该域名下站点都会重定向到https 在不确定你的服务端所有的接口都支持https的时候，选择1 成功后发现想要配置文件中多了： listen 443 ssl; # managed by Certbot ssl_certificate /etc/letsencrypt/live/backstage.qingyun100.cn/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/backstage.qingyun100.cn/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot 首先要确保443端口的开放，再去https访问域名，会看到安全访问标志 firewall-cmd --zone=public --add-port=443/tcp --permanent firewall-cmd --reload 如果是阿里云的服务器要在安全组里面设置开放的端口。 3.自动更新证书由于这个证书的时效只有90天，我们需要设置自动更新的功能，帮我们自动更新证书的时效 先在命令行模拟证书更新： sudo certbot renew --dry-run 模拟更新成功的效果如下： - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ** DRY RUN: simulating &apos;certbot renew&apos; close to cert expiry ** (The test certificates below have not been saved.) Congratulations, all renewals succeeded. The following certs have been renewed: /etc/letsencrypt/live/backstage.qingyun100.cn/fullchain.pem (success) ** DRY RUN: simulating &apos;certbot renew&apos; close to cert expiry ** (The test certificates above have not been saved.) - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 既然模拟成功，我们就使用crontab -e的命令来启用自动任务，命令行： sudo crontab -e 添加配置： 30 2 * * 1 /usr/bin/certbot renew &gt;&gt; /var/log/le-renew.log 上面的执行时间为：每周一半夜2点30分执行renew任务。 你可以在命令行执行 /usr/bin/certbot renew &gt;&gt; /var/log/le-renew.log 看看是否执行正常，如果一切OK，那么我们的配置到此结束！ 现在你就可以使用免费的ssl进行安全访问啦","tags":[{"name":"https","slug":"https","permalink":"https://shleyz.github.io/tags/https/"}]},{"title":"nginx搭建一个可用的静态资源服务器","date":"2018-11-22T02:52:24.000Z","path":"2018/11/22/nginx搭建一个可用的静态资源服务器/","text":"nginx配置文件nginx.conf http { include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 120; #gzip on; #gzip_min_length 1; server { listen port; --- 端口号 server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { alias www_home/; index index.html index.htm; } } 配置好以后，nginx可以访问时 Nginx开启Gzip压缩大幅提高页面加载速度gzip on; // gzip开关开启 gzip_min_length 1; // 小于一字节就不再压缩 gzip_comp_level 2; // 压缩级别 gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/peg image/gif image/png; Nginx打开目录浏览功能–autoindexNginx默认是不允许列出整个目录的。如需此功能，打开nginx.conf文件或你要启用目录浏览虚拟主机的配置文件，在server或location 段里添加上autoindex on;来启用目录流量 location / { alias www_home/; autoindex on; index index.html index.htm; } 限制访问速度–limit_ratelocation / { alias www_home/; autoindex on; set $limit_rate 1k; // 每秒1k，设置这个以后就会访问很慢 index index.html index.htm; }","tags":[{"name":"nginx","slug":"nginx","permalink":"https://shleyz.github.io/tags/nginx/"}]},{"title":"nginx 命令","date":"2018-11-21T07:51:03.000Z","path":"2018/11/21/nginx-命令/","text":"格式和linux命令差不多nginx -s reload (-s是发送信号指令，reload是参数) 帮助： -？或者 -h 使用指定配置文件： -c 指定配置指令：-g 指定运行目录： -p 发送信号： -s nginx -s stop 立即停止服务 nginx -s quit 优雅的停止服务 nginx -s reload 重载配置文件 nginx -s reopen 重载开始记录日志文件 测试配置文件是否有语法错误： -t -T nginx版本信息： -v -V 重载配置文件在/home/**/nginx/sbin目录下： ./nginx -s reload 如果出现错误./nginx可以查看错误，如下： nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use) nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use) nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use) nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use) nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use) 此时说明80端口被占用， 查看是哪个进程被占用，如果是nginx，停止nginx服务，或者kill -9 进程号进行强制杀死进程 netstat -lnp|grep 80命令 再重新reload即可成功 升级nginx版本首先备份/nginx/sbin/nginx二进制文件 [root@zhao sbin]# ls nginx [root@zhao sbin]# mv nginx nginx.bak [root@zhao sbin]# ls nginx.bak 然后把已经编译好的新的二进制文件拷贝进sbin目录 [root@zhao sbin]# cp -r /目录/nginx /home/zh****/nginx/sbin/ [root@zhao sbin]# ls nginx nginx.bak 然后给正在运行的nginx的master进程发送信号，告诉它我要热部署了，要进行版本升级 [root@zhao sbin]# ps -ef |grep nginx root 8732 1 0 10:09 ? 00:00:00 nginx: master process ./nginx nobody 8740 8732 0 10:09 ? 00:00:00 nginx: worker process root 9769 9226 0 10:29 pts/1 00:00:00 grep --color=auto nginx [root@zhao sbin]# kill -USR2 8732 [root@zhao sbin]# ps -ef |grep nginx root 8732 1 0 10:09 ? 00:00:00 nginx: master process ./nginx nobody 8740 8732 0 10:09 ? 00:00:00 nginx: worker process root 9787 8732 0 10:29 ? 00:00:00 nginx: master process ./nginx nobody 9788 9787 0 10:29 ? 00:00:00 nginx: worker process root 9794 9226 0 10:29 pts/1 00:00:00 grep --color=auto nginx [root@zhao sbin]# 发现又新起了一个master进程 发送信号给旧的nginx的master进程，让他优雅的关闭 [root@zhao sbin]# kill -WINCH 8732 [root@zhao sbin]# ps -ef |grep nginx root 8732 1 0 10:09 ? 00:00:00 nginx: master process ./nginx root 9787 8732 0 10:29 ? 00:00:00 nginx: master process ./nginx nobody 9788 9787 0 10:29 ? 00:00:00 nginx: worker process root 9985 9226 0 10:33 pts/1 00:00:00 grep --color=auto nginx [root@zhao sbin]# 发现旧的master进程还存在，但是他的worker进程已经没有了，说明所有的请求已经新升级到新的worker进程中了。此时旧的8732可以不要kill掉，因为在需要版本回退时，或者新版本有问题时，只需要重新给8732发送reload命令，把worker进程拉起来，再把新版本关掉 日志分割[root@zhao logs]# ll 总用量 20 -rw-r--r-- 1 root root 662618 11月 22 10:37 access.log -rw-r--r-- 1 root root 6112 11月 22 10:33 error.log -rw-r--r-- 1 root root 5 11月 22 10:29 nginx.pid -rw-r--r-- 1 root root 5 11月 22 10:09 nginx.pid.oldbin [root@zhao logs]# 当我们发现log文件太大时，需要把以前的日志备份到其他文件，但是nginx还是正常运行，通过reopen命令实现 [root@zhao logs]# mv access.log bake.log [root@zhao logs]# ll 总用量 20 -rw-r--r-- 1 root root 662618 11月 22 10:43 bake.log -rw-r--r-- 1 root root 6343 11月 22 10:43 error.log -rw-r--r-- 1 root root 5 11月 22 10:29 nginx.pid -rw-r--r-- 1 root root 5 11月 22 10:09 nginx.pid.oldbin [root@zhao logs]# ../sbin/nginx -s reopen [root@zhao logs]# ll 总用量 20 -rw-r--r-- 1 nobody root 0 11月 22 10:43 access.log -rw-r--r-- 1 root root 662618 11月 22 10:43 bake.log -rw-r--r-- 1 nobody root 6404 11月 22 10:43 error.log -rw-r--r-- 1 root root 5 11月 22 10:29 nginx.pid -rw-r--r-- 1 root root 5 11月 22 10:09 nginx.pid.oldbin [root@zhao logs]# 一般最好日志文件要每天备份，所以最好写在bash文件里面自动执行每天备份","tags":[{"name":"nginx","slug":"nginx","permalink":"https://shleyz.github.io/tags/nginx/"}]},{"title":"nginx编译","date":"2018-11-19T02:10:50.000Z","path":"2018/11/19/nginx编译/","text":"安装nginx有两种方法，一种是直接通过yarn/apt-get直接来安装，一种就是编译 通过yarn/apt-get直接来安装，有一个问题，就是nginx的二进制文件会把模块直接编译进去，nignx的官方模块并不是每一个都会开启，如果想要添加第三方的nginx模块，必须通过编译的方式进行添加。 推荐编译安装 下载nginx打开nginx.org 找到stable版本(当前stable版本为1.14.1)，复制下载地址，进入linux你想要安装的目录 wget http://nginx.org/download/nginx-1.14.1.tar.gz tar -xzf nginx-1.14.1.tar.gz 进行解压 cd nginx-1.14.1 进入解压后的源码目录,查看目录如下： 总用量 748 drwxr-xr-x 6 mysql mysql 4096 11月 19 10:31 auto -rw-r--r-- 1 mysql mysql 287441 11月 6 21:52 CHANGES -rw-r--r-- 1 mysql mysql 438114 11月 6 21:52 CHANGES.ru drwxr-xr-x 2 mysql mysql 4096 11月 19 10:31 conf -rwxr-xr-x 1 mysql mysql 2502 11月 6 21:52 configure drwxr-xr-x 4 mysql mysql 4096 11月 19 10:31 contrib drwxr-xr-x 2 mysql mysql 4096 11月 19 10:31 html -rw-r--r-- 1 mysql mysql 1397 11月 6 21:52 LICENSE drwxr-xr-x 2 mysql mysql 4096 11月 19 10:31 man -rw-r--r-- 1 mysql mysql 49 11月 6 21:52 README drwxr-xr-x 9 mysql mysql 4096 11月 19 10:31 src nginx源码各个目录1.auto目录： 总用量 204 drwxr-xr-x 2 mysql mysql 4096 11月 19 10:31 cc -rw-r--r-- 1 mysql mysql 141 11月 6 21:52 define -rw-r--r-- 1 mysql mysql 889 11月 6 21:52 endianness -rw-r--r-- 1 mysql mysql 2812 11月 6 21:52 feature -rw-r--r-- 1 mysql mysql 136 11月 6 21:52 have -rw-r--r-- 1 mysql mysql 137 11月 6 21:52 have_headers -rw-r--r-- 1 mysql mysql 411 11月 6 21:52 headers -rw-r--r-- 1 mysql mysql 1020 11月 6 21:52 include -rw-r--r-- 1 mysql mysql 745 11月 6 21:52 init -rw-r--r-- 1 mysql mysql 4836 11月 6 21:52 install drwxr-xr-x 11 mysql mysql 4096 11月 19 10:31 lib -rw-r--r-- 1 mysql mysql 18253 11月 6 21:52 make -rw-r--r-- 1 mysql mysql 3183 11月 6 21:52 module -rw-r--r-- 1 mysql mysql 37857 11月 6 21:52 modules -rw-r--r-- 1 mysql mysql 136 11月 6 21:52 nohave -rw-r--r-- 1 mysql mysql 24767 11月 6 21:52 options drwxr-xr-x 2 mysql mysql 4096 11月 19 10:31 os -rw-r--r-- 1 mysql mysql 8654 11月 6 21:52 sources -rw-r--r-- 1 mysql mysql 120 11月 6 21:52 stubs -rw-r--r-- 1 mysql mysql 2014 11月 6 21:52 summary -rw-r--r-- 1 mysql mysql 394 11月 6 21:52 threads drwxr-xr-x 2 mysql mysql 4096 11月 19 10:31 types -rw-r--r-- 1 mysql mysql 26859 11月 6 21:52 unix 包含四个子目录： cc–用于编译,lib–lib库,os–判断操作系统,types 其他所有的都是为了配合configure脚本执行的时候去判定nginx支持哪些模块，当前操作系统有什么特性供nginx使用， 2.CHANGES文件：nginx每个版本中的特性和bugfix 3.conf是一个配置示例文件 4.configure脚本是用来生成中间文件，执行编译前的必备动作 5.contrib目录,vim编辑器的nginx语法高亮显示 6.html目录, 里面是500错误，重定向到的页面，还有一个是index默认页面 7.man目录，是linux对nginx的帮助文件 8.src目录, 是nginx的源代码 编译configure支持哪些参数呢： ./configure --help | more 结果： --help print this message --prefix=PATH set installation prefix --sbin-path=PATH set nginx binary pathname --modules-path=PATH set modules path --conf-path=PATH set nginx.conf pathname --error-log-path=PATH set error log pathname --pid-path=PATH set nginx.pid pathname --lock-path=PATH set nginx.lock pathname --user=USER set non-privileged user for worker processes --group=GROUP set non-privileged group for worker processes --build=NAME set build name --builddir=DIR set build directory --with-select_module enable select module --without-select_module disable select module --with-poll_module enable poll module --without-poll_module disable poll module --More-- 1.开始编译（使用默认参数prefix）： ./configure --prefix=/home/zhaoxuelin/nginx (指定了nginx安装目录) 如果没有报错，nignx就在指定目录安装成功了 此过程生成的中间文件放在新增加的objs目录下 objs: 总用量 84 -rw-r--r-- 1 root root 17763 11月 19 10:59 autoconf.err -rw-r--r-- 1 root root 39736 11月 19 10:59 Makefile -rw-r--r-- 1 root root 6816 11月 19 10:59 ngx_auto_config.h -rw-r--r-- 1 root root 657 11月 19 10:59 ngx_auto_headers.h -rw-r--r-- 1 root root 5725 11月 19 10:59 ngx_modules.c (决定了哪些模块被编译进nginx) drwxr-xr-x 9 root root 4096 11月 19 10:59 src 2.接下来执行make编译 make 编译完成以后，就会生成大量中间文件和运行nginx的二进制文件。可以在objs目录中看到。 3.执行make install首次安装可以执行这个命令 make install 以上就是编译nginx的步骤","tags":[{"name":"nginx","slug":"nginx","permalink":"https://shleyz.github.io/tags/nginx/"}]},{"title":"antd onChange事件中setFieldsValue无效","date":"2018-11-15T08:35:43.000Z","path":"2018/11/15/antd-onChange事件中setFieldsValue无效/","text":"antd Form 表单中onChange事件中setFieldsValue 无效 参考 http://ju.outofmemory.cn/entry/348216 出现的场景： 想要在Input输入框中，禁止输入空格等特殊字符 123456789101112131415161718192021&#123; key: 'name', label: '姓名', labelCol: &#123; span: 7 &#125;, wrapperCol: &#123; span: 13 &#125;, style: &#123; display: 'inline-block', marginTop: '18px', paddingLeft: '20px' &#125;, node: ( &lt;Input style=&#123;&#123; width: '110px' &#125;&#125; placeholder=\"请输入姓名\" onChange=&#123;this.onNameSelect&#125; /&gt; ), options: &#123; initialValue: this.state.name &#125;&#125; 想要在onChange方法中正则替换非法字符为空可是最后发现无效 参照上面的链接，里面有onChange的源码解说，可以用options.normalize方法，处理 官方文档说明： 转换默认的 value 给控件， 一个例子： https://codepen.io/afc163/pen/JJVXzG?editors=001 综上实现方法： 12345678910111213141516171819202122&#123; key: 'name', label: '姓名', labelCol: &#123; span: 7 &#125;, wrapperCol: &#123; span: 13 &#125;, style: &#123; display: 'inline-block', marginTop: '18px', paddingLeft: '20px' &#125;, node: ( &lt;Input style=&#123;&#123; width: '110px' &#125;&#125; placeholder=\"请输入姓名\" onChange=&#123;this.onNameSelect&#125; /&gt; ), options: &#123; initialValue: this.state.name, normalize: this.onNameSelect1 &#125;&#125; 禁止输入空格/表情/特殊字符 123456789onNameSelect1 = (value: any, preValue: any) =&gt; &#123; let res = value.replace(/(^\\s+)|(\\s+$)/g, ''); // 去掉空格 res = res.replace(/[&amp;\\|\\\\\\*^%$#@\\-]/g, ''); // 去掉特殊字符 res = res.replace( /[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF][\\u200D|\\uFE0F]|[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF]|[0-9|*|#]\\uFE0F\\u20E3|[0-9|#]\\u20E3|[\\u203C-\\u3299]\\uFE0F\\u200D|[\\u203C-\\u3299]\\uFE0F|[\\u2122-\\u2B55]|\\u303D|[\\A9|\\AE]\\u3030|\\uA9|\\uAE|\\u3030/gi, '' ); //去除表情 return res;&#125;;","tags":[{"name":"antd","slug":"antd","permalink":"https://shleyz.github.io/tags/antd/"}]},{"title":"img显示base64图片","date":"2018-11-15T02:42:42.000Z","path":"2018/11/15/img显示base64图片/","text":"&lt;img src=`data:image/jpg;base64,${bese64码}` alt=''&gt;","tags":[{"name":"base64","slug":"base64","permalink":"https://shleyz.github.io/tags/base64/"}]},{"title":"react","date":"2018-09-10T00:54:48.000Z","path":"2018/09/10/react/","text":"以组件的方式考虑ui的构建单一职责原则每个组件只做一件事，如果组件变得复杂，拆分成小组件。复杂度拆分，提高性能（局部刷新state,不会影响其他组件）。 数据状态管理： DRY原则 能计算得到的状态，不要进行存储，在用的时候计算 组件尽量无状态，所有数据从props获取。纯组件，有更好的性能，更容易被重用。 组件的生命周期Render阶段，纯净没有副作用Pre-commit 阶段，可以读取domCommit 阶段，使用Dom， 生命周期的三个类型 创建时 constructor更新时 render卸载时 willUnmount 渲染机制渲染过程在页面一开始打开的时候，React会调用render函数构建一棵Dom树，在state/props发生改变的时候，render函数会被再次调用渲染出另外一棵树，接着，React会用对两棵树进行对比，找到需要更新的地方批量改动。 Diff 算法（将算法复杂度从O(n^3)降低到O(n)）Diff算法只会对同层的节点进行比较，也就是说如果父节点不同，React将不会在去对比子节点。因为不同的组件DOM结构会不相同，所以就没有必要在去对比子节点了。这也提高了对比的效率。 对于不同的节点类型，react会基于第一条假设，直接删去旧的节点，新建一个新的节点。 当对比相同的节点类型比较简单，react会对比它们的属性，只改变需要改变的属性 比如： &lt;div className=&quot;before&quot; title=&quot;stuff&quot; /&gt; &lt;div className=&quot;after&quot; title=&quot;stuff&quot; /&gt; 这两个div中，react会只更新className的值 &lt;div style={{color: 'red', fontWeight: 'bold'}} /&gt; &lt;div style={{color: 'green', fontWeight: 'bold'}} /&gt; 这两个div中，react只会去更新color的值 列表比较 // 列表一到列表二 从列表一到列表二，只是在中间插入了一个C，但是如果没有key的时候，react会把B删去，新建一个C放在B的位置，然后重新建一个节点B放在尾部。 当节点很多的时候，这样做是非常低效的，所以我们需要给每个节点配一个key，让react可以识别出来哪些节点是一样的，不需要重新创建。 配上key之后，列表二的生命周期就如我所愿，只在指定的位置创建C节点插入。这里要注意的一点是，key值必须是稳定（所以我们不能用Math.random()去创建key），可预测，并且唯一的。 ###","tags":[]},{"title":"mac Jemeter","date":"2018-09-06T23:35:24.000Z","path":"2018/09/07/mac-Jemeter/","text":"第一步下载Jemeter 下载Binaries里面的.tgz 第二步解压apache-jmeter-4.0.tgz, 使用命令： tar -zxvf apache-jmeter-4.0.tgz 第三步打开刚解压到的文件apache-jmeter-3.3，切换到/bin目录下，启动Jmeter: sh jmeter 前提是配置好java环境MAC安装JDK及环境变量配置 mac 配置 jmeter 环境变量编辑用户目录下.bash_profile文件 vim .bash_profile 添加 export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home export JMETER_HOME=/Users/******/apache-jmeter-3.2 export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JMETER_HOME/lib/ext/ApacheJMeter_core.jar:$JMETER_HOME/lib/jorphan.jar:$JMETER_HOME/lib/logkit-2.0.jar export PATH=$JAVA_HOME/bin:$JMETER_HOME/bin:$PATH 上面的 /**/ 填自己的用户名,JAVA_HOME里面的版本号填自己的。 保存退出后 source ~/.bash_profile","tags":[]},{"title":"随机颜色生成","date":"2018-09-05T22:14:17.000Z","path":"2018/09/06/随机颜色生成/","text":"hsla颜色H: Hue–色调 0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360S: Sturation–饱和度 取值为：0.0% - 100.0%L: Lightness–亮度 取值为：0.0% - 100.0%A: Alpha透明度。取值0~1之间 随机颜色： 123let firstValue = Math.random() * 360;let color = [];color[0] = 'hsla(’ + firstValue + ‘, 75%, 40%, 1)' 如果需要一系列的很多颜色值，那么后续的颜色值的计算，只需要在前一个颜色的色相上偏转一个角度，就得到新的颜色值了。 把偏转角度设置成不是360度因数的值，可以防止后续颜色的重复循环，这样就可以得到无穷的适合的随机颜色序列。而且，偏转角度可以让前后的色彩保持足够的差异，让相邻颜色之间的视觉效果格外分明。 后续的第i个色相，可以通过旋转某个角度取得，比如 color[i] = ‘hsla(’ + ( firstValue + i * 222.5 ) + ‘, 75%, 50%, 0.3)’ 用随机函数生成第一个色相，然后每次偏转222.5度（这个角度的叠加很难导致达到360的倍数，而且前后两个颜色的差异也足够大） 不支持IE6-8 闭包递归1234567let getRandomColor = function()&#123; return '#' + (function(color)&#123; return (color += '0123456789abcdef'[Math.floor(Math.random()*16)]) &amp;&amp; (color.length == 6) ? color : arguments.callee(color); &#125;)('');&#125; 方法三123let getRandomColor = function()&#123; return '#'+Math.floor(Math.random()*16777215).toString(16);&#125; hex颜色值是从#000000到#ffffff，后面那六位数是16进制数，相当于”0x000000”到”0xffffff”。 这实现的思路是将hex的最大值ffffff先转换为10进制，进行random后再转换回16进制 方法四123let getRandomColor = function()&#123; return '#'+(Math.random()*0xffffff&lt;&lt;0).toString(16);&#125; 实现方法三的改进，利用左移运算符把0xffffff转化为整型。这样就不用记16777215了。由于左移运算符的优先级比不上乘号，因此随机后再左移 方法五12345let getRandomColor = function()&#123; return '#'+(function(h)&#123; return new Array(7-h.length).join(\"0\")+h &#125;)((Math.random()*0x1000000&lt;&lt;0).toString(16))&#125; 修正上面版本的bug（无法生成纯白色与hex位数不足问题）。0x1000000相当0xffffff+1，确保会抽选到0xffffff。在闭包里我们处理hex值不足6位的问题，直接在未位补零。 方法六123let getRandomColor = function()&#123; return '#'+('00000'+(Math.random()*0x1000000&lt;&lt;0).toString(16)).slice(-6);&#125; 这次在前面补零，连递归检测也省了","tags":[{"name":"随机颜色","slug":"随机颜色","permalink":"https://shleyz.github.io/tags/随机颜色/"}]},{"title":"svg animation","date":"2018-09-03T22:11:12.000Z","path":"2018/09/04/svg-animation/","text":"基础知识：stroke用于绘制形状的轮廓颜色的表示属性 作为表示属性，它可以应用于任何元素，但它仅对以下十一个元素产生影响： &lt;altGlyph&gt;, &lt;circle&gt;, &lt;ellipse&gt;, &lt;path&gt;, &lt;polygon&gt;, &lt;polyline&gt;, &lt;rect&gt;, &lt;text&gt;, &lt;textPath&gt;, &lt;tref&gt;, &lt;tspan&gt; strokeWidth定义要应用于形状的笔划宽度的表示属性，默认1px 作为表示属性，它可以应用于任何元素，但它仅对以下十一个元素产生影响： &lt;altGlyph&gt;, &lt;circle&gt;, &lt;ellipse&gt;, &lt;path&gt;, &lt;polygon&gt;, &lt;polyline&gt;, &lt;rect&gt;, &lt;text&gt;, &lt;textPath&gt;, &lt;tref&gt;, &lt;tspan&gt; fillfill属性有两个不同的含义：对于形状和文本，它是一个表示属性，它允许定义用于绘制元素的颜色；对于动画，它允许定义动画的最终状态。 作为表示属性，它可以应用于任何元素，但它仅对以下十一个元素产生影响： &lt;altGlyph&gt;, &lt;circle&gt;, &lt;ellipse&gt;, &lt;path&gt;, &lt;polygon&gt;, &lt;polyline&gt;, &lt;rect&gt;, &lt;text&gt;, &lt;textPath&gt;, &lt;tref&gt;, &lt;tspan&gt; 例如： 123&lt;svg viewBox=\"0 0 400 100\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;circle cx=\"150\" cy=\"50\" r=\"40\" fill=\"url(#myGradient)\" /&gt;&lt;/svg&gt; 对于动画，五个元素使用此属性: &lt;animate&gt;, &lt;animateColor&gt;, &lt;animateMotion&gt;, &lt;animateTransform&gt;, &lt;set&gt; 例如： 123456789&lt;svg viewBox=\"0 0 400 100\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;circle cx=\"250\" cy=\"50\" r=\"20\"&gt; &lt;animate attributeType=\"XML\" attributeName=\"r\" from=\"0\" to=\"40\" dur=\"5s\" fill=\"freeze\" /&gt; &lt;/circle&gt; &lt;/svg&gt; 作为表示属性，fill可以用作CSS属性。 fill-opacity定义应用于形状的不透明度的表示属性。 例如： 1234567&lt;svg viewBox=\"0 0 400 100\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;circle cx=\"250\" cy=\"50\" r=\"40\" fill-opacity=\"50%\" /&gt;&lt;/svg&gt; stroke-dasharraystroke-dasharray属性用来设置实线和虚线的宽度.如果提供奇数个，则会自动复制该值成偶数 比如： stroke-dasharray: 50 20; 50和20分别对应了实线和虚线的长度 stroke-dashoffsetstroke-dashoffset：定义虚线描边的偏移量（在路径开始的前面，看不到） 动画svg 描边动画能使用css3 animation 实现，无需任何JavaScript 123456789&lt;svg&gt; &lt;path d=\"......\" stroke=\"#000\" stroke-width=2 fill=\"#fff\" fill-opacity=0 /&gt;&lt;/svg&gt; CSS: 1234567891011path &#123; stroke-dasharray: 1000; stroke-dashoffset: 1000; animation: dash 5s linear infinite;&#125;@keyframes dash &#123; to &#123; stroke-dashoffset: 0; &#125;&#125; 上面的1000应该是大于等于路径的长度 路径长度的计算var path = document.querySelector('path'); var length = path.getTotalLength();","tags":[{"name":"svg","slug":"svg","permalink":"https://shleyz.github.io/tags/svg/"}]},{"title":"NATAPP内网穿透与 webpack 一同使用出现invalid host header 问题","date":"2018-08-05T12:05:19.000Z","path":"2018/08/05/NATAPP内网穿透/","text":"disableHostCheck: true 在webpack配置文件中加入以上。","tags":[]},{"title":"node 版本升级","date":"2018-07-29T06:02:01.000Z","path":"2018/07/29/node版本升级/","text":"首先：查看当前node版本：node –v 安装n模块：npm install -g n 升级到指定版本/最新版本（该步骤可能需要花费一些时间）升级之前，可以执行n ls （查看可升级的版本）如： n 6.9.1 或者你也可以告诉管理器，安装最新的稳定版本 n stable 安装完成后，查看Node的版本，检查升级是否成功node -v","tags":[]},{"title":"从输入网址到页面呈现都发生了什么？","date":"2018-05-09T02:23:04.000Z","path":"2018/05/09/从输入网址到页面呈现都发生了什么？/","text":"涉及到网络通信和页面渲染 网络通信如果输入的地址是域名：www.baidu.com 域名解析（DNS解析）： 1.先检查本地hosts文件有没有域名对应的ip映射，如果有直接调用这个映射到的ip，域名解析完成 2.如果hosts文件没有相应的映射，查找本地DNS解析缓存，如果有直接返回，解析完成 3.如果hosts文件和本地DNS解析缓存都没有相应的网址映射，则查找本地DNS服务器（TCP/IP参数中设置的首选DNS服务器），如果域名包含在本地DNS服务器配置中，则返回相应的IP给客户机，完成解析 4.如果本地DNS服务器配置中没有相应的映射，则查找本地DNS服务器缓存是否存在网址映射关系，有则返回IP，完成域名解析 5.如果本地DNS服务器和缓存都没有相应的映射关系，如果本地DNS服务器未用转发模式 本地DNS会把请求发给13台根DNS, 根DNS收到请求，会查询.com是谁来授权管理的，返回负责这个顶级域名服务器的Ip给本地DNS服务器 本地DNS服务器收到这个ip以后，发送请求给这台服务器 这台负责.com域的服务器如果无法解析，则找.com域的下一级也就是授权管理baidu.com的DNS服务器的ip给本地DNS服务器 本地DNS服务器收到这个ip以后，发送请求给这台服务器，重复这个操作 6.如果用的时转发模式， 本地DNS会把请求发给上一级DNS服务器,交给上一级解析 如果上一级不能解析，交给上上级解析，没有上上级则查找根DNS服务器，也就是5的操作 7.不管是不是转发模式，最终都会把域名解析的地址返回给本地DNS服务器，本地DNS服务器再返回给客户端 应用层客户端发送http请求http请求包含报文头和请求主体 报文头包含了重要的信息：请求方式，请求地址，遵循的协议，是否需要缓存，客户端是否发送cookie等 传输层 确保传输报文可靠性的tcp协议tcp协议通过三次握手保证传输的可靠 发送端发送一个包含SYN(synchronize)标志的数据包给接收端，在一定延迟时间内等待回复 接收端接收到以后，返回一个SYC/ACK标志的数据包表示确认 发送方收到以后，发送一个带有ACK标志的数据包给接收端，表示握手成功 如果发送方在延迟时间内不能收到回复，默认接收方没有收到请求，会再次发送，直到收到请求 如果三次握手不能顺利进行，则不能建立连接 tcp把大块数据分割成报文段为单位的数据包并编号进行传输，方便服务器还原数据信息 网络层 负责传输的IP协议IP协议负责把tcp协议分割的数据包传给接收方，需要保证传输正确，还需要找到接收方的mac地址，也就是物理地址。 一个网络设备的mac地址和IP是一一对应的，IP会变但是mac不变 ARP协议将ip地址解析成对应的mac地址 当发送方和接收方不在同一个局域网，需要多次中转才能到达最终目标 数据链路层找到mac地址以后，把数据发送到数据链路层传输，到这里，客户端发送请求阶段结束 服务器接收报文 在数据链路层接收到请求，删除请求的首部信息，传输给网络层 网络层将收到的数据传给传输层 传输层将数据段按序号还原报文，传送给应用层 数据传输到应用层才是真正的接收到从客户端发送过来的http请求 应用层 服务器发送http响应报文服务器接收到客户端发送的请求后，查找请求的资源，并返回响应报文，响应报文最重要的信息： 状态码 200或2XX，请求成功 301， 永久重定向，同时也会反回一个重定向地址，请求资源已经永久转移 304， 请求缓存 404， not found,没有找到资源 405, 请求方式错误 页面渲染解析html以构建dom树解析一个文档即将其转换为具有一定意义的结构(编码可以理解和使用的东西)。解析的结果通常是表达文档结构的节点树，称为解析树或语法树。解析是以文档所遵循的语法规则（编写文档所用的语言或格式）为基础的。所有可以解析的格式都必须对应确定的语法（由词汇和语法规则构成）。这称为与上下文无关的语法。解析的过程可以分成两个子过程：词法分析和语法分析。 词法分析是将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的单词。语法分析是应用语言的语法规则的过程。解析器通常将解析工作分给以下两个组件来处理： 词法分析器（有时也称为标记生成器），负责将输入内容分解成一个个有效标记；而解析器负责根据语言的语法规则分析文档的结构，从而构建解析树。由于不能使用常规的解析技术，浏览器就创建了自定义的解析器来解析 HTML。此解析算法由两个阶段组成：标记化和树构建。具体的解析过程可参考中的标记化算法和构建树算法 解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。解析树的根节点是“Document”对象。 当解析到link标签时会请求相应的CSS文件，并将其CSS规则解析为StyleSheet对象，CSS文件中的其他外链资源如背景图片等只有等到其规则与DOM树某节点相匹配时才会加载当解析遇到img标签时会根据路径向服务器相应的资源文件夹中请求图片资源，但并不会等待图片资源下载完再去解析接下来的html，而是并发执行即图片资源仍在下载，html解析也在进行。如果没有定义图片的height和width属性，那么浏览器为了能够显示每一个加载的图像，它需要先下载图像，然后解析出图像的高度和宽度，并在显示窗口留出相应的屏幕空间，这样就会导致浏览器不断地重新计算/调整页面的布局，这可能会延迟文档的显示，并导致页面重绘。当解析遇到script标签时，将启动 JavaScript 引擎，这时将阻塞 DOM 树的构建。因为 JavaScript 执行过程中， JavaScript 很可能会对 DOM 树进行读写操作。直到 JavaScript 执行完毕（此时执行的是全局对象初始创建和全局上下文中代码的执行），DOM树才会恢复构建。 构建render树为了更好地用户体验效果，浏览器会在构建DOM树的同时，也在构建render树。呈现树的每一个节点即为与其相对应的DOM节点的CSS框，框的类型与DOM节点的display属性有关，block元素生成block框，inline元素生成inline框。每一个呈现树节点都有与之相对应的DOM节点，但DOM节点不一定有与之相对应的呈现树节点，比如display属性为none的DOM节点，而且呈现树节点在呈现树中的位置与他们在DOM树中的位置不一定相同，比如float与绝对定位元素。在构建render树的时候需要为DOM树匹配CSS规则，在这个阶段因为匹配规则是从右往左匹配的，所以css的编写规则很重要。不好的CSS选择器写法会影响到页面渲染的效率，具体是如何编写高效的CSS规则的可参考这篇文章 布局render树在创建render树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。布局是一个递归的过程，它从根元素开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的呈现器计算几何信息。布局通常具有以下模式： 父呈现器确定自己的宽度。 父呈现器依次处理子呈现器，并且：放置子呈现器（设置 x,y 坐标）。如果有必要，调用子呈现器的布局，这会计算子呈现器的高度。 父呈现器根据子呈现器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父呈现器的父呈现器使用。 将其 dirty 位设置为 false 绘制render树在绘制阶段，系统会遍历render树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。和布局一样，绘制也分为全局（绘制整个呈现树）和增量两种。在增量绘制中，部分呈现器发生了更改，但是不会影响整个树。更改后的呈现器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块“dirty 区域”，并生成“paint”事件。绘制顺序: 背景颜色 背景图片 边框 子代 轮廓 页面变化造成的影响在发生变化时，浏览器会尽可能做出最小的响应。 元素的颜色改变后，只会对该元素进行重绘。 元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。 添加 DOM 节点后，会对该节点进行布局和重绘。 一些重大变化（例如增大“html”元素的字体）会导致缓存无效，使得整个呈现树都会进行重新布局和绘制。 页面渲染阶段的优化： 将css文件放在头部，便于构建dom树 将javascript文件放在尾部，以免阻塞构建dom树 javascript的onload事件里，不要写太多影响首屏渲染的、操作dom树的代码 精简js和css代码，是资源更快的下载 重要的图片或想让用户先看到的图片使用img标签，次要的可以使用background引入","tags":[{"name":"http","slug":"http","permalink":"https://shleyz.github.io/tags/http/"}]},{"title":"js闭包的特性和其优缺点","date":"2018-05-09T01:19:34.000Z","path":"2018/05/09/js闭包的特性和其优缺点/","text":"javascript有 全局变量和局部变量 js的特点就是函数内部可以读取全局和局部变量，但是函数外部不能读取内部的局部变量 这样就有闭包可以实现读取函数内部变量：在函数内部再定义一个函数 123456function f1() &#123; let n = 99; function f2()&#123; console.log(n) &#125;&#125; 所以可以理解为闭包是一个外部访问内部变量的一个通道。 闭包的用途： 读取函数内部的变量 让这些变量的值保存在内存中，不会被垃圾回收机制自动清除 优点： 避免全局变量污染 使变量长期保存在内存中 缺点 增加内存使用量 造成内存泄漏 （这些变量不会被垃圾回收机制自动清除），解决方法：在退出或者不用之后把局部变量手动清除 垃圾回收机制了解一下js每次创建变量（字符串，对象，数组等）时，都会自动分配内存来存储这些变量，只要动态分配了内存，最终都要释放以便内存可以再次使用，否则js解释器就会消耗完系统的所有内存，造成系统崩溃。这就是为什么需要垃圾回收。 js 不像c/c++，有自己的一套垃圾回收机制，js只能进行检测，看这些变量什么时候不用了，不需要了就进行释放。 123var a = \"before\";var b = \"override a\";var a = b; //重写a 上面的代码运行之后，”before”这个字符串失去了引用，系统检测到了之后，就会释放该字符串的存储空间以便这些空间可以被再利用。 原理：标记清除 当变量进入执行环境，标记为“进入环境”，当变量离开环境，标记为“离开环境”垃圾收集器运行的时候， 会把所有的变量加上标记， 然后去掉所有在环境中的变量的标记， 如果有变量不用了，访问不到了，再给这些变量加上标记，视为将要删除的变量， 垃圾回收器完成清除，销毁带有标记的变量，释放内存 原理：引用计数 跟踪记录每个变量被引用的次数 当声明了一个变量并给他赋值，则这个值的引用次数为 1 反之，如果这个值对应的变量又取得另外一个值， 则原来这个值引用次数 -1 当引用次数为0时，说明访问不到这个值了，则销毁并回收 引发内存泄漏的操作 意外的全局变量引起的内存泄漏 原因: 全局变量，不会被回收 解决方法： 使用严格模式，严格模式不允许意外创建全局变量（非严格模式下，错误的创建变量会导致创建为全局变量） 闭包引起内存泄漏 原因： 可以维持函数内局部变量，使其得不到释放 没有清理的dom元素引用 原因： 虽然别的地方删除了，但是对象中还存在对dom的引用 解决方法： 手动删除引用","tags":[{"name":"闭包","slug":"闭包","permalink":"https://shleyz.github.io/tags/闭包/"}]},{"title":"布局方式static/relative/absolute/fixed","date":"2018-05-09T01:01:35.000Z","path":"2018/05/09/布局方式static-relative-absolute-fixed/","text":"css中position的布局方式有：static | relative | absolute | fixed static: 默认值，制定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时top | bottom | left | right | z-index 属性都不生效 relative: 根据自身的位置来进行定位， 不脱离文档流 absolute: 脱离文档流，根据上级中最近的非static元素来定位 fixed: 脱离文档流，相对于屏幕视口进行定位","tags":[]},{"title":"js防抖和截流","date":"2018-05-08T09:56:08.000Z","path":"2018/05/08/js防抖和截流/","text":"在页面操作中，很高频率的对dom的操作会加重浏览器的负担，也会导致一些bug，例如滚动条滚动触发的操作，很快的点击一个按钮，输入字符串搜索等。因此采用防抖和截流进行降低调用频率，但又不影响使用。 事件防抖：拿输入字符串搜索来说，等待用户停止输入，例如过了500ms用户还没有输入，则搜索以输入的字符串，如果用户在等待500ms的时间内又输入了，则在输入后再等待500ms，如果没有继续输入则搜索，如果有就再等待500ms有没有输入。。。。。。 实现防抖的思路： 每次触发事件时都取消之前的延时，出发后发出新的延时 function debounce(fn, delay) { let handle; return function(e){ clearTimeout(handle); handle = setTimeout(() =&gt; { fn(e) }, delay) } } function sayHi(e){ console.log(e.target.innerWidth, e.target.innerHeight) } window.addEventListener('resize', debounce(sayHi, 500)) 事件节流事件节流就是 每过500ms进行一次搜索 实现节流的思路： 每次触发事件时都判断当前是否有等待执行的延时函数 function throttle(fn, delay) { let runStatus = false; return function(e){ if(runStatus) { return false } runStatus = true; setTimeout(() =&gt; { fn(e); runStatus = false }, delay) } } function sayHi(e){ console.log(e.target.innerWidth, e.target.innerHeight) } window.addEventListener('resize', debounce(sayHi, 500))","tags":[{"name":"防抖截流","slug":"防抖截流","permalink":"https://shleyz.github.io/tags/防抖截流/"}]},{"title":"js算法-排序","date":"2018-05-02T09:05:14.000Z","path":"2018/05/02/js算法-排序/","text":"我们平时对计算机中存储的数据执行的两种最常见的操作就是排序和查找，对于计算机的排序和查找的研究，自计算机诞生以来就没有停止过。如今又是大数据，云计算的时代，对数据的排序和查找的速度、效率要求更高，因此要对排序和查找的算法进行专门的数据结构设计，（例如我们上一篇聊到的二叉查找树就是其中一种），以便让我们对数据的操作更加简洁高效。 介绍一下排序算法的术语： 稳定：如果排序前a在b前面，并且a=b，排序后a仍然在b前面 不稳定：如果排序前a在b前面，并且a=b，排序后a可能在b后面 内排序：所有排序操作都在内存中进行 外排序：由于数据太大，因此数据放在磁盘中，排序操作通过磁盘和内存的传输才能进行 时间复杂度： 算法执行所需要的时间 空间复杂度： 算法执行所需要的内存大小 假设下面的排序都是按从小到大排列 冒泡排序对比相邻两个元素，如果第一个比第二个大就交换。是排序最慢的算法之一 实现如下： 1234567891011121314151617181920function bubbleSort(data)&#123; for (var i=0; i&lt;data.length; i++)&#123; for(var j=i; j&lt;data.length; j++)&#123; if(data[i] &gt; data[j])&#123; let temp; temp = data[i]; data[i] = data[j]; data[j] = temp; &#125; &#125; &#125; return data&#125;var arr = [72 , 1 , 68 , 95 , 75 , 54 , 58 , 10 , 35 , 6 , 28 , 45 , 69 , 13 , 88 , 99 , 24 , 28 , 30 , 31 , 78 , 2 , 77 , 82 , 72]var bubbleSortArr = bubbleSort(arr)console.log(arr)console.log(bubbleSortArr)// [72, 1, 68, 95, 75, 54, 58, 10, 35, 6, 28, 45, 69, 13, 88, 99, 24, 28, 30, 31, 78]// [1, 6, 10, 13, 24, 28, 28, 30, 31, 35, 45, 54, 58, 68, 69, 72, 75, 78, 88, 95, 99] 选择排序从数组的开头开始遍历，记录里面最小的数，遍历完，把最小的数放在第一位，然后，从第二位开始遍历，记录里面最小的数，遍历完，把最小的数放在第二位，。。。。依次遍历直到倒数第二位遍历完，就完成了选择排序 实现如下： 1234567891011121314151617181920212223function selectionSort(data) &#123; for(var i=0; i&lt;data.length; i++) &#123; let min = data[i] let minIndex = i; for(var j=i; j&lt;data.length; j++) &#123; if(data[j] &lt; data[i]) &#123; min = data[j] minIndex = j &#125; &#125; let temp = data[i]; data[i] = min; data[minIndex] = temp; &#125;&#125;var arr = [72 , 1 , 68 , 95 , 75 , 54 , 58 , 10 , 35 , 6 , 28 , 45 , 69 , 13 , 88 , 99 , 24 , 28 , 30 , 31 , 78 , 2 , 77 , 82 , 72]console.log(arr)var selectionSort = selectionSort(arr)console.log(selectionSort)// [72, 1, 68, 95, 75, 54, 58, 10, 35, 6, 28, 45, 69, 13, 88, 99, 24, 28, 30, 31, 78]// [1, 6, 10, 13, 24, 28, 28, 30, 31, 35, 45, 54, 58, 68, 69, 72, 75, 78, 88, 95, 99] 插入排序从第一位开始，默认它为已排序序列，取下一个元素，在已排序序列中，从后向前比对已排序数据，如果已排序数据大于取出的元素，将已排序元素后移如果已排序数据小于等于取出的元素，将取出的元素插入该位置再取下一个元素。。。。。","tags":[{"name":"算法","slug":"算法","permalink":"https://shleyz.github.io/tags/算法/"}]},{"title":"几种数据结构的特性","date":"2018-04-30T03:44:46.000Z","path":"2018/04/30/几种数据结构的特性/","text":"列表：存储的类型没有限制，长度也不限制，但是受内存限制，主要属性或方法有： currentPos, prev, next, insert, move, getElement, clear, front, end, hasPrev, hasNext等 栈： 只有一端可以存取数据，也就是栈顶， 后入先出， 主要属性和方法： pop, push, top, peek, clear, length等 队列： 不同于列表，只能在队列尾部添加元素，在头部删除元素，满足先进先出，后进后出，主要属性和方法： enquene, dequene, clear, empty, front, back, show 单向链表： 链表节点属性data负责存储数据， 另一个属性next则指向下一个节点，链表主要属性和方法： insert, remove, findPrev, head, display, find 双向链表： data,next与单向链表一样，多出一个previous，指向前一个节点 insert, remove, findPrev, findLast, head, display, displayReverse, find等 循环链表： 单向链表的最后一个节点指向head 字典： dictionary 一种以键值对形式存储的数据结构 集合： set 集合的成员是无序的，都不相同的 树： 二叉查找树，bst，层次结构，遍历二叉树： 前序，中序，后续遍历","tags":[]},{"title":"数组拷贝","date":"2018-04-28T01:09:09.000Z","path":"2018/04/28/数组拷贝/","text":"首先要理解什么是栈内存和堆内存javascript中变量的存放有原始值和引用值之分 原始值代表原始数据类型，如Undefined，Null，Number， String，Boolean类型的值 引用值如Object，Function，Array 1.栈内存存放存储对象的地址 原始类型的值，其地址和具体内容都存放在栈内,栈中数据的大小一般是已知的或者有上限的，自动分配内存空间，由系统自动释放内存 2.堆内存存放存储对象的具体内容 引用类型的值(对象变量的指针)，其地址存放在栈内，但是其具体内容存放在堆中,堆中数据的大小一般是未知的，是动态分配内存的，系统不会自动释放内存 这也是为什么null作为对象却存放在栈中。 null === null –&gt; true 存储在栈NaN === NaN –&gt; false 存储在堆 3.栈内存和堆内存的区别 栈内存相对与堆内存运行效率比较高，空间相对于堆内存来说较小 说明一下const一般定义的类型值是不能改的，但是定义的对象可以通过修改对象的属性来改变的（但是栈中存在的指针是不能变得）。 什么是深拷贝和浅拷贝浅拷贝 拷贝引用也就是栈内存放的指针，拷贝对象的和被拷贝对象都指向一个引用，并且修改数据会影响另一个数据 深拷贝 复制变量的值，对于非基本类型的值，则递归至基本变量后，再复制。可以使用slice()和concat() 1.浅拷贝的实现1234var arr = ['a', 'b', 'c'];var arr1 = arrarr1[0] = 'd'arr // ['d', 'b', 'c'] arr2的修改会影响被拷贝的值 2.深拷贝的实现slice和concat和自定义函数实现2.1 slice12345var arr = ['a', 'b', 'c']var arr2 = arr.slice(0)arr2[0] = 'd'arr2 // ['d', 'b', 'c']arr // ['a', 'b', 'c'] arr2的修改不会影响被拷贝的值 2.2 concat12345var arr = ['a', 'b', 'c']var arr2 = [].concat(arr)arr2[0] = 'd'arr2 // ['d', 'b', 'c']arr // ['a', 'b', 'c'] arr2的修改不会影响被拷贝的值 2.3 es6扩展运算符…实现深拷贝注意只能深拷贝一维数组，当有多维数组时，二维以及以后的维度的仍然是引用，因此修改之后仍然会影响原来的数组，而不能做到深拷贝 var arr = ['a', 'b', 'c'] var arr2 = [...arr] arr2[0] = 'd' arr2 // ['d', 'b', 'c'] arr // ['a', 'b', 'c'] arr2的修改不会影响被拷贝的值 2.4 自定义function DeepClone(obj) { if(obj === null){ return null } if(obj.constructor !== 'object'){ return obj } if(obj.constructor === Date){ return new Date(obj) } if(obj.constructor === RegExp) { return new RegExp(obj) } var newObj = new obj.constructor() //保持继承的原型 for (var key in obj) { if(obj.hasOwnProperty(key)) { var val = obj[key]; newObj[key] = typeof val === 'object' ? DeepClone(val) : val } } return newObj } let a = DeepClone({'a': 1, 'b': 2, 'c': {'c1': 3}}) a // {a: 1, b: 2, c: {c1: 3}}","tags":[{"name":"数组拷贝","slug":"数组拷贝","permalink":"https://shleyz.github.io/tags/数组拷贝/"}]},{"title":"js数据结构-树，二叉树","date":"2018-04-25T05:10:24.000Z","path":"2018/04/25/js数据结构-二叉树/","text":"不同于列表，队列，栈等线性数据结构，树是一种非线性结构的树。树的特征就是： 元素之间有明显的层次特性，常用来存储具有层级关系的数据，比如文件系统的文件 父节点树结构中每一个节点只有一个前件根节点没有前件的节点只有一个就是子节点每个节点可以有多个后件叶子节点没有后件的节点度一个节点所拥有的子节点的个数树的度所有节点最大的度树的深度树的最大层次 二叉树是一种特殊的树，他的子节点个数不超过两个，分别被成为左子树和右子树二叉树也被称为二叉查找树，二叉堆，二叉排序树 树的遍历： 按一定的规则和顺序走遍二叉树的所有节点，使每个节点都被访问到，并且只被访问一次。 二叉树是非线性结构，所以要先把二叉树抓换成线性序列 按根节点的访问顺序，树的遍历分为三种： 前序遍历： 根节点 –&gt; 左子树 –&gt; 右子树 中序遍历： 左子树 –&gt; 根节点 –&gt; 右子树 后续遍历： 左子树 –&gt; 右子树 –&gt; 根节点 如上图遍历结果： 前序遍历：ABGEFDC中序遍历：DEBGFAC后续遍历：EDGFBCA 二叉查找树（BST）的属性或者方法： 类型 描述 insert 插入节点 preOrder 先序遍历 inOrder 中序遍历 postOrder 后序遍历 find 查找节点 getMin 查找最小值 getMax 查找最大值 remove 删除节点 二叉查找树（BST）的实现二叉树实际由多个节点组成，因此定义Node类，用于存放树的节点。Node类既保存了数据又保存了其左节点和右节点的链接，show方法用来显示保存在节点中的数据。 1234567891011121314151617181920212223// 节点定义function Node(data, left, right) &#123; this.data = data; this.left = left; this.right = right; this.show = show&#125;function show() &#123; return this.data;&#125;// 二叉查找树（BST）的类function BST()&#123; this.root = null; this.insert = insert; // 插入节点 this.preOrder = preOrder; // 先序遍历 this.inOrder = inOrder; // 中序遍历 this.postOrder = postOrder; // 后序遍历 this.find = find; // 查找节点 this.getMin = getMin; //查找最小值 this.getMax = getMax; //查找最大值 this.remove = remove; //解除节点&#125; 向二叉树插入数据，涉及到插入的位置问题 首先创建一个新的Node节点， 其次检查当前BST是否有根节点，如果没有，则是一个新树，添加的节点就是根节点。 如果有根节点，则要遍历BST，找到合适的位置插入： 设置当前节点为根节点 如果待插入的data小于当前节点的值，则新节点为当前节点的左节点，反之进行 4 操作 如果当前节点的左节点为null,则新节点就放在这里，退出循环，否则进入下一次循环 新节点为当前节点的右节点 如果当前节点的右节点为null,则新节点就放在这里，退出循环，否则进入下一次循环 具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131function insert(data) &#123; var insertN = new Node(data, null, null) if(this.root == null)&#123; this.root = insertN &#125; else &#123; var current = this.root; while(true) &#123; if(data &lt; current.data) &#123; // 放在左节点 if(current.left == null) &#123; current.left = insertN break; &#125; else &#123; current = current.left &#125; &#125; else &#123; // 放在右节点 if(current.right == null) &#123; current.right = insertN break; &#125; else &#123; current = current.right &#125; &#125; &#125; &#125;&#125;// 中序遍历function inOrder(node) &#123; if(!(node == null))&#123; inOrder(node.left) console.log(node.data) inOrder(node.right) &#125;&#125;// 先序遍历function preOrder(node)&#123; if(!(node == null)) &#123; console.log(node.data) preOrder(node.left) preOrder(node.right) &#125;&#125;// 后序遍历function postOrder(node)&#123; if(!(node == null)) &#123; postOrder(node.left) postOrder(node.right) console.log(node.data) &#125;&#125;//查找最小值, 最小值应该在左子树，遍历左子树直到他的左子树为null时function getMin() &#123; var current = this.root; while(!(current.left == null))&#123; current = current.left &#125; return current.show()&#125;//查找最大值, 最大值应该在右子树，遍历右子树直到他的右子树为null时function getMax() &#123; var current = this.root; while(!(current.right == null))&#123; current = current.right &#125; return current.show()&#125;// 查找节点function find(data) &#123; var current = this.root; while(!(current == null)) &#123; if(current.data === data) &#123; return current &#125; else if(current.data &gt; data) &#123; current = current.left &#125; else &#123; current = current.right &#125; &#125; return null&#125;// 移除节点function remove(data) &#123; removeNode(this.root, data)&#125;// 查找最小值function getSmallest(node) &#123; if(node.left == null) &#123; return node &#125; else &#123; return getSmallest(node.left) &#125;&#125;function removeNode(node, data)&#123; if (node == null) &#123; return null &#125; if(data == node.data) &#123; // 没有子节点 if(node.left == null &amp;&amp; node.right == null) &#123; return null &#125; // 只有右节点 if(node.left == null)&#123; return node.right &#125; // 只有左节点 if(node.right == null)&#123; return node.left &#125; // 有两个子节点 var tempNode = getSmallest(node.right) node.data = tempNode.data; node.right = removeNode(node.right, tempNode.data) return node &#125; else if(data &lt; node.data) &#123; removeNode(node.left, data) &#125; else &#123; removeNode(node.right, data) &#125;&#125; 测试： 123456789101112131415161718192021222324var bst = new BST()bst.insert(9)bst.insert(4)bst.insert(14)bst.insert(12)bst.insert(11)bst.insert(13)bst.insert(15)bst.insert(16)console.log(bst)inOrder(bst.root) // 4, 9, 11, 12, 13, 14, 15, 16 console.log('------') preOrder(bst.root) // 9, 4, 14, 12, 11, 13, 15, 16 console.log('------')postOrder(bst.root)console.log('------') // 4, 11, 13, 12, 16, 15, 14, 9console.log(bst.getMin()) // 4console.log(bst.getMax()) // 16console.log(bst.find(12)) // Node &#123;data: 12, left: Node, right: Node, show: ƒ&#125;bst.remove(12)console.log(bst) // BST &#123;root: Node, insert: ƒ, preOrder: ƒ, inOrder: ƒ, postOrder: ƒ, …&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://shleyz.github.io/tags/数据结构/"}]},{"title":"js数据结构-集合","date":"2018-04-24T03:10:53.000Z","path":"2018/04/24/js数据结构-集合/","text":"集合是一组无序但彼此之间又有一定关系的成员构成，每个成员在集合中只出现一次。集合的特征就是： 1. 无序， 2. 不重复 不包含任何成员的集合是空集包含一切可能成员的集合是全集两个集合里面成员完全相同，则两个集合相等如果一个集合A的成员全部包含在另一个成员B,则A是B的子集 集合的操作并集：两个集合中的成员合并，生成的一个新的集合交集：两个集合中的共同存在的成员，生成的新的集合补集：属于一个集合但不属于另一个集合，生成的新的集合 集合常见的属性或者方法： 类型 描述 add 添加成员 remove 删除成员 size 集合成员个数 union 求并集 intersect 求交集 subset 判断一个集合是否是另一个集合的子集 difference 求补集 contains 判断成员是否属于集合 show 显示集合 集合的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113var mySet = function() &#123; this.dataStore = []; //初始化为空&#125;mySet.prototype = (function () &#123; return &#123; add: add, remove: remove, size: size, union: union, intersect: intersect, subset: subset, difference: difference, contains: contains, show: show, &#125; // 添加成员, 返回boolean function add(data) &#123; let index = this.dataStore.indexOf(data) if(index === -1) &#123; // 如果元素不存在 this.dataStore.push(data); return true &#125; else &#123; // 如果元素存在 console.log('can not add ' + data + ', must already be existed') return false &#125; &#125; // 删除一个成员 function remove(data)&#123; let index = this.dataStore.indexOf(data) if(index === -1) &#123; // 如果元素不存在 console.log(data + ', is not in set') return false &#125; else &#123; // 如果元素存在 this.dataStore.splice(index, 1) return true &#125; &#125; // 集合成员个数 function size(key) &#123; return this.dataStore.length; &#125; // 判断成员是不是在集合内 function contains(data) &#123; let index = this.dataStore.indexOf(data) return index !== -1 &#125; // 两个集合的并集 function union(set)&#123; var tempSet = new mySet(); for (var i=0; i&lt;this.dataStore.length; i++) &#123; tempSet.add(this.dataStore[i]) &#125; for (var i=0; i&lt;set.dataStore.length; i++) &#123; if(!tempSet.contains(set.dataStore[i])) &#123; tempSet.add(set.dataStore[i]) &#125; &#125; return tempSet &#125; // 集合的交集 function intersect(set)&#123; var tempSet = new mySet(); for (var i=0; i&lt;this.dataStore.length; i++) &#123; if(set.contains(this.dataStore[i])) &#123; tempSet.add(this.dataStore[i]) &#125; &#125; return tempSet &#125; // 判断一个集合是否是另一个集合set的子集 function subset(set) &#123; if(this.size() &gt; set.size()) &#123; return false &#125; else &#123; for (var i=0; i&lt;this.dataStore.length; i++) &#123; if(!set.contains(this.dataStore[i])) &#123; return false &#125; &#125; &#125; return true &#125; // 集合的补集 function difference(set) &#123; var tempSet = new mySet(); for (var i=0; i&lt;this.dataStore.length; i++) &#123; if(!set.contains(this.dataStore[i])) &#123; tempSet.add(this.dataStore[i]) &#125; &#125; return tempSet &#125; // 显示集合 function show() &#123; console.log(this.dataStore) return this.dataStore &#125;&#125;()) 操作： 12345678910111213141516171819202122var myset = new mySet()myset.show() // []myset.add('cat') // [\"cat\"]myset.add('dog') // [\"cat\", \"dog\"]myset.add('cat') // can not add cat, must already be existedmyset.add('fish') // [\"cat\", \"dog\", \"fish\"]myset.add('bird') // [\"cat\", \"dog\", \"fish\", \"bird\"]myset.remove('cat') // [\"dog\", \"fish\", \"bird\"]var otherset = new mySet()otherset.add('cat')otherset.add('dog')otherset.add('fish') // [\"cat\", \"dog\", \"fish\"]console.log(myset.subset(otherset)) // falseotherset.add('bird') // [\"cat\", \"dog\", \"fish\", \"bird\"]console.log(myset.subset(otherset)) // trueconsole.log(myset.union(otherset)) // [\"dog\", \"fish\", \"bird\", \"cat\"]console.log(myset.intersect(otherset)) // [\"dog\", \"fish\", \"bird\"]console.log(myset.difference(otherset)) // []","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://shleyz.github.io/tags/数据结构/"}]},{"title":"js数据结构-字典","date":"2018-04-24T02:19:00.000Z","path":"2018/04/24/js数据结构-字典/","text":"字典是一种键值对形式存储的数据结构。javascript中的Object就是由字典形式设计的 字典常见的属性或者方法： 类型 描述 add 添加元素 find 查找一个元素 remove 删除一个元素 showAll 显示字典元素 count 字典元素个数 clear 清空字典元素 字典的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 var Dictionary = function() &#123; this.dataStore = []; //初始化为空 &#125; Dictionary.prototype = (function () &#123; return &#123; add: add, find: find, remove: remove, showAll: showAll, count: count, clear: clear, &#125; // 添加元素 function add(key, value) &#123; this.dataStore[key] = value &#125; // 查找字典中的元素 function find(key) &#123; return this.dataStore[key] &#125; // 删除一个元素 function remove(key)&#123; if(this.dataStore[key]) &#123; delete this.dataStore[key] &#125; else &#123; return 'Not Found' &#125; &#125; // 显示所有字典元素 function showAll()&#123; for(var key in this.dataStore)&#123; console.log(key + '--&gt;' + this.dataStore[key]) &#125; &#125; // 字典元素个数 function count()&#123; var count = 0; for(var key in this.dataStore)&#123; count += 1; &#125; return count &#125; // 清空字典元素 function clear() &#123; for(var key in this.dataStore)&#123; delete this.dataStore[key] &#125; &#125; &#125;())``` 操作：``` js var dict = new Dictionary(); dict.add('name', 'cat') dict.add('name1', 'dog') dict.add('name2', 'bird') dict.add('name3', 'fish') console.log(dict.showAll()) // name--&gt;cat // name1--&gt;dog // name2--&gt;bird // name3--&gt;fish console.log(dict.find('name')) // cat dict.remove('name3') console.log(dict.showAll()) // name--&gt;cat // name1--&gt;dog // name2--&gt;bird console.log(dict.count()) // 3 dict.clear() console.log(dict.count()) // 0","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://shleyz.github.io/tags/数据结构/"}]},{"title":"js数据结构-链表","date":"2018-04-23T07:54:06.000Z","path":"2018/04/23/js数据结构-链表/","text":"链表 Linked-list链表的种类有单向链表，双向链表，单向循环链表和双向循环链表 链表是一组节点的集合，每个节点都使用一个对象的引用（链）来指向后一个节点。 data | next --&gt; data2 | next --&gt; Null 其中data保存数据，next保存下一个节点的引用（指针），上面最后一个节点也就是链表的为元素指向null,表示链接结束。 有头节点的链表: 由于链表的起始点比较难以确定，所以很多链表的实现都是在链表的最前面加一个特殊的节点，称为头节点，来表示链表的头部，链表就变成了这样： Header | next --&gt; data1 | next --&gt; data2 | next --&gt; Null 向链表中插入一个节点： 只需改变前一个节点的指向（指向到新节点），新节点的指向原来前一个节点的指向，如下新节点data3 Header | next –&gt; data1 | next –&gt; data3 | next –&gt; data2 | next –&gt; Null 向列表删除一个节点(删除data1节点)： 只需将带删除节点的前一个节点指向改为待删节点的指向，然后把待删节点指向null Header | next –&gt; data3 | next –&gt; data2 | next –&gt; Null data1 | next –&gt; null 链表的实现设计的链表应该包含两个类，一个是Node类用来表示节点，一个是LinkedList用来表示对节点的操作（添加/删除等） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function Node(ele) &#123; this.element = ele; this.next = null&#125;function LList() &#123; this.head = new Node('head); this.find = find; this.insert = insert; this.remove = remove; this.findPrev = findPrev; this.display = display;&#125;// 查找某个节点function find(item)&#123; var currNode = this.head; while(currNode.element !== item) &#123; currNode = currNode.next &#125; return currNode;&#125;// 在item节点插入newEle节点function insert(newEle, item) &#123; var currNode = this.find(item); var newNode = new Node(newEle); newNode.next = currNode.next; currNode.next = newNode;&#125;// 查找前一个节点function findPrev(item) &#123; var currNode = this.head; while( !(currNode.next == null) &amp;&amp; currNode.next.element !== item) &#123; currNode = currNode.next &#125; return currNode&#125;// 移除一个节点function remove(item) &#123; var currNode = this.find(item); var PrevNode = this.findPrev(item); PrevNode.next = currNode.next; currNode.next = null&#125;// 显示所有链表元素function display() &#123; var currNode = this.head; while( !(currNode.next == null) )&#123; console.log(currNode.element); currNode = currNode.next &#125;&#125; 测试： 123456789101112131415161718192021222324252627var linkedList = new LList()console.log(linkedList) // LList &#123;head: Node, find: ƒ, insert: ƒ, remove: ƒ, findPrev: ƒ, …&#125; // display: ƒ display() // find: ƒ find(item) // findPrev: ƒ findPrev(item) // head: Node // element: \"head\" // next: Node &#123;element: \"node1\", next: Node&#125; // __proto__: Object // insert: ƒ insert(newEle, item) // remove: ƒ remove(item) // __proto__: ObjectlinkedList.insert('node1', 'head')linkedList.insert('node2', 'node1')linkedList.insert('node3', 'node2')console.log(linkedList.display())// // head// node1// node2linkedList.remove('node2')console.log(linkedList)// // head// node1 双向链表的实现Null &lt;– previous | Header | next previous | data1 | next previous | data2 | next –&gt; Null 要实现双向链表，需要给node类添加一个previous属性， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function Node(ele) &#123; this.element = ele; this.next = null; this.previous = null;&#125;function LList() &#123; this.head = new Node('head'); this.find = find; this.findLast = findLast; this.insert = insert; this.remove = remove; this.findPrev = findPrev; this.display = display; this.dispReverse = dispReverse; // 反向显示链表&#125;// 查找某个节点function find(item)&#123; var currNode = this.head; while(currNode.element !== item) &#123; currNode = currNode.next &#125; return currNode;&#125;// 在item节点插入newEle节点function insert(newEle, item) &#123; var currNode = this.find(item); var newNode = new Node(newEle); newNode.next = currNode.next; newNode.previous = currNode; currNode.next = newNode;&#125;// 查找前一个节点function findPrev(item) &#123; var currNode = this.head; while( !(currNode.next == null) &amp;&amp; currNode.next.element !== item) &#123; currNode = currNode.next &#125; return currNode&#125;// 查找最后一个元素function findLast() &#123; var currNode = this.head; while(!(currNode.next == null)) &#123; currNode = currNode.next &#125; return currNode&#125;// 移除一个节点function remove(item) &#123; var currNode = this.find(item); var PrevNode = this.findPrev(item); PrevNode.next = currNode.next; currNode.next = null&#125;// 显示所有链表元素function display() &#123; var currNode = this.head; while( !(currNode.next == null) )&#123; console.log(currNode.element); currNode = currNode.next &#125;&#125;// 反向显示所有链表元素function dispReverse() &#123; var lastNode = this.findLast(); while( !(lastNode.previous.element == 'head') )&#123; console.log(lastNode.element); lastNode = lastNode.previous &#125;&#125; 测试： 12345678910111213141516171819var lists = new LList();lists.insert('node' , 'head');lists.insert('node1' , 'node');lists.insert('node2' , 'node1');lists.insert('node3' , 'node2');console.log( lists.display() ); // node// node1// node2// undefinedconsole.log( lists.dispReverse() );// node2// node1// node// undefined 循环链表的实现Header | next –&gt; data1 | next –&gt; data2 | next –&gt; Header 循环链表和单链表相似，节点类型都是一样，唯一的区别是，在创建循环链表的时候，让其头节点的 next 属性执行它本身，即 head.next = head;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://shleyz.github.io/tags/数据结构/"}]},{"title":"js数据结构-队列","date":"2018-04-22T06:29:22.000Z","path":"2018/04/22/js数据结构-队列/","text":"队列也是一种列表，不同于列表的是，只能在列表尾部插入元素，在队首删除元素，满足先进先出，后进后出的情况都适用于队列（FIFO:first-in-first-out）队列常见的属性或者方法： 类型 描述 enquene 向队列末尾添加元素 dequene 删除队列头部元素 front 读取队列首元素 back 读取队列尾元素 toString 显示队列所有元素 clear 清空队列内元素 empty 判断队列是否为空 队列的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667var Quene = function() &#123; this.dataStore = []; //初始化为空&#125;Quene.prototype = (function () &#123; return &#123; enquene: enquene, dequene: dequene, front: front, back: back, toString: toString, clear: clear, empty: empty, &#125; // 入队 function enquene(ele) &#123; this.dataStore.push(ele) &#125; // 出队 function dequene() &#123; if(this.empty())&#123; return 'empty quene' &#125; else &#123; this.dataStore.shift() &#125; &#125; // 读取队列首元素 function front()&#123; if(this.empty())&#123; return 'empty quene' &#125; else &#123; return this.dataStore[0] &#125; &#125; // 读取队列尾元素 function back()&#123; if(this.empty())&#123; return 'empty quene' &#125; else &#123; return this.dataStore[this.dataStore.length - 1] &#125; &#125; // 显示队列所有元素 function toString()&#123; if(this.empty())&#123; return 'empty quene' &#125; else &#123; return this.dataStore.join(',') &#125; &#125; // 清空队列内元素 function clear() &#123; delete this.dataStore; this.dataStore = [] &#125; // 判断队列是否为空 function empty() &#123; return this.dataStore.length === 0 &#125;&#125;()) 操作： 12345678910111213141516var que = new Quene()que.enquene(1)console.log(que.front()) // 1console.log(que.back()) // 1que.enquene(2)que.enquene(3)console.log(que.front()) // 1console.log(que.back()) // 3que.dequene()console.log(que.front()) // 2console.log(que.back()) // 3console.log(que.toString()) // \"2,3\"console.log(que.empty()) // falseque.clear()console.log(que.empty()) // true 队列的应用利用队列实现基数排序 基数排序（radix sort）属于“分配式排序”（distribution sort），它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。 排序两位数的思路： 先按个位数字进行排序，再按十位数进行排序 假设我们有一串数字，分别为 73, 22, 93, 43, 55, 14, 28, 65, 39, 81 首先根据个位数字排序，81, 22, 73, 93, 43, 14, 55, 65, 28, 39 然后根据十位数字排序，14, 22, 28, 39, 43, 55, 65, 73, 81, 93 1234567891011121314151617181920212223242526272829303132333435363738394041424344//基数排序var queues = []; //定义队列数组var nums = []; //定义数字数组//选十个0~99的随机数进行排序for ( var i = 0 ; i &lt; 10 ; i ++ )&#123; queues[i] = new Queue(); nums[i] = Math.floor( Math.random() * 101 );&#125;//排序之前console.log( 'before radix sort: ' + nums );//基数排序distribution( nums , queues , 10 , 1 );collect( queues , nums );distribution( nums , queues , 10 , 10 );collect( queues , nums );//排序之后console.info('after radix sort: ' + nums );//根据相应的（个位和十位）数值，将数字分配到相应队列function distribution ( nums , queues , n , digit ) &#123; //digit表示个位或者十位的值 for( var i = 0 ; i &lt; n ; i++ )&#123; if( digit == 1)&#123; queues[ nums[i] % 10 ].enqueue( nums[i] ); &#125;else&#123; queues[ Math.floor( nums[i] / 10 ) ].enqueue( nums[i] ); &#125; &#125;&#125;//从队列中收集数字function collect ( queues , nums ) &#123; var i = 0; for ( var digit = 0 ; digit &lt; 10 ; digit ++ )&#123; while ( !queues[digit].empty() )&#123; nums[ i++ ] = queues[digit].front(); queues[digit].dequeue(); &#125; &#125;&#125; 优先队列/循环队列","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://shleyz.github.io/tags/数据结构/"}]},{"title":"js数据结构-栈","date":"2018-04-21T05:37:35.000Z","path":"2018/04/21/js数据结构-栈/","text":"上一篇的列表对数据的存储顺序不要求，而这次的栈和列表类似，但是比列表更高效。 栈，又称堆栈，栈内的元素只能通过数据的一端访问，称为栈顶，数据只能在栈顶添加或删除，遵循先入后出的原则（last-in-first-out） 栈的主要操作：push–元素入栈， pop–元素出栈 栈常见的属性或者方法： 类型 描述 push 新元素入栈 pop 顶部元素出栈 top 查看当前栈顶位置 peek 查看当前栈顶元素 length 查看当前栈元素总数 clear 清空栈内元素 栈的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546var Stack = function() &#123; this.top = 0; //记录栈顶位置 this.dataStore = []; //初始化为空&#125;Stack.prototype = (function () &#123; return &#123; length: length, clear: clear, pop: pop, push: push, peek: peek, &#125; // 返回栈元素的个数 function length() &#123; return this.top; &#125; // 清空栈的所有元素 function clear() &#123; delete this.dataStore; this.top = 0; this.dataStore = []; &#125; // 该方法将一个新元素入栈，放到数组中 top 所对应的位置上，并将 top 的值加 1，让其指向数组的下一个空位置 function push(ele)&#123; this.dataStore[this.top++] = ele; &#125; // 该方法与入栈相反，返回栈顶元素，并将 top 的值减 1 function pop()&#123; return this.dataStore[--this.top]; &#125; // 该方法返回的是栈顶元素，即 top - 1 个位置元素 function peek()&#123; if(this.top &gt; 0) &#123; return this.dataStore[this.top - 1] &#125; else &#123; return 'empty' &#125; &#125; &#125;()) 操作： 1234567891011var stack = new Stack()console.log(stack.peek()) // emptystack.push('one')stack.push('two')console.log(stack.peek()) // twostack.pop()console.log(stack.peek()) // onestack.length() // 1stack.clear()console.log(stack.peek()) // empty 栈的应用判断回文字符串，即反转后的字符串和原字符串一样 12345678910111213141516function isPalindrome(word) &#123; var s = new Stack() for (var i = 0; i &lt; word.length; i++) &#123; s.push(word[i]) &#125; var rword = \"\"; while (s.length() &gt; 0) &#123; rword += s.pop(); &#125; if (word == rword) &#123; return true; &#125; else &#123; return false; &#125;&#125; 实现一个阶乘算法 5! = 5 4 3 2 1 = 120 function fact(n) { var s = new Stack() while (n &gt; 1) { //[5,4,3,2] s.push(n--); } var product = 1; while (s.length() &gt; 0) { product *= s.pop(); } return product; } fact(6) // 720","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://shleyz.github.io/tags/数据结构/"}]},{"title":"列表","date":"2018-04-21T03:16:49.000Z","path":"2018/04/21/js数据结构-列表/","text":"列表是一组有序的数据，每个列表中的数据被称为一个元素，元素可以是任意类型，列表可以保存多少数据没有限制，但是会受内存的限制。列表中常见的属性或者方法： 类型 描述 listSize 列表元素个数 pos 当前位置 length 返回列表中元素的个数 clear 清除列表中所有元素 toString 返回列表的字符串形式 getElement 返回当前位置的元素 insert 在现有元素后插入新元素 append 在列表的末尾添加新元素 remove 在列表中删除元素 front 将列表的当前位置移动到第一个元素位置 end 将列表的当前位置移动到最后一个元素位置 prev 将当前位置后移一位 next 将当前位置前移一位 hasNext 判断是否还有下一位 hasPrev 判断是否还有上一位 currPos 返回列表的当前位置 moveTo 将当前位置移动到指定位置 模拟列表来构造函数以及对应迭代器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142var List = function() &#123; this.listSize = 0; this.pos = 0; this.dataStore = [];&#125;List.prototype = (function () &#123; return &#123; length: length, clear: clear, toString: toString, getElement: getElement, insert: insert, append: append, remove: remove, front: front, end: end, prev: prev, next: next, hasNext: hasNext, hasPrev: hasPrev, currPos: currPos, moveTo: moveTo, find: find, &#125; /* * 返回列表元素的个数 * @returns &#123;number&#125; */ function length() &#123; return this.listSize; &#125; /** * 清空列表中的所有元素 */ function clear() &#123; delete this.dataStore; this.listSize = 0; this.currPos = 0; this.dataStore.length = 0; &#125; /* * 返回要展示的列表 * @returns &#123;string&#125; */ function toString() &#123; return this.dataStore; &#125; /* * 返回当前位置的元素 * @returns &#123;*&#125; */ function getElement() &#123; return this.dataStore[this.pos] &#125; /* * 插入某个元素 * @param ele 要插入的元素 * @param after 列表中的元素之后 * @returns &#123;boolean&#125; */ function insert(ele, after) &#123; var insertPos = this.dataStore.find(after); if(this.insertPos &gt; -1) &#123; this.dataStore.splice(insertPos, 0, ele) ++this.listSize; return true &#125; else &#123; return false &#125; &#125; /* * 给列表最后添加元素的时候，列表元素个数+1 * @param ele */ function append(ele) &#123; ++this.listSize; this.dataStore.push(ele) &#125; /* * 删除元素成功，元素个数-1 * @param ele * @returns &#123;boolean&#125; */ function remove(ele) &#123; let removeIndex = this.dataStore.find(ele); if(removeIndex &gt; -1) &#123; this.dataStore.splice(removeIndex, 1) this.listSize -- return true &#125; else &#123; return false &#125; &#125; /* * 将列表的当前位置移动到第一个元素 */ function front() &#123; this.pos = 0 &#125; /* * 将列表的当前位置移动到最后一个元素 */ function end() &#123; this.pos = this.listSize - 1 &#125; /* * 将当前位置向前移动一位 */ function prev() &#123; --this.pos &#125; /* * 将当前位置向后移动一位 */ function next() &#123; ++this.pos &#125; /* * 判断是否有后一位 * @returns &#123;boolean&#125; */ function hasNext() &#123; return this.pos &lt; this.listSize &#125; /* * 判断是否有前一位 * @returns &#123;boolean&#125; */ function hasPrev() &#123; return this.pos &gt; 0 &#125; /* * 返回列表的当前位置 * @returns &#123;number|*&#125; */ function currPos() &#123; return this.pos &#125;&#125;())","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://shleyz.github.io/tags/数据结构/"}]},{"title":"SSH连接","date":"2018-04-20T05:11:12.000Z","path":"2018/04/20/SSH连接/","text":"服务器端安装SSH安装SSH： yum install openssh-server 启动SSH： sevice sshd start 设置开机运行： chkconfig sshd on 或 systemctl enable sshd.service 客户端SSH连接服务器端SSH本地命令行l： ssh root@server_ip 回车输入密码连接。 SSH config config方便批量管理多个ssh config存放在 ~/.ssh/config config语法 cd ~/.ssh/ vim config 编辑： host &quot;zhu&quot; HostName 47.96.140.** User root Port 22 同样可以配置多个host SSH免密码登录ssh key ssh key使用非对称加密方式生成公钥和私钥 私钥存放在本地~/.ssh目录 公钥可以对外开放，放在服务器的~/.ssh/authorized_keys linux生成秘钥 cd ~/.ssh/ ssh-keygen 然后输入文件名字输入密码确认密码 生成成功 Your identification has been saved in file_sra. Your public key has been saved in file_sra.pub. The key fingerprint is: SHA256:NrBxS72quC*************Mf54sqrl8tPwraeHYdKzg root@server The key&apos;s randomart image is: +---[RSA 2048]----+ | | | . | | o o . | | * . . | | . . S . | | . + o.o | | *.+oo+o. | | ==E==+== | | =@OO=*=oo. | +----[SHA256]-----+ [root@qyweb01 .ssh]# ls -al total 24 drwx------ 2 root root 4096 Apr 27 12:14 . dr-xr-x---. 5 root root 4096 Apr 27 12:02 .. -rw------- 1 root root 0 Apr 27 10:20 authorized_keys -rw-r--r-- 1 root root 67 Apr 27 11:52 config -rw-r--r-- 1 root root 174 Apr 27 11:58 known_hosts -rw------- 1 root root 1679 Apr 27 12:14 zxl_sra -rw-r--r-- 1 root root 394 Apr 27 12:14 zxl_sra.pub 把公钥 .pub 里面的内容复制到服务器 ~/.ssh/authorized_keys 这样就可以免密连接服务器 SSH设置安全端口ssh默认端口22 防止不法分子利用，最好修改默认端口 修改配置文件 /etc/ssh/sshd_config 的port部分， 然后重启服务 systemctl restart sshd.service 最好不要修改默认端口，而是使用复杂的密码，或者使用密钥登陆","tags":[]},{"title":"Linux使用","date":"2018-04-20T05:11:12.000Z","path":"2018/04/20/linux操作/","text":"软件操作软件包管理 yum 安装 yum install ... 卸载 yum remove ... 搜索 yum serach ... 清理缓存 yum clean packages 列出已安装 yum list 软件包信息 yum info ... 硬件资源信息 内存 free -m 硬盘 df -h 负载（w或top） w 12:53:49 up 2:33, 3 users, load average: 0.00, 0.01, 0.05 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT root tty2 10:32 1:59m 0.04s 0.04s -bash root pts/0 121.239.246.23 11:34 1:13m 0.01s 0.01s -bash root pts/1 121.239.246.23 12:24 5.00s 0.02s 0.00s w load average: 0.00, 0.01, 0.05 分别表示最近1分钟，5分钟，15分钟时候的负载值 当到达1时说明负载快要超荷。0.6-0.7是健康值。 cpu个数和核数 cat /proc/cpuinfo 文件操作####目录结构 根目录/ 家目录 /home 临时目录 /tmp 配置目录 /etc 用户程序目录 /usr ####文件基本操作 touch --新建文件 rm --删除文件和目录 cp --复制 mv --移动 pwd --显示路径 ####vim gg--定位到行头 G--定位到行尾 dd--删除整行 u--恢复 ####文件权限421 r--4 可读 w--2 可写 x--1 可执行 ####文件搜索，查找 tail--从尾部开始读 head--从头部开始读 cat--读取整个文件 more--分页读取 less--可控分页 grep--搜索关键字 find--查找文件 wc--统计个数 find . -name &quot;*.conf&quot; --查找当前路径下以conf后缀的文件 find . -type f --查找当前路径下的文件 find . -type d --查找当前路径下的文件夹 find . -ctime -20 --查找20天内更新过的文件 文件压缩和解压tar和untar把zxl文件压缩为zxl.tar： tar -cf zxl.tar zxl 查看zxl.tar里面的内容： tar -tf zxl.tar 查看zxl.tar里面的详细内容： tar -tvf zxl.tar 把zxl.tar解压： tar -xf zxl.tar 系统用户操作命令添加用户cd /home/ useradd zhaolin 这时查看home里面会多了一个文件夹zhaolin 给zhaolin用户添加密码： passwd zhaolin 输入密码并确认密码。 这样就有了一个新的用户zhaolin，可以用ssh用zhaolin用户连接。 删除用户userdel zhaolin --删除用户zhaolin rm -rf zhaolin --删除用户zhaolin目录 userdel -r zhaolin --彻底删除用户以及用户文件夹 防火墙操作作用：保护服务器安全 安装： yum install firewalld 启动： service firewalld started 启动： service firewalld restarted 列出防火墙服务： yum list | grep firewall 查看是否启动防火墙： ps -ef|grep firewall 停止： service firewalld stop service firewalld status 提权root账号中 visudo 修改： ## Allows people in group wheel to run all commands %wheel ALL=(ALL) ALL %zhaolin ALL=(ALL) ALL 在zhaolin用户进行操作以前，前面加上sudo即可 sudo yum install XXXXX 文件上传linux: scpscp zhaolin@47.96.140.xx:/tmp/abc.txt ./ 把服务器47.96.140.xx上tmp里面的文件传到本地当前目录 scp abc.txt zhaolin@47.96.140.xx:/tmp 把本地当前目录的文件上传到服务器47.96.140.xx上tmp windows xshell 首先xshell连接linux， 然后再linux服务器上安装： yum install lrzsz 装好以后执行命令： rz 会出现弹框： 选择文件并上传即可 文件下载wget XXXXX","tags":[{"name":"linux","slug":"linux","permalink":"https://shleyz.github.io/tags/linux/"}]},{"title":"Nginx 安装使用","date":"2018-04-20T05:11:12.000Z","path":"2018/04/20/nginx centOS/","text":"nginx基本操作安装： yum install nginx 启动： service nginx start 停止： service nginx stop 重载： service nginx reload 部署NGINX：// $ sudo service httpd stop $ sudo yum install nginx 查看是否启动： $ ps -ef | grep nginx 启动： $ sudo service nginx start $ sudo service nginx reload firewall-cmd --zone=public --add-port=80/tcp --permanent 防火墙开启80端口 firewall-cmd --reload 防火墙重载 yum install iptables-services systemctl enable iptables systemctl stop firewalld systemctl start firewalld 配置/etc/nginx/下的配置文件： 因为在nginx主配置文件中引入了conf.d文件夹中的: include /etc/nginx/conf.d/*.conf;所以在nginx/conf.d/下面添加**.conf文件进行配置. 主配置文件如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# For more information on configuration, see:# * Official English Documentation: http://nginx.org/en/docs/# * Official Russian Documentation: http://nginx.org/ru/docs/user root;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;# Load dynamic modules. See /usr/share/nginx/README.dynamic.include /usr/share/nginx/modules/*.conf;events &#123; worker_connections 1024;&#125;http &#123; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125; &#125; 首先主配置文件，修改用户组 user root; 然后进行操作： cd conf.d touch **.conf //新建文件 vim **.conf 修改**.conf: server { listen 80; server_name 47.**.***.**; #charset koi8-r; #access_log logs/host.access.log main; location / { root /home/********/****; index index.html index.htm; try_files $uri /index.html; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } react-router在nginx上的应用，参照：调整nginx正确服务react-router应用 注意在linux进行解压文件时unrar e build.rar build 这样会把build.rar里面所有的文件都解压到build文件夹，不保持原有的目录。 unrar x build.rar build 这样解压会保持原有的目录。","tags":[{"name":"nginx","slug":"nginx","permalink":"https://shleyz.github.io/tags/nginx/"}]},{"title":"阿里云服务器nginx安装","date":"2018-04-20T05:11:12.000Z","path":"2018/04/20/nginx web服务器/","text":"阿里云服务器Linux远程ssh连接可以在创建 ECS 实例时分配密钥对，也可以为实例绑定密钥对。 一台 ECS 实例只能绑定一个 SSH 密钥对。 创建密钥对登录 ECS 控制台。 在左侧导航栏中，单击 密钥对。 在 密钥对 页面上，选择所需地域后，单击 创建密钥对。 在 创建密钥对 页面，设置密钥对名称，并选择 自动新建密钥对。 单击 确定 创建密钥对。 绑定密钥对登录 ECS 控制台。 在左侧导航栏中，选择 网络与安全 &gt; 密钥对。 选择一个地域。 找到需要操作的密钥对，在 操作 列中，单击 绑定密钥对。 在 绑定密钥对 对话框里，在 选择 ECS 实例 栏中，选中需要绑定该密钥对的 ECS 实例名称，单击 &gt;，移入 已选择 栏中。 单击 确定 绑定密钥对。 使用 SSH 密钥对连接 Linux 实例（本地为 Windows 环境）#####前提条件 已经下载并安装了 PuTTY 和 PuTTYgen。 PuTTY 和 PuTTYgen 的下载地址： PuTTY： https://the.earth.li/~sgtatham/putty/latest/w64/putty.exe PuTTYgen： https://the.earth.li/~sgtatham/putty/latest/w64/puttygen.exe 已经拥有一个分配了密钥对的 Linux 实例。可以在创建 ECS 实例时分配密钥对，也可以为实例绑定密钥对。 实例所在的安全组必须添加以下安全组规则（具体操作，请参考 https://help.aliyun.com/document_detail/51798.html?spm=a2c4g.11186623.4.2.4RBql5#windows） #####操作步骤 （可选）如果您正在使用阿里云生成的 .pem 私钥文件，应先按以下步骤转为 .ppk 私钥文件。如果您使用的私钥文件本身已经是 .ppk 文件，可以略过这一步。 启动 PuTTYgen。本示例中的 PuTTYgen 版本为 0.68。 在 Parameters &gt; Type of key to generate 中，选中 RSA。Number of bits in a generated key 的值不需要设置，软件会根据导入的私钥信息自动更新。 单击 Load。PuTTYgen 默认仅显示扩展名为 .ppk 的文件。要找到您的 .pem 文件，请选择显示所有类型的文件。 选择您从阿里云下载的“.pem”格式的私钥文件，然后单击 打开。 单击 OK（确定）关闭确认对话框。 单击 Save private key。PuTTYgen 会显示一条关于在没有口令的情况下保存密钥的警告，单击 是(Y)。 指定与密钥对相同的私钥名称，保存。PuTTY 会自动为文件添加 .ppk 扩展名。 启动 PuTTY。 单击 Connection &gt; SSH &gt; Auth，再单击 Browse…，选择前面所生成的 .ppk 文件。 单击 Session， 在 Host Name (or IP address) 里输入账号和需要连接的实例公网 IP 地址，格式为 “root@IP 地址”。 在 Port 里输入端口号 22； Connection type 选择 SSH。 单击 Open，开始连接您的 Linux 实例。 Ubuntu下搭建和配置Nginx Web服务器安装nginxapt-get update apt-get install nginx 启动nginxsystemctl start nginx systemctl status nginx -l systemctl enable nginx 停止nginxsystemctl stop nginx 测试：lsof -i:80 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME AliYunDun 898 root 18u IPv4 12980 0t0 TCP qyweb01:33654-&gt;140.205.140.205:http (CLOSE_WAIT) AliYunDun 934 root 18u IPv4 12980 0t0 TCP qyweb01:33654-&gt;140.205.140.205:http (CLOSE_WAIT) AliYunDun 934 root 21u IPv4 13271 0t0 TCP qyweb01:48738-&gt;106.11.68.13:http (ESTABLISHED) nginx 16177 root 6u IPv4 33583 0t0 TCP *:http (LISTEN) nginx 16177 root 7u IPv6 33584 0t0 TCP *:http (LISTEN) nginx 16178 www-data 6u IPv4 33583 0t0 TCP *:http (LISTEN) nginx 16178 www-data 7u IPv6 33584 0t0 TCP *:http (LISTEN) nginx 16179 www-data 6u IPv4 33583 0t0 TCP *:http (LISTEN) nginx 16179 www-data 7u IPv6 33584 0t0 TCP *:http (LISTEN) 看到如上的信息，说明nginx启动成功。 nginx配置文件全放在/etc/nginx 下面，用 ll 名令查看如下： root@qyweb01:/etc/nginx# ll total 64 drwxr-xr-x 6 root root 4096 Apr 26 12:47 ./ drwxr-xr-x 90 root root 4096 Apr 26 12:47 ../ drwxr-xr-x 2 root root 4096 Jul 12 2017 conf.d/ -rw-r--r-- 1 root root 1077 Feb 12 2017 fastcgi.conf -rw-r--r-- 1 root root 1007 Feb 12 2017 fastcgi_params -rw-r--r-- 1 root root 2837 Feb 12 2017 koi-utf -rw-r--r-- 1 root root 2223 Feb 12 2017 koi-win -rw-r--r-- 1 root root 3957 Feb 12 2017 mime.types -rw-r--r-- 1 root root 1462 Feb 12 2017 nginx.conf -rw-r--r-- 1 root root 180 Feb 12 2017 proxy_params -rw-r--r-- 1 root root 636 Feb 12 2017 scgi_params drwxr-xr-x 2 root root 4096 Apr 26 12:47 sites-available/ drwxr-xr-x 2 root root 4096 Apr 26 12:47 sites-enabled/ drwxr-xr-x 2 root root 4096 Apr 26 12:47 snippets/ -rw-r--r-- 1 root root 664 Feb 12 2017 uwsgi_params -rw-r--r-- 1 root root 3071 Feb 12 2017 win-utf nginx.conf是主配置文件 查看nginx进程是否启动 ps -ef|grep nginx 配置nginx Web服务器主要配置文件nginx.conf sudo vim /etc/nginx/nginx.conf 虚拟主机配置文件 sudo vim /etc/nginx/sites-enabled/default Ubuntu下安装nodesudo apt-get install nodejs-legacy nodejs sudo apt-get install npm Windows上传文件到Ubuntu服务器使用WinSCP工具，传输rar压缩文件 Linux解压文件apt install rar unrar unrar e build.rar","tags":[{"name":"nginx","slug":"nginx","permalink":"https://shleyz.github.io/tags/nginx/"}]},{"title":"git相关","date":"2018-03-17T06:42:05.000Z","path":"2018/03/17/git相关/","text":"git仓库 创建版本库：123$ mkdir learngit$ cd learngit$ git init 当前目录下多了一个.git的隐藏目录，这个目录是Git来跟踪管理版本库的，千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 把文件添加到版本库 新建一个文件readme.txt 用命令git add告诉Git，把文件添加到仓库（把要提交的所有修改放到暂存区）： 1$ git add readme.txt 用命令git commit告诉Git，把文件提交到仓库（把暂存区的所有修改提交到分支）： 123$ git commit -m \"本次提交的说明\"$ git push origin brachName 把分支上的所有本地提交推送到远程库 123$ git status 可以让我们时刻掌握仓库当前的状态$ git log 显示从最近到最远的提交日志 12345678commit 8125d1babdf58e7f82b2ce78d048f47d867b1b5c (HEAD -&gt; master)Author: shleyZ &lt;zxl735975459@126.com&gt;Date: Sat Mar 17 11:13:22 2018 +0800 添加一段内容commit 43c80b42f0d4da4005a4c7cf87d150d59a44e64a（HEAD表示当前版本） 回退到上一个版本1$ git reset --hard HEAD^ 指定回到某个版本 1$ git reset --hard 3628164(版本号) 查看你之前的每一次命令，前面是版本号前几位 1$ git reflog 8125d1b (HEAD -&gt; master) HEAD@{0}: commit: 添加一段内容 43c80b4 HEAD@{1}: commit (initial): 本次提交的说明 删除文件 1$ git rm test.txt git分支创建dev分支，然后切换到dev分支 12$ git checkout -b dev//Switched to a new branch 'dev' 用git branch命令查看当前分支（列出所有分支，当前分支前面会标一个*号） 123$ git branch* dev master 合并某分支到当前分支： 1git merge &lt;name&gt; 删除分支： 123git branch -d &lt;name&gt;git branch -D &lt;name&gt; （强行删除分支） 冲突需要根据提示手动解决，最好不要两人在同时对一个文件修改。 分支 master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 在dev分支干活，也就是说，dev分支是不稳定的 合并分支最好用下面这种方法： 1git merge --no-ff -m \"merge with no-ff\" dev 这样Git就会在merge时生成一个新的commit，能看出来曾经做过合并。 bug分支： 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 Feature分支（开发新功能） 多人协作：git remote -v 查看远程库的信息 多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令 1git branch --set-upstream branch-name origin/branch-name。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。","tags":[{"name":"git","slug":"git","permalink":"https://shleyz.github.io/tags/git/"}]},{"title":"解决webstorm被限制读写权限的问题","date":"2018-03-15T08:32:28.000Z","path":"2018/03/15/解决webstorm被限制读写权限的问题/","text":"在webstorm上新建一个项目，发现项目下的所有文件上都多了一个小锁的图标，对这些文件修改或新建文件的时候总是弹出：‘ cannot modify a ready-only directory’的弹窗， 点击修改读写权限的小锁图标，页是弹出‘failed to change read-only flag’。 解决方法： 运行：1sudo chown -R myusername my-project-folder","tags":[]},{"title":"mac修改hostname","date":"2017-12-13T12:10:07.000Z","path":"2017/12/13/mac修改hostname/","text":"修改Mac终端～前面的计算机名： sudo scutil --set HostName temp temp是你想要修改成的名字输入密码回车后重启终端计算机名就会显示temp了！","tags":[{"name":"mac","slug":"mac","permalink":"https://shleyz.github.io/tags/mac/"}]},{"title":"shell进行vim操作Found a swp file by the name","date":"2017-12-10T12:15:52.000Z","path":"2017/12/10/shell进行vim操作Found-a-swp-file-by-the-name/","text":"用vim打开.bash_profile时出现： ATTENTION Found a swap file by the name &quot;.bash_profile.swp&quot; owned by: ****** dated: ****** file name: ******* modified: YES user name: ****** host name: ******* process ID: ****** 。。。。。。。 原因是之前vi 操作.bash_profile文件时出现了异常中断，所以在当前目录下产生了一个.bash_profile.swp文件 使用ls -a命令查看可以发现这个隐藏文件。 rm .bash_profile.swp 这样就不会有 ATTENTION 了","tags":[]},{"title":"python获取指定目录以及其子目录下所有文件","date":"2017-12-05T08:24:54.000Z","path":"2017/12/05/python获取指定目录以及其子目录下所有文件/","text":"#!/usr/bin/env python3 #-*- coding: utf-8 -*- import os def findfile(path): # 获取指定path下的所有文件和文件夹 allfiles = os.listdir(path) for x in allfiles: newPath = os.path.join(path,x) if os.path.isdir(newPath): # 如果是文件夹，就继续往下查找 findfile(newPath) if os.path.isfile(newPath): # 如果是文件，打印出来 print(newPath) #绝对路径 print(newPath.split(path)[1]) # 相对路径","tags":[]},{"title":"python操作文件和目录","date":"2017-12-02T07:28:27.000Z","path":"2017/12/02/python操作文件和目录/","text":"如何在python中进行文件和目录操作呢，我们可以在命令行输入操作系统提供的各种命令。 python内置的os模块可以直接调用操作系统提供的接口函数 1.引用os模块在python交互命令行中 123&gt;&gt;&gt; import os &gt;&gt;&gt; os.name'posix' 如果系统是Linux，Unix或Mac OS X，那么os.name是’posix’如果系统是Windows，那么os.name是’nt’ 2.操作系统中定义的环境变量都在os.environ中12&gt;&gt;&gt; os.environenviron(&#123;'TERM_PROGRAM': 'Apple_Terminal', 'SHELL': '/bin/bash', 'TERM': 'xterm-256color', 'TMPDIR': '/var/folders/jg/dr9gc8rd7y7g0pzyv3xzzp500000gn/T/', 'Apple_PubSub_Socket_Render': '/private/tmp/com.apple.launchd.LI1PfpIvgk/Render', 'TERM_PROGRAM_VERSION': '38.8.1.1', 'OLDPWD': '/Users/*****/workspace', 'TERM_SESSION_ID': '475******6', 'USER': '*****', 'SSH_AUTH_SOCK': '/private/tmp/com.apple.launchd.h8tpeio0hp/Listeners', '__CF_USER_TEXT_ENCODING': '0x1F5:0x19:0x34', 'PATH': '/anaconda3/bin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/anaconda3/bin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/bin:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/bin:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/bin:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/bin', 'PWD': '/Users/*****/workspace/cpython', 'JAVA_HOME': '/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home', 'LANG': 'zh_CN.UTF-8', 'XPC_FLAGS': '0x0', 'XPC_SERVICE_NAME': '0', 'SHLVL': '1', 'HOME': '/Users/*****', 'LOGNAME': '*****', 'CLASSPATH': '.:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/lib:.:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home', '_': '/anaconda3/bin/python3'&#125;) 要获取某个环境变量的值，可以用os.environ.get(‘key’): 12&gt;&gt;&gt; os.environ.get('PATH')'/anaconda3/bin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/anaconda3/bin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/bin:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/bin:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/bin:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/bin' 3.操作文件和目录查看当前绝对路径12&gt;&gt;&gt; os.path.abspath('.')'/Users/******/Workspace/Cpython' 在目录下创建一个新目录seconddir123&gt;&gt;&gt; os.path.join('/Users/******/Workspace/Cpython','seconddir')'/Users/******/Workspace/Cpython/seconddir'&gt;&gt;&gt; os.mkdir('/Users/******/Workspace/Cpython/seconddir') 删除一个目录:1&gt;&gt;&gt; os.rmdir('/Users/******/Workspace/Cpython/seconddir') 拼接路径：12 &gt;&gt;&gt; os.path.join('/Users/******/Workspace','Cpython')'/Users/******/Workspace/Cpython' 拆分路径：12 &gt;&gt;&gt; os.path.split('/Users/******/Workspace/Cpython')('/Users/******/Workspace', 'Cpython') 对文件夹或者文件重命名：1&gt;&gt;&gt; os.rename('seconddir','second') 删掉文件（当前目录下的）1&gt;&gt;&gt; os.remove('first_test.py') 列出当前目录下的所有目录12 &gt;&gt;&gt; [x for x in os.listdir('.') if os.path.isdir(x)]['__pycache__', 'second'] 列出所有的.py文件：12&gt;&gt;&gt; [x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1] == '.py']['first.py', 'first_test.py', 'hello.py', 'learning.py', 'module.py']","tags":[]},{"title":"彻底弄懂javascript执行机制","date":"2017-11-28T06:05:11.000Z","path":"2017/11/28/彻底弄懂javascript执行机制/","text":"这一次，彻底弄懂 JavaScript 执行机制","tags":[]},{"title":"python基础总结","date":"2017-11-26T08:11:12.000Z","path":"2017/11/26/python/","text":"1.原始数据类型和运算符(is vs. ==) is 检查两个变量是否引用同一个对象, 但是 == 检查指向的对象是否具有相同的值.1234567a = [1, 2, 3, 4] # Point a at a new list, [1, 2, 3, 4]b = a # Point b at what a is pointing tob is a # =&gt; True, a and b refer to the same objectb == a # =&gt; True, a's and b's objects are equalb = [1, 2, 3, 4] # Point b at a new list, [1, 2, 3, 4]b is a # =&gt; False, a and b do not refer to the same objectb == a # =&gt; True, a's and b's objects are equal 字符串也可以+ 但尽量不要这样做。1\"Hello \" + \"world!\" # =&gt; \"Hello world!\" 字符串文字（但不是变量）可以连接而不使用’+’1\"Hello \" \"world!\" # =&gt; \"Hello world!\" 可以将字符串视为字符列表1\"This is a string\"[0] # =&gt; 'T' 字符串的长度1len(\"This is a string\") # =&gt; 16 .format可用于格式化字符串，如下所示：12\"&#123;&#125; can be &#123;&#125;\".format(\"Strings\", \"interpolated\") # =&gt; \"Strings can be interpolated\" 重复的format 以方便输入.12\"&#123;0&#125; be nimble, &#123;0&#125; be quick, &#123;0&#125; jump over the &#123;1&#125;\".format(\"Jack\", \"candle stick\")# =&gt; \"Jack be nimble, Jack be quick, Jack jump over the candle stick\" format可以使用关键字。12\"&#123;name&#125; wants to eat &#123;food&#125;\".format(name=\"Bob\", food=\"lasagna\") # =&gt; \"Bob wants to eat lasagna\" 如果Python 3代码也需要在Python 2.5及更低版本上运行，你仍然可以使用旧格式：12\"%s can be %s the %s way\" % (\"Strings\", \"interpolated\", \"old\") # =&gt; \"Strings can be interpolated the old way\" 还可以使用f-strings或格式化的字符串文字进行格式化（在Python 3.6+中）12name = \"Reiko\"f\"She said her name is &#123;name&#125;.\" # =&gt; \"She said her name is Reiko\" 可以将任何Python语句放在大括号内，它将在字符串中输出。1f\"&#123;name&#125; is &#123;len(name)&#125; characters long.\" None 是一个对象1None # =&gt; None 不要使用等号“==”符号将对象与None进行比较，而是使用“is”。 这会检查对象标识是否相等。12\"etc\" is None # =&gt; FalseNone is None # =&gt; True None, 0和空字符串/列表/ dicts /元组都计算为False。 所有其他值均为True12345bool(0) # =&gt; Falsebool(\"\") # =&gt; Falsebool([]) # =&gt; Falsebool(&#123;&#125;) # =&gt; Falsebool(()) # =&gt; False 2.变量和集合print 方法，默认情况下，print方法最后有一个换行符。使用可选参数end更改结束字符串。12345print(\"I'm Python. Nice to meet you!\") # =&gt; I'm Python. Nice to meet you!print(\"Hello, World\", end=\"!\") # =&gt; Hello, World! 从控制台获取输入数据1input_string_var = input(\"Enter some data: \") 变量没有声明，只有赋值。约定命名规则：小写和下划线lower_case_with_underscores12some_var = 5some_var # =&gt; 5 访问以前未分配的变量会报错。1some_unknown_var # 引发异常 if 表达式，等价于三元运算符12\"yahoo!\" if 3 &gt; 2 else 2 # =&gt; 'yahoo!'\"yahoo!\" if 3 &gt; 4 else 2 # =&gt; 2 数组–使用append将内容添加到列表末尾12345li = []li.append(1) # li is now [1]li.append(2) # li is now [1, 2]li.append(4) # li is now [1, 2, 4]li.append(3) # li is now [1, 2, 4, 3] 数组–使用pop从列表末尾删除1li.pop() # =&gt; 3 and li is now [1, 2, 4] 数组–使用切片语法查看范围。包含起始索引，不包括结束索引12345678li = [1, 2, 4, 3] li[1:3] # =&gt; [2, 4]li[2:] # =&gt; [4, 3]li[:3] # =&gt; [1, 2, 4]li[::2] # =&gt;[1, 4] //间隔输出li[::-1] # =&gt; [3, 4, 2, 1] // list反转reverseli[start:end:step] 数组–数组拷贝1li2 = li[:] # =&gt; li2 = [1, 2, 4, 3] but (li2 is li) will result in false. 数组–使用del从列表中删除任意元素1del li[2] # li is now [1, 2, 3] 数组–删除第一次出现的值12li.remove(2) # li is now [1, 3]li.remove(2) # Raises a ValueError as 2 is not in the list 数组–在特定索引处插入元素1li.insert(1, 2) # li is now [1, 2, 3] again 数组–获取与参数匹配的第一个项目的索引12li.index(2) # =&gt; 1li.index(4) # Raises a ValueError as 4 is not in the list 数组–数组相加，原数组不会改变123li=[1, 2, 3]other_li=[4, 5, 6]li + other_li # =&gt; [1, 2, 3, 4, 5, 6] 数组–in检查是否存在于列表中11 in li # =&gt; True 元组–元组类似列表，但是不可变。123tup = (1, 2, 3)tup[0] # =&gt; 1tup[0] = 3 # Raises a TypeError 元组–注意，长度为1的元组必须在最后一个元素之后使用逗号123type((1)) # =&gt; &lt;class 'int'&gt;type((1,)) # =&gt; &lt;class 'tuple'&gt;type(()) # =&gt; &lt;class 'tuple'&gt; 元组–元组操作1234a, b, c = (1, 2, 3) # a is now 1, b is now 2 and c is now 3a, *b, c = (1, 2, 3, 4) # a is now 1, b is now [2, 3] and c is now 4d, e, f = 4, 5, 6 # d is now 4, e is now 5 and f is now 6e, d = d, e # d is now 5 and e is now 4 两个值交换 dictionaries–键值对存储，keys for dictionaries必须是不可变类型。 这是为了确保可以将密钥转换为常量哈希值，以便快速查找。不可变类型包括整数，浮点数，字符串，元组。但是，值可以是任何类型12345empty_dict = &#123;&#125;filled_dict = &#123;\"one\": 1, \"two\": 2, \"three\": 3&#125;invalid_dict = &#123;[1,2,3]: \"123\"&#125; # =&gt; Raises a TypeError: unhashable type: 'list'valid_dict = &#123;(1,2,3):[1,2,3]&#125; filled_dict[\"one\"] # =&gt; 1 dictionaries–使用“keys（）”获取所有keys。 使用“values()”获取所有的值，需要用list（）包装调用以将其转换为列表。 注 - 对于Python版本&lt;3.7，不保证字典键排序。 但是，从Python 3.7开始，字典项保持它们插入字典的顺序。1234567list(filled_dict.keys()) # =&gt; [\"three\", \"two\", \"one\"] in Python &lt;3.7list(filled_dict.keys()) # =&gt; [\"one\", \"two\", \"three\"] in Python 3.7+list(filled_dict.values()) # =&gt; [3, 2, 1] in Python &lt;3.7list(filled_dict.values()) # =&gt; [1, 2, 3] in Python 3.7+\"one\" in filled_dict # =&gt; True1 in filled_dict # =&gt; False dictionaries–查找不存在的key值会报错，使用get不会报错123filled_dict[\"four\"] # KeyErrorfilled_dict.get(\"one\") # =&gt; 1filled_dict.get(\"four\") # =&gt; None dictionaries–get方法设置默认参数，如果查询不到key对应的值，则返回默认参数12filled_dict.get(\"one\", 4) # =&gt; 1filled_dict.get(\"four\", 4) # =&gt; 4 dictionaries–setdefault（）仅在给定键不存在时才插入字典12filled_dict.setdefault(\"five\", 5) # filled_dict[\"five\"] is set to 5filled_dict.setdefault(\"five\", 6) # filled_dict[\"five\"] is still 5 dictionaries–向字典中添加和删除123filled_dict.update(&#123;\"four\":4&#125;) # =&gt; &#123;\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4&#125;filled_dict[\"four\"] = 4 # another way to add to dictdel filled_dict[\"one\"] # Removes the key \"one\" from filled dict set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。12empty_set = set()some_set = &#123;1, 1, 2, 2, 3, 4&#125; # some_set is now &#123;1, 2, 3, 4&#125; set–与字典的键类似，集合的元素必须是不可变的。12345invalid_set = &#123;[1], 1&#125; # =&gt; Raises a TypeError: unhashable type: 'list'valid_set = &#123;(1,), 1&#125;filled_set = &#123;1, 2, 3, 4&#125;filled_set.add(5) # filled_set is now &#123;1, 2, 3, 4, 5&#125;filled_set.add(5) # it remains as before &#123;1, 2, 3, 4, 5&#125; set–与＆设置交集12other_set = &#123;3, 4, 5, 6&#125;filled_set &amp; other_set # =&gt; &#123;3, 4, 5&#125; set–用|设置并集1filled_set | other_set # =&gt; &#123;1, 2, 3, 4, 5, 6&#125; set–用-设置差集12&#123;1, 2, 3, 4&#125; - &#123;2, 3, 5&#125; # =&gt; &#123;1, 4&#125;&#123;2, 3, 5&#125; - &#123;1, 2, 3, 4&#125; # =&gt; &#123;5&#125; set–用^设置对称差集1&#123;1, 2, 3, 4&#125; ^ &#123;2, 3, 5&#125; # =&gt; &#123;1, 4, 5&#125; set–检查左侧的设置是否是右侧设置的超集1&#123;1, 2&#125; &gt;= &#123;1, 2, 3&#125; # =&gt; False set–检查左侧的set是否是右侧set的子集1&#123;1, 2&#125; &lt;= &#123;1, 2, 3&#125; # =&gt; True set–in检查是否存在122 in filled_set # =&gt; True10 in filled_set # =&gt; False 3.控制流和循环if语句。缩进在Python中很重要！约定是使用四个空格，而不是制表符。1234567some_var = 5if some_var &gt; 10: print(\"some_var is totally bigger than 10.\")elif some_var &lt; 10: # This elif clause is optional. print(\"some_var is smaller than 10.\")else: # This is optional too. print(\"some_var is indeed 10.\") for循环12for animal in [\"dog\", \"cat\", \"mouse\"]: print(\"&#123;&#125; is a mammal\".format(animal)) for in 便历(range返回可迭代的数字,从小到大)12345678for i in range(4): print(i) # 1 2 3 4for i in range(4, 8): print(i) # 4 5 6 7for i in range(4, 8, 2): print(i) # 4 6 while 循环1234x = 0while x &lt; 4: print(x) x += 1 # 0 1 2 3 使用try / except块处理异常1234567891011try: # Use \"raise\" to raise an error raise IndexError(\"This is an index error\")except IndexError as e: pass # Pass is just a no-op. Usually you would do recovery here.except (TypeError, NameError): pass # Multiple exceptions can be handled together, if required.else: # Optional clause to the try/except block. Must follow all except blocks print(\"All good!\") # Runs only if the code in try raises no exceptionsfinally: # Execute under all circumstances print(\"We can clean up resources here\") 4.Functions使用“def”创建新方法123456def add(x, y): print(\"x is &#123;&#125; and y is &#123;&#125;\".format(x, y)) return x + y add(5, 6) # =&gt; prints out \"x is 5 and y is 6\" and returns 11add(y=6, x=5) # =&gt; prints out \"x is 5 and y is 6\" and returns 11 可变数量的参数12345def manyArgs(*args): print(args) return args manyArgs(1, 2, 3, 4, 5) # =&gt; prints out \"(1, 2, 3, 4, 5)\" and returns (1, 2, 3, 4, 5) 可变数量的关键字参数12345def keyword_args(**kwargs):return kwargs# Let's call it to see what happenskeyword_args(big=\"foot\", loch=\"ness\") # =&gt; &#123;\"big\": \"foot\", \"loch\": \"ness\"&#125; 同时传 可变数量的参数 和 可变数量的关键字参数1234567891011121314def all_the_args(*args, **kwargs): print(args) print(kwargs)all_the_args(1, 2, a=3, b=4) prints:(1, 2)&#123;\"a\": 3, \"b\": 4&#125; args = (1, 2, 3, 4)kwargs = &#123;\"a\": 3, \"b\": 4&#125;all_the_args(*args) # equivalent to all_the_args(1, 2, 3, 4)all_the_args(**kwargs) # equivalent to all_the_args(a=3, b=4)all_the_args(*args, **kwargs) # equivalent to all_the_args(1, 2, 3, 4, a=3, b=4) 返回多个值（以元祖的形式， 值不可变）123456def swap(x, y):return y, x # 将多个值作为元组返回，不带括号。(注意：括号已被排除，但可以包括在内x = 1y = 2x, y = swap(x, y) # =&gt; x = 2, y = 1 函数作用域, 局部变量x与全局变量x123456789101112131415x = 5def set_x(num): # Local var x not the same as global variable x x = num # =&gt; 43 print(x) # =&gt; 43def set_global_x(num): global x print(x) # =&gt; 5 x = num # global var x is now set to 6 print(x) # =&gt; 6set_x(43)set_global_x(6) 匿名函数12(lambda x: x &gt; 2)(3) # =&gt; True(lambda x, y: x ** 2 + y ** 2)(2, 1) # =&gt; 5 python 还有很多内置的高阶函数12345list(map(max, [1, 2, 3], [4, 2, 1])) # =&gt; [4, 2, 3]list(filter(lambda x: x &gt; 5, [3, 4, 5, 6, 7])) # =&gt; [6, 7][x for x in [3, 4, 5, 6, 7] if x &gt; 5] # =&gt; [6, 7]&#123;x for x in 'abcddeef' if x not in 'abc'&#125; # =&gt; &#123;'d', 'e', 'f'&#125;&#123;x: x**2 for x in range(5)&#125; # =&gt; &#123;0: 0, 1: 1, 2: 4, 3: 9, 4: 16&#125; 5.模块Modules123456789import mathprint(math.sqrt(16)) # =&gt; 4.0from math import ceil, floorprint(ceil(3.7)) # =&gt; 4.0print(floor(3.7)) # =&gt; 3.0import math as mmath.sqrt(16) == m.sqrt(16) # =&gt; True 查看模块的功能和属性12import mathdir(math) 6.类Class12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# 创建一个类class Human: # 一个类属性。 它由此类的所有实例共享 species = \"H. sapiens\" # 基本初始值设定项，在实例化此类时调用。请注意，双前导和尾随下划线表示Python使用但存在于用户控制的命名空间中的对象或属性,方法（或对象或属性），如：__ init__，__ ttr__，__repr__ etc.被称为特殊方法（或有时称为dunder方法）不应该自己创建这些名称。 def __init__(self, name): # 将参数分配给实例的name属性 self.name = name # 初始化属性 self._age = 0 # 实例方法。 所有方法都将“self”作为第一个参数 def say(self, msg): print(\"&#123;name&#125;: &#123;message&#125;\".format(name=self.name, message=msg)) # 另一种实例方法 def sing(self): return 'yo... yo... microphone check... one two... one two...' # 所有实例共享一个类方法,它们以调用类作为第一个参数调用 @classmethod def get_species(cls): return cls.species # 在没有类或实例引用的情况下调用静态方法 @staticmethod def grunt(): return \"*grunt*\" # 一个属性就像一个getter.它将方法age（）转换为同名的只读属性。没有必要在Python中编写琐碎的getter和setter。 @property def age(self): return self._age # 允许设置属性 @age.setter def age(self, age): self._age = age # 允许删除属性 @age.deleter def age(self): del self._age# 当Python解释器读取源文件时，它会执行所有代码。__name__检查确保仅在此模块是主程序时才执行此代码块。if __name__ == '__main__': # 实例化一个类 i = Human(name=\"Ian\") i.say(\"hi\") # \"Ian: hi\" j = Human(\"Joel\") j.say(\"hello\") # \"Joel: hello\" # i和j是Human类型的实例，换句话说：它们是Human对象 # 调用我们的类方法 i.say(i.get_species()) # \"Ian: H. sapiens\" # 更改共享属性 Human.species = \"H. neanderthalensis\" i.say(i.get_species()) # =&gt; \"Ian: H. neanderthalensis\" j.say(j.get_species()) # =&gt; \"Joel: H. neanderthalensis\" # 调用静态方法 print(Human.grunt()) # =&gt; \"*grunt*\" # 无法使用对象实例调用静态方法 # 因为i.grunt（）会自动将“self”（对象i）作为参数 print(i.grunt()) # =&gt; TypeError: grunt() takes 0 positional arguments but 1 was given # 更新此实例的属性 i.age = 42 # 获取属性 i.say(i.age) # =&gt; \"Ian: 42\" j.say(j.age) # =&gt; \"Joel: 0\" # 删除该属性 del i.age # i.age # =&gt; this would raise an AttributeError inheritance类的继承","tags":[]},{"title":"python参数","date":"2017-11-25T05:11:12.000Z","path":"2017/11/25/python参数/","text":"文章出自 菜比之路 python参数*与**可变参数在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。 我们以数学题为例子，给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……。 要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下： 12345def calc(numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 但是调用的时候，需要先组装出一个list或tuple： 1234&gt;&gt;&gt; calc([1, 2, 3])14&gt;&gt;&gt; calc((1, 3, 5, 7))84 如果利用可变参数，调用函数的方式可以简化成这样： 1234&gt;&gt;&gt; calc(1, 2, 3)14&gt;&gt;&gt; calc(1, 3, 5, 7)84 所以，我们把函数的参数改为可变参数： 12345def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 定义可变参数和定义list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数： 1234&gt;&gt;&gt; calc(1, 2)5&gt;&gt;&gt; calc()0 如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做： 123&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])14 这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去： 123&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(*nums)14 这种写法相当有用，而且很常见。 关键字参数可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例： 12def person(name, age, **kw): print 'name:', name, 'age:', age, 'other:', kw 函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数： 12&gt;&gt;&gt; person('Michael', 30)name: Michael age: 30 other: &#123;&#125; 也可以传入任意个数的关键字参数： 1234&gt;&gt;&gt; person('Bob', 35, city='Beijing')name: Bob age: 35 other: &#123;'city': 'Beijing'&#125;&gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer')name: Adam age: 45 other: &#123;'gender': 'M', 'job': 'Engineer'&#125; 关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。 和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去： 123&gt;&gt;&gt; kw = &#123;'city': 'Beijing', 'job': 'Engineer'&#125;&gt;&gt;&gt; person('Jack', 24, city=kw['city'], job=kw['job'])name: Jack age: 24 other: &#123;'city': 'Beijing', 'job': 'Engineer'&#125; 当然，上面复杂的调用可以用简化的写法： 123&gt;&gt;&gt; kw = &#123;'city': 'Beijing', 'job': 'Engineer'&#125;&gt;&gt;&gt; person('Jack', 24, **kw)name: Jack age: 24 other: &#123;'city': 'Beijing', 'job': 'Engineer'&#125; 参数组合在Python中定义函数，可以用必选参数、默认参数、可变参数和关键字参数，这4种参数都可以一起使用，或者只用其中某些，但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。 比如定义一个函数，包含上述4种参数： 12def func(a, b, c=0, *args, **kw): print 'a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw 在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。 12345678&gt;&gt;&gt; func(1, 2)a = 1 b = 2 c = 0 args = () kw = &#123;&#125;&gt;&gt;&gt; func(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = &#123;&#125;&gt;&gt;&gt; func(1, 2, 3, 'a', 'b')a = 1 b = 2 c = 3 args = ('a', 'b') kw = &#123;&#125;&gt;&gt;&gt; func(1, 2, 3, 'a', 'b', x=99)a = 1 b = 2 c = 3 args = ('a', 'b') kw = &#123;'x': 99&#125; 最神奇的是通过一个tuple和dict，你也可以调用该函数： 1234&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = &#123;'x': 99&#125;&gt;&gt;&gt; func(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = &#123;'x': 99&#125; 所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。 小结Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。 默认参数一定要用不可变对象，如果是可变对象，运行会有逻辑错误！ 要注意定义可变参数和关键字参数的语法： *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 以及调用函数时如何传入可变参数和关键字参数的语法： 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))； 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{‘a’: 1, ‘b’: 2})。 使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。","tags":[]},{"title":"javascript组件化","date":"2017-10-28T12:46:39.000Z","path":"2017/10/28/javascript组件化/","text":"文章来源于purplebamboo的博客：https://github.com/purplebamboo/blog/issues/16 作为一名前端工程师，写组件的能力至关重要。虽然javascript经常被人嘲笑是个小玩具，但是在一代代大牛的前仆后继的努力下，渐渐的也摸索了一套组件的编写方式。 下面我们来谈谈，在现有的知识体系下，如何很好的写组件。 比如我们要实现这样一个组件，就是一个输入框里面字数的计数。这个应该是个很简单的需求。 我们来看看，下面的各种写法。 为了更清楚的演示，下面全部使用jQuery作为基础语言库。 最简陋的写法 嗯 所谓的入门级写法呢，就是完完全全的全局函数全局变量的写法。（就我所知，现在好多外包还是这种写法） 代码如下： 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;test&lt;/title&gt; &lt;script src=\"http://code.jquery.com/jquery-1.9.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function() &#123; var input = $('#J_input'); // 用来获取字数 function getNum()&#123; return input.val().length; &#125; // 渲染元素 function render()&#123; var num = getNum(); // 没有字数的容器就新建一个 if ($('#J_input_count').length == 0) &#123; input.after('&lt;span id=\"J_input_count\"&gt;&lt;/span&gt;'); &#125;; $('#J_input_count').html(num+'个字'); &#125; // 监听事件 input.on('keyup',function()&#123; render(); &#125;); // 初始化，第一次渲染 render(); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"text\" id=\"J_input\"/&gt;&lt;/body&gt;&lt;/html&gt; 这段代码跑也是可以跑的，但是呢，各种变量混乱，没有很好的隔离作用域,当页面变的复杂的时候,会很难去维护。目前这种代码基本是用不了的。当然少数的活动页面可以简单用用。 作用域隔离 让我们对上面的代码作些改动，使用单个变量模拟命名空间。 12345678910111213141516171819202122232425262728293031var textCount = &#123; input:null, init:function(config)&#123; this.input = $(config.id); this.bind(); // 这边范围对应的对象，可以实现链式调用 return this; &#125;, bind:function()&#123; var self = this; this.input.on('keyup',function()&#123; self.render(); &#125;); &#125;, getNum:function()&#123; return this.input.val().length; &#125;, // 渲染元素 render:function()&#123; var num = this.getNum(); if ($('#J_input_count').length == 0) &#123; this.input.after('&lt;span id=\"J_input_count\"&gt;&lt;/span&gt;'); &#125;; $('#J_input_count').html(num+'个字'); &#125;&#125;$(function() &#123; // 在domready后调用 textCount.init(&#123;id:'#J_input'&#125;).render();&#125;) 这样一改造，立马变的清晰了很多，所有的功能都在一个变量下面。代码更清晰，并且有统一的入口调用方法。 但是还是有些瑕疵，这种写法没有私有的概念，比如上面的getNum,bind应该都是私有的方法。但是其他代码可以很随意的改动这些。当代码量特别特别多的时候，很容易出现变量重复，或被修改的问题。 于是又出现了一种函数闭包的写法： 123456789101112131415161718192021222324252627282930var TextCount = (function()&#123; // 私有方法，外面将访问不到 var _bind = function(that)&#123; that.input.on('keyup',function()&#123; that.render(); &#125;); &#125; var _getNum = function(that)&#123; return that.input.val().length; &#125; var TextCountFun = function(config)&#123;&#125; TextCountFun.prototype.init = function(config) &#123; this.input = $(config.id); _bind(this); return this; &#125;; TextCountFun.prototype.render = function() &#123; var num = _getNum(this); if ($('#J_input_count').length == 0) &#123; this.input.after('&lt;span id=\"J_input_count\"&gt;&lt;/span&gt;'); &#125;; $('#J_input_count').html(num+'个字'); &#125;; // 返回构造函数 return TextCountFun;&#125;)();$(function() &#123; new TextCount().init(&#123;id:'#J_input'&#125;).render();&#125;) 这种写法，把所有的东西都包在了一个自动执行的闭包里面，所以不会受到外面的影响，并且只对外公开了TextCountFun构造函数，生成的对象只能访问到init,render方法。这种写法已经满足绝大多数的需求了。事实上大部分的jQuery插件都是这种写法。 面向对象 上面的写法已经可以满足绝大多数需求了。 但是呢，当一个页面特别复杂，当我们需要的组件越来越多，当我们需要做一套组件。仅仅用这个就不行了。首先的问题就是，这种写法太灵活了，写单个组件还可以。如果我们需要做一套风格相近的组件，而且是多个人同时在写。那真的是噩梦。 在编程的圈子里，面向对象一直是被认为最佳的编写代码方式。比如java，就是因为把面向对象发挥到了极致，所以多个人写出来的代码都很接近，维护也很方便。但是很不幸的是，javascript不支持class类的定义。但是我们可以模拟。 下面我们先实现个简单的javascript类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209var Class = (function() &#123; var _mix = function(r, s) &#123; for (var p in s) &#123; if (s.hasOwnProperty(p)) &#123; r[p] = s[p] &#125; &#125; &#125; var _extend = function() &#123; // 开关 用来使生成原型时,不调用真正的构成流程init this.initPrototype = true; var prototype = new this(); this.initPrototype = false; var items = Array.prototype.slice.call(arguments) || []; var item; // 支持混入多个属性，并且支持&#123;&#125;也支持 Function while (item = items.shift()) &#123; _mix(prototype, item.prototype || item); &#125; // 这边是返回的类，其实就是我们返回的子类 function SubClass() &#123; if (!SubClass.initPrototype &amp;&amp; this.init); this.init.apply(this, arguments); // 调用init真正的构造函数 &#125; // 赋值原型链，完成继承 SubClass.prototype = prototype // 改变constructor引用 SubClass.prototype.constructor = SubClass // 为子类也添加extend方法 SubClass.extend = _extend return SubClass &#125; // 超级父类 var Class = function() &#123;&#125; // 为超级父类添加extend方法 Class.extend = _extend return Class&#125;)()``` 这是拿John Resig的class简单修改了下。这边只是很简陋的实现了类的继承机制。如果对类的实现有兴趣可以参考我另一篇文章[javascript oo](http://purplebamboo.github.io/2014/07/13/javascript-oo-class/)实现我们看下使用方法：``` js// 继承超级父类，生成个子类Animal，并且混入一些方法。这些方法会到Animal的原型上。// 另外这边不仅支持混入&#123;&#125;，还支持混入Functionvar Animal = Class.extend(&#123; init:function(opts)&#123; this.msg = opts.msg this.type = \"animal\" &#125;, say:function()&#123; alert(this.msg+\":i am a \"+this.type) &#125;&#125;)// 继承Animal，并且混入一些方法var Dog = Animal.extend(&#123; init:function(opts)&#123; //并未实现super方法，直接简单使用父类原型调用即可 Animal.prototype.init.call(this,opts) //修改了type类型 this.type = \"dog\" &#125;&#125;)//new Animal(&#123;msg:'hello'&#125;).say()new Dog(&#123;msg:'hi'&#125;).say()``` 使用很简单，超级父类具有extend方法，可以继承出一个子类。子类也具有extend方法。这边要强调的是，继承的父类都是一个也就是单继承。但是可以通过extend实现多重混入。详见下面用法。有了这个类的扩展，我们可以这么编写代码了：``` jsvar TextCount = Class.extend(&#123; init:function(config)&#123; this.input = $(config.id); this._bind(); this.render(); &#125;, render:function() &#123; var num = this._getNum(); if ($('#J_input_count').length == 0) &#123; this.input.after('&lt;span id=\"J_input_count\"&gt;&lt;/span&gt;'); &#125;; $('#J_input_count').html(num+'个字'); &#125;, _getNum:function()&#123; return this.input.val().length; &#125;, _bind:function()&#123; var self = this; self.input.on('keyup',function()&#123; self.render(); &#125;); &#125;&#125;)$(function() &#123; new TextCount(&#123; id:\"#J_input\" &#125;);&#125;)``` 这边可能还没看见class的真正好处，不急我们继续往下。抽象出base------------可以看到，我们的组件有些方法，是大部分组件都会有的。比如init用来初始化属性。比如render用来处理渲染的逻辑。比如bind用来处理事件的绑定。当然这也是一种约定俗成的规范了。如果大家全部按照这种风格来写代码，开发大规模组件库就变得更加规范，相互之间配合也更容易。这个时候面向对象的好处就来了，我们抽象出一个Base类。其他组件编写时都继承它。``` jsvar Base = Class.extend(&#123; init:function(config)&#123; // 自动保存配置项 this.__config = config this.bind() this.render() &#125;, // 可以使用get来获取配置项 get:function(key)&#123; return this.__config[key] &#125;, // 可以使用set来设置配置项 set:function(key,value)&#123; this.__config[key] = value &#125;, bind:function()&#123; &#125;, render:function() &#123; &#125;, // 定义销毁的方法，一些收尾工作都应该在这里 destroy:function()&#123; &#125;&#125;)``` base类主要把组件的一般性内容都提取了出来，这样我们编写组件时可以直接继承base类，覆盖里面的bind和render方法。于是我们可以这么写代码：``` jsvar TextCount = Base.extend(&#123; _getNum:function()&#123; return this.get('input').val().length; &#125;, bind:function()&#123; var self = this; self.get('input').on('keyup',function()&#123; self.render(); &#125;); &#125;, render:function() &#123; var num = this._getNum(); if ($('#J_input_count').length == 0) &#123; this.get('input').after('&lt;span id=\"J_input_count\"&gt;&lt;/span&gt;'); &#125;; $('#J_input_count').html(num+'个字'); &#125;&#125;)$(function() &#123; new TextCount(&#123; // 这边直接传input的节点了，因为属性的赋值都是自动的。 input:$(\"#J_input\") &#125;);&#125;)``` 可以看到我们直接实现一些固定的方法，bind，render就行了。其他的base会自动处理（这里只是简单处理了配置属性的赋值）。事实上，这边的init，bind，render就已经有了点生命周期的影子，但凡是组件都会具有这几个阶段，初始化，绑定事件，以及渲染。当然这边还可以加一个destroy销毁的方法，用来清理现场。此外为了方便，这边直接变成了传递input的节点。因为属性赋值自动化了，一般来说这种情况下都是使用getter，setter来处理。这边就不详细展开了。引入事件机制（观察者模式）----------------------有了base应该说我们编写组件更加的规范化，体系化了。下面我们继续深挖。还是上面的那个例子，如果我们希望输入字的时候超过5个字就弹出警告。该怎么办呢。小白可能会说，那简单啊直接改下bind方法：``` js var TextCount = Base.extend(&#123; ... bind:function()&#123; var self = this; self.get('input').on('keyup',function()&#123; if(self._getNum() &gt; 5)&#123; alert('超过了5个字了。。。') &#125; self.render(); &#125;); &#125;, ...&#125;) 的确也是一种方法，但是太low了，代码严重耦合。当这种需求特别特别多，代码会越来越乱。 这个时候就要引入事件机制，也就是经常说的观察者模式。 注意这边的事件机制跟平时的浏览器那些事件不是一回事，要分开来看。什么是观察者模式呢，官方的解释就不说了，直接拿这个例子来说。 想象一下base是个机器人会说话，他会一直监听输入的字数并且汇报出去（通知）。而你可以把耳朵凑上去，听着他的汇报（监听）。发现字数超过5个字了，你就做些操作。 所以这分为两个部分，一个是通知，一个是监听。 假设通知是 fire方法，监听是on。于是我们可以这么写代码： 12345678910111213141516171819202122232425var TextCount = Base.extend(&#123; ... bind:function()&#123; var self = this; self.get('input').on('keyup',function()&#123; //通知,每当有输入的时候，就报告出去。 self.fire('Text.input',self._getNum()) self.render(); &#125;); &#125;, ...&#125;)$(function() &#123; var t = new TextCount(&#123; input:$(\"#J_input\") &#125;); //监听这个输入事件 t.on('Text.input',function(num)&#123; //可以获取到传递过来的值 if(num&gt;5)&#123; alert('超过了5个字了。。。') &#125; &#125;)&#125;) fire用来触发一个事件，可以传递数据。而on用来添加一个监听。这样组件里面只负责把一些关键的事件抛出来，至于具体的业务逻辑都可以添加监听来实现。没有事件的组件是不完整的。 下面我们看看怎么实现这套事件机制。 我们首先抛开base，想想怎么实现一个具有这套机制的类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//辅组函数，获取数组里某个元素的索引 indexvar _indexOf = function(array,key)&#123; if (array === null) return -1 var i = 0, length = array.length for (; i &lt; length; i++) if (array[i] === item) return i return -1&#125;var Event = Class.extend(&#123; //添加监听 on:function(key,listener)&#123; //this.__events存储所有的处理函数 if (!this.__events) &#123; this.__events = &#123;&#125; &#125; if (!this.__events[key]) &#123; this.__events[key] = [] &#125; if (_indexOf(this.__events,listener) === -1 &amp;&amp; typeof listener === 'function') &#123; this.__events[key].push(listener) &#125; return this &#125;, //触发一个事件，也就是通知 fire:function(key)&#123; if (!this.__events || !this.__events[key]) return var args = Array.prototype.slice.call(arguments, 1) || [] var listeners = this.__events[key] var i = 0 var l = listeners.length for (i; i &lt; l; i++) &#123; listeners[i].apply(this,args) &#125; return this &#125;, //取消监听 off:function(key,listener)&#123; if (!key &amp;&amp; !listener) &#123; this.__events = &#123;&#125; &#125; //不传监听函数，就去掉当前key下面的所有的监听函数 if (key &amp;&amp; !listener) &#123; delete this.__events[key] &#125; if (key &amp;&amp; listener) &#123; var listeners = this.__events[key] var index = _indexOf(listeners, listener) (index &gt; -1) &amp;&amp; listeners.splice(index, 1) &#125; return this; &#125;&#125;)var a = new Event()//添加监听 test事件a.on('test',function(msg)&#123; alert(msg)&#125;)//触发 test事件a.fire('test','我是第一次触发')a.fire('test','我又触发了')a.off('test')a.fire('test','你应该看不到我了') 实现起来并不复杂，只要使用this.__events存下所有的监听函数。在fire的时候去找到并且执行就行了。 这个时候面向对象的好处就来了，如果我们希望base拥有事件机制。只需要这么写: 123456789101112var Base = Class.extend(Event,&#123; ... destroy:function()&#123; //去掉所有的事件监听 this.off() &#125;&#125;)//于是可以//var a = new Base()// a.on(xxx,fn)//// a.fire() 是的只要extend的时候多混入一个Event，这样Base或者它的子类生成的对象都会自动具有事件机制。 有了事件机制我们可以把组件内部很多状态暴露出来，比如我们可以在set方法中抛出一个事件，这样每次属性变更的时候我们都可以监听到。 到这里为止，我们的base类已经像模像样了，具有了init，bind，render，destroy方法来表示组件的各个关键过程，并且具有了事件机制。基本上已经可以很好的来开发组件了。 更进一步，richbase 我们还可以继续深挖。看看我们的base，还差些什么。首先浏览器的事件监听还很落后，需要用户自己在bind里面绑定，再然后现在的TextCount里面还存在dom操作，也没有自己的模板机制。这都是需要扩展的，于是我们在base的基础上再继承出一个richbase用来实现更完备的组件基类。 主要实现这些功能： 事件代理：不需要用户自己去找dom元素绑定监听，也不需要用户去关心什么时候销毁。模板渲染：用户不需要覆盖render方法，而是覆盖实现setUp方法。可以通过在setUp里面调用render来达到渲染对应html的目的。单向绑定：通过setChuckdata方法，更新数据，同时会更新html内容，不再需要dom操作。我们看下我们实现richbase后怎么写组件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180var TextCount = RichBase.extend(&#123; //事件直接在这里注册，会代理到parentNode节点，parentNode节点在下面指定 EVENTS:&#123; //选择器字符串，支持所有jQuery风格的选择器 'input':&#123; //注册keyup事件 keyup:function(self,e)&#123; //单向绑定，修改数据直接更新对应模板 self.setChuckdata('count',self._getNum()) &#125; &#125; &#125;, //指定当前组件的模板 template:'&lt;span id=\"J_input_count\"&gt;&lt;%= count %&gt;个字&lt;/span&gt;', //私有方法 _getNum:function()&#123; return this.get('input').val().length || 0 &#125;, //覆盖实现setUp方法，所有逻辑写在这里。最后可以使用render来决定需不需要渲染模板 //模板渲染后会append到parentNode节点下面，如果未指定，会append到document.body setUp:function()&#123; var self = this; var input = this.get('parentNode').find('#J_input') self.set('input',input) var num = this._getNum() //赋值数据，渲染模板，选用。有的组件没有对应的模板就可以不调用这步。 self.render(&#123; count:num &#125;) &#125;&#125;)$(function() &#123; //传入parentNode节点，组件会挂载到这个节点上。所有事件都会代理到这个上面。 new TextCount(&#123; parentNode:$(\"#J_test_container\") &#125;);&#125;)/**对应的html,做了些修改，主要为了加上parentNode，这边就是J_test_container&lt;div id=\"J_test_container\"&gt; &lt;input type=\"text\" id=\"J_input\"/&gt;&lt;/div&gt;*/``` 看下上面的用法，可以看到变得更简单清晰了： 1.事件不需要自己绑定，直接注册在EVENTS属性上。程序会自动将事件代理到parentNode上。 2.引入了模板机制，使用template规定组件的模板，然后在setUp里面使用render(data)的方式渲染模板，程序会自动帮你append到parentNode下面。 3.单向绑定，无需操作dom，后面要改动内容，不需要操作dom，只需要调用setChuckdata(key,新的值)，选择性的更新某个数据，相应的html会自动重新渲染。下面我们看下richebase的实现：``` jsvar RichBase = Base.extend(&#123; EVENTS:&#123;&#125;, template:'', init:function(config)&#123; //存储配置项 this.__config = config //解析代理事件 this._delegateEvent() this.setUp() &#125;, //循环遍历EVENTS，使用jQuery的delegate代理到parentNode _delegateEvent:function()&#123; var self = this var events = this.EVENTS || &#123;&#125; var eventObjs,fn,select,type var parentNode = this.get('parentNode') || $(document.body) for (select in events) &#123; eventObjs = events[select] for (type in eventObjs) &#123; fn = eventObjs[type] parentNode.delegate(select,type,function(e)&#123; fn.call(null,self,e) &#125;) &#125; &#125; &#125;, //支持underscore的极简模板语法 //用来渲染模板，这边是抄的underscore的。非常简单的模板引擎，支持原生的js语法 _parseTemplate:function(str,data)&#123; /** * http://ejohn.org/blog/javascript-micro-templating/ * https://github.com/jashkenas/underscore/blob/0.1.0/underscore.js#L399 */ var fn = new Function('obj', 'var p=[],print=function()&#123;p.push.apply(p,arguments);&#125;;' + 'with(obj)&#123;p.push(\\'' + str .replace(/[\\r\\t\\n]/g, \" \") .split(\"&lt;%\").join(\"\\t\") .replace(/((^|%&gt;)[^\\t]*)'/g, \"$1\\r\") .replace(/\\t=(.*?)%&gt;/g, \"',$1,'\") .split(\"\\t\").join(\"');\") .split(\"%&gt;\").join(\"p.push('\") .split(\"\\r\").join(\"\\\\'\") + \"');&#125;return p.join('');\") return data ? fn(data) : fn &#125;, //提供给子类覆盖实现 setUp:function()&#123; this.render() &#125;, //用来实现刷新，只需要传入之前render时的数据里的key还有更新值，就可以自动刷新模板 setChuckdata:function(key,value)&#123; var self = this var data = self.get('__renderData') //更新对应的值 data[key] = value if (!this.template) return; //重新渲染 var newHtmlNode = $(self._parseTemplate(this.template,data)) //拿到存储的渲染后的节点 var currentNode = self.get('__currentNode') if (!currentNode) return; //替换内容 currentNode.replaceWith(newHtmlNode) self.set('__currentNode',newHtmlNode) &#125;, //使用data来渲染模板并且append到parentNode下面 render:function(data)&#123; var self = this //先存储起来渲染的data,方便后面setChuckdata获取使用 self.set('__renderData',data) if (!this.template) return; //使用_parseTemplate解析渲染模板生成html //子类可以覆盖这个方法使用其他的模板引擎解析 var html = self._parseTemplate(this.template,data) var parentNode = this.get('parentNode') || $(document.body) var currentNode = $(html) //保存下来留待后面的区域刷新 //存储起来，方便后面setChuckdata获取使用 self.set('__currentNode',currentNode) parentNode.append(currentNode) &#125;, destroy:function()&#123; var self = this //去掉自身的事件监听 self.off() //删除渲染好的dom节点 self.get('__currentNode').remove() //去掉绑定的代理事件 var events = self.EVENTS || &#123;&#125; var eventObjs,fn,select,type var parentNode = self.get('parentNode') for (select in events) &#123; eventObjs = events[select] for (type in eventObjs) &#123; fn = eventObjs[type] parentNode.undelegate(select,type,fn) &#125; &#125; &#125;&#125;) 主要做了两件事，一个就是事件的解析跟代理，全部代理到parentNode上面。另外就是把render抽出来，用户只需要实现setUp方法。如果需要模板支持就在setUp里面调用render来渲染模板，并且可以通过setChuckdata来刷新模板，实现单向绑定。 结语 有了richbase，基本上组件开发就没啥问题了。但是我们还是可以继续深挖下去。 比如组件自动化加载渲染，局部刷新，比如父子组件的嵌套，再比如双向绑定，再比如实现ng-click这种风格的事件机制。 当然这些东西已经不属于组件里面的内容了。再进一步其实已经是一个框架了。实际上最近比较流行的react，ploymer还有我们的brix等等都是实现了这套东西。受限于篇幅，这个以后有空再写篇文章详细分析下。 鉴于有人跟我要完整代码，其实上面都列出来了。好吧 那我就再整理下，放在github了包含具体的demo，请点这里。","tags":[]},{"title":"我的FCC项目","date":"2017-10-20T01:42:56.000Z","path":"2017/10/20/我的FCC项目/","text":"我的codepen地址：https://codepen.io/Sherry728/","tags":[]},{"title":"科学上网","date":"2017-10-19T06:52:17.000Z","path":"2017/10/19/科学上网/","text":"科学上网：用 VPS 搭建 shadowsocks 服务器 目前 shadowsocks 服务已经受到了影响，不过部署在 25 端口目前还可用。 仍然可以通过 ubuntu 的 apt-get 获取到 shadowsocks 服务端，windows、Mac OS X、Android 客户端的 release 下载链接仍然保留。因此在写作本文时，shadowsocks 还是可以使用的。 shadowsocks 简介shadowsocks 是一款自定义协议的代理软件，由于其流量特征不明显，（直到不久前）一直可以稳定提供上网代理。 shadowsocks 客户端会在本地开启一个 socks5 代理，通过此代理的网络访问请求由客户端发送至服务端，服务端发出请求，收到响应数据后再发回客户端。 因此使用 shadowsocks 需要一台墙外的服务器来部署 shadowsocks 服务端。 购买 VPS 服务器主流的 VPS（虚拟主机）服务器提供商有三家： linodedigital oceanbandwagon下面的比上面的便宜。如果只是自用，bandwagon 足够。 一般使用 paypal 绑定一个 visa 或 mastercard 信用卡来付款。注意要用国际 paypal 帐号，国内的是不能用外币付款的。 在 bandwagon 购买 VPS 以后会获得一个主机地址和用于 ssh 登录的 root 密码。 远程登陆 VPSMac OS X 或 Linux 下直接在终端中 ssh root@your_vps_ip -p your_ssh_port 即可。 在 windows 系统下需要专门的客户端来 SSH 登录 VPS。在 xShell 官网 下载 xShell。 家庭和学校用户可以免费试用，下载时选择 home and school use 即可。需要用邮箱注册一下，下载链接会发送到邮箱中。 xShell 中新建一个连接，会要求输入目标 IP 地址和端口，以及 root 密码，按提示操作即可。 安装 shadowsocks打开 shell，使用 VPS 服务商提供的 root 用户和密码 SSH 登录 VPS。然后执行如下命令： Debian/Ubuntu: apt-get install python-pip pip install shadowsocks CentOS: yum install python-setuptools &amp;&amp; easy_install pip pip install shadowsocks shadowsocks 就安装好了。 有时 Ubuntu 会遇到第一个命令安装 python-pip 时找不到包的情况。pip 官方给出了一个安装脚本，可以自动安装 pip。先下载脚本，然后执行即可： wget https://bootstrap.pypa.io/get-pip.py python get-pip.py 编写配置文件shadowsocks 启动时的参数，如服务器端口，代理端口，登录密码等，可以通过启动时的命令行参数来设定，也可以通过 json 格式的配置文件设定。推荐使用配置文件，方便查看和修改。 用 vi 新建一个配置文件： vi /etc/shadowsocks.json 然后输入如下内容： { &quot;server&quot;:&quot;my_server_ip&quot;, &quot;server_port&quot;:25, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;mypassword&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false } 保存退出。 配置文件中个字段的含义： server: 服务器ip地址server_port: 绑定的端口，注意不要设置已经使用了的端口possword: 密码timeout: 超时时间method: 加密方法fast_open: 如果你的服务器 Linux 内核在3.7+，可以开启 fast_open 以降低延迟workers: 默认为1 如果需要配置多个SS账号，可以按照如下案例进行配置： { &quot;server&quot;:&quot;your_server_ip&quot;, &quot;port_password&quot;:{ &quot;8381&quot;:&quot;password1&quot;, &quot;8382&quot;:&quot;password2&quot;, &quot;8383&quot;:&quot;password3&quot;, &quot;8384&quot;:&quot;password4&quot; }, &quot;timeout&quot;:300, &quot;method&quot;:&quot;rc4-md5&quot;, &quot;fast_open&quot;:false, &quot;workers&quot;:1 } 启动 shadowsocks如果已经写好了配置文件，启动 shadowsocks 服务器的命令如下： ssserver -c /etc/shadowsocks.json 后台启动和停止 shadowsocks 服务器： ssserver -c /etc/shadowsocks.json -d start ssserver -c /etc/shadowsocks.json -d stop shadowsocks 的日志保存在 /var/log/shadowsocks.log 安装并启动 shadowsocks 客户端 shadowsocks 支持 windows、Mac OS X、Linux、Android、iOS 等多个平台。不过 iOS 由于系统对应用后台运行的限制，推荐使用客户端内嵌的浏览器科学上网，给其他应用代理时需要每过几分钟重新启动一下 app。 shadowsocks 项目 Github 主页在这里。 里面可以找到客户端下载地址。 下载安装客户端以后，只需按服务器的配置填写 IP 地址、服务器端口、本地端口（如果没有本地端口选项，就是默认的 1080）、密码、加密方式等参数，启动就可以了。 客户端支持全局代理和 PAC 代理两种方式，后者会使用一个脚本来自动检查一个网站是否在需要代理的网站列表中，自动选择直接连接或代理连接。 PAC 列表可以在线更新，但是难免有收录不全的情况。这时可以选择关闭 shadowsocks 代理（实际上是取消对系统代理的配置，shadowsocks 客户端仍然保持工作），然后使用支持自定义规则的代理管理插件来实现自动切换代理，比如 switchyOmega。 使用 switchyOmega 实现自动切换代理switchyOmega 是 chrome 浏览器上一个很好用的代理管理插件。它的前身 switchySharp 更有名。 chrome 应用商店本身需要翻墙才能访问，因此需要先在 shadowsocks 启动代理模式下下载安装，再关闭 shadowsocks 代理。 安装完毕后，右击 switchyOmega 图标，选择选项，进入 switchOmega 配置界面。 创建 shadowsocks 情景模式 新建一个情景模式，比如叫 SS，代理协议选择 socks5，代理地址为 127.0.0.1，端口 1080。 现在切换到 SS 情景模式就可以通过 shadowsocks 科学上网了。后面获取自动切换规则列表 设置自动切换模式 在设置界面选择自动切换模式，在 “切换规则” 中勾选“规则列表规则”，对应的情景模式选择刚刚新建的 SS。 然后在下面的规则列表地址中填写 https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt 规则列表格式选择 AutoProxy。 然后点击立即更新情景模式， 更新完成后会有提示。 点击左侧的 “应用选项”。然后单击 switchyOmega 图标，选择自动切换，就可以在访问“不存在的网站” 时自动切换到 shadowsocks 代理了。 添加自定义规则 如果遇到某个国外网站无法直接连接或速度太慢时，可以单击 switchyOmega 图标，选择 “添加条件”，情景模式选择 SS，就可以了。 这时打开 switchyOmega 选项，在自动切换模式的切换规则中就可以看到刚刚添加的规则。可以在这里管理自定义的规则。 导入和导出 switchyOmega 设置 如果换了一台电脑，重新设置一遍 switchyOmega 就太麻烦了。可以在设置好的 switchyOmega 中导出设置文件，在另一个 chrome 浏览器中导入，就可以直接复制原来的设置了。 在 switchyOmega 选项的左侧点击 “导入 / 导出”，点击“生成备份文件” 即可生成 switchyOmega 设置备份。点击 “从备份文件恢复” 可以导入备份文件。 (apt install shadowsocks-libev ) 坑： 1.远程连接ubuntu系统时，可能会出现如下错误： @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that a host key has just been changed. The fingerprint for the ECDSA key sent by the remote host is SHA256:JHdZe0uj0FNj0PzyxFFNGZ5TU4M0aY/HsyTRON2CgQ4. Please contact your system administrator. Add correct host key in /Users/*****/.ssh/known_hosts to get rid of this message. Offending ECDSA key in /Users/*****/.ssh/known_hosts:6 ECDSA host key for 45.77.195.128 has changed and you have requested strict checking. 这种情况可能是因为已经登陆过，但是你修改过了ubuntu系统的信息，导致ssh信息不一致，只需要找到.ssh文件（Mac系统里面使用command+shift+.来显示隐藏文件，一般.ssh文件就在个人文件夹里面），删除对应的ip信息就好。 2.在pip install shadowsocks时会出现error： ImportError: No module named setuptools 解决办法： wget http://pypi.python.org/packages/source/s/setuptools/setuptools-0.6c11.tar.gz tar zxvf setuptools-0.6c11.tar.gz cd setuptools-0.6c11 python setup.py build python setup.py install 3.error: invalid command ‘bdist_wheel’ 解决办法： pip install setuptools --upgrade","tags":[{"name":"科学上网","slug":"科学上网","permalink":"https://shleyz.github.io/tags/科学上网/"}]},{"title":"Webpack","date":"2017-10-16T07:02:14.000Z","path":"2017/10/16/Webpack/","text":"webpack 是一个现代 JavaScript 应用程序的模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成少量的 bundle - 通常只有一个，由浏览器加载。 1.安装webpack 新建一个文件夹webpack npm init 此时最好把package.json中的name改掉，不能是webpack，否则局部安装webpack时会报错。改为webpack-test。 npm install webpack --save-dev 用编辑器打开 npm install css-loader style-loader –save-dev 2.webpack使用 入口:告诉 webpack 从哪里开始，并根据依赖关系图确定需要打包的内容。可以将应用程序的入口起点认为是根上下文(contextual root) 或 app 第一个启动文件。 出口:将所有的资源(assets)归拢在一起后，还需要告诉 webpack 在哪里打包应用程序。webpack 的 output 属性描述了如何处理归拢在一起的代码(bundled code)。 Loader:webpack 把每个文件(.css, .html, .scss, .jpg, etc.) 都作为模块处理。然而 webpack 自身只理解 JavaScript。webpack loader 在文件被添加到依赖图中时，其转换为模块。(loader的作用：1.识别需要转换的文件，2.转换这些文件，从而使这些文件添加到依赖图)。 插件:webpack 的插件系统极其强大和可定制化。要使用一个插件，需要先require它，再把它添加到plugin数组中。 下面是webpack.config.js: const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //installed via npm const webpack = require(&apos;webpack&apos;); //to access built-in plugins const path = require(&apos;path&apos;); const config = { entry: &apos;./path/to/my/entry/file.js&apos;, output: { path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; }, module: { rules: [ { test: /\\.txt$/, use: &apos;raw-loader&apos; } ] }, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin({template: &apos;./src/index.html&apos;}) ] }; module.exports = config; 入口单个入口： const config = { entry: { main: &apos;./path/to/my/entry/file.js&apos; } }; 多个入口（对象形式）： const config = { entry: { app: &apos;./src/app.js&apos;, vendors: &apos;./src/vendors.js&apos; } }; 分离 应用程序(app) 和 第三方库(vendor) 入口。（或者多页面应用程序） 输出output即使可以存在多个入口起点，但只指定一个输出配置。 在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点： filename 用于输出文件的文件名。 目标输出目录 path 的绝对路径。 const config = { output: { path: &apos;/home/proj/public/assets&apos;, filename: &apos;bundle.js&apos; } } 如果有多个入口，应该使用占位符(substitutions)来确保每个文件具有唯一的名称： { entry: { app: &apos;./src/app.js&apos;, vendors: &apos;./src/vendors.js&apos; } output: { filename: &apos;[name].js&apos;, path: __dirname + bundle.js } } // 写入到硬盘：./dist/app.js, ./dist/search.js loader对模块的源代码进行转换。 loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ module.exports = { entry: { … }, output: { … }, module: { rules:[ {test: /.css$/, use: ‘css-loader’}, {test:/.ts$/, use: ‘ts-loader’} ] } } loader的使用方法有三种： 1.推荐配置webpack.config.js module: { rules: [ { test: /\\.css$/, use: [ { loader: &apos;style-loader&apos; }, { loader: &apos;css-loader&apos;, options: { modules: true } } ] } ] } 2.内联 import Styles from &apos;style-loader!css-loader?modules!./styles.css&apos;; 3.CLI(webpack命令行借口) webpack --module-bind jade-loader --module-bind &apos;css=style-loader!css-loader&apos; 插件插件是webpack的支柱功能，目的是解决loader无法实现的事情。 用法： webpack 配置中，向 plugins 属性传入 new 实例。 plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin({template: &apos;./src/index.html&apos;}) ] 配置1.通过require(…)导入其他文件2.通过require(…)使用npm的工具函数3.使用JS的控制流表达式4.对常用值使用常量或者变量5.编写并执行函数来生成部分配置 模块在模块化编程中，开发者将程序分解成离散功能块，称为模块。","tags":[]},{"title":"python题目","date":"2017-10-14T05:27:40.000Z","path":"2017/10/14/python题目/","text":"1.打印多行字符串： 123456&gt;&gt;&gt; print('''line1... line2... line3''')line1line2line3 2.练习格式化字符串的使用： 12&gt;&gt;&gt; 'Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%'.format('小明', 17.125)'Hello, 小明, 成绩提升了 17.1%' 3.小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数： 低于18.5：过轻18.5-25：正常25-28：过重28-32：肥胖高于32：严重肥胖用if-elif判断并打印结果： 1234567891011121314151617# -*- coding: utf-8 -*-height = 1.75weight = 80.5bmi = weight/(height*height)if bmi&lt;18.5: print('过轻')elif bmi&lt;25: print('正常')elif bmi&lt;28: print('过重')elif bmi&lt;32: print('肥胖')else: print('严重肥胖')&gt;&gt;&gt;过重 4.请利用循环依次对list中的每个名字打印出Hello, xxx!： 123456789# -*- coding: utf-8 -*-L = ['Bart', 'Lisa', 'Adam']for i in L: print('hello,',i)&gt;&gt;&gt; hello, Bart&gt;&gt;&gt; hello, Lisa&gt;&gt;&gt; hello, Adam 5.请利用Python内置的hex()函数把一个整数转换成十六进制表示的字符串： 123456789# -*- coding: utf-8 -*-n1 = 255n2 = 1000print('n1转换成十六进制：%s'% (hex(n1)))print('n2转换成十六进制：%s'% (hex(n2)))&gt;&gt;&gt; n1转换成十六进制：0xff&gt;&gt;&gt; n2转换成十六进制：0x3e8 6.请定义一个函数quadratic(a, b, c)，接收3个参数，返回一元二次方程：ax2 + bx + c = 0的两个解。 提示：计算平方根可以调用math.sqrt()函数： 12345678910111213141516# -*- coding: utf-8 -*-import mathdef quadratic(a, b, c): deta = b*b - 4*a*c if deta == 0: return -b/(2*a) elif deta &lt; 0: print('无解') return else: x1 = (-b + math.sqrt(deta))/(2*a) x2 = (-b - math.sqrt(deta))/(2*a) return x1,x2 7.一个函数：可接收一个或多个参数并计算乘积 123456789# -*- coding: utf-8 -*-def product(x,*y): result = x if len(y)==0: return result else: for i in y: result = result * i return result 8.汉诺塔的移动可以用递归函数非常简单地实现。 请编写move(n, a, b, c)函数，它接收参数n，表示3个柱子A、B、C中第1个柱子A的盘子数量，然后打印出把所有盘子从A借助B移动到C的方法，例如： 123456789101112131415161718move(3, 'A', 'B', 'C')# 期待输出:# A --&gt; C# A --&gt; B# C --&gt; B# A --&gt; C# B --&gt; A# B --&gt; C# A --&gt; C# -*- coding: utf-8 -*-def move(n, a, b, c): if n == 1: print(a, '--&gt;', c) else: move(n-1,a,c,b) move(1,a,b,c) move(n-1,b,a,c) 9.利用切片操作，实现一个trim()函数，去除字符串首尾的空格，注意不要调用str的strip()方法： 1234567# -*- coding: utf-8 -*-def trim(s): while s[0:1] == ' ': s = s[1:] while s[-1:] == ' ': s = s[:-1] return s 10.请使用迭代查找一个list中最小和最大值，并返回一个tuple： 123456789101112# -*- coding: utf-8 -*-def findMinAndMax(L): if len(L) == 0: return None,None max_value = L[0] min_value = L[0] for i in L: if max_value &lt; i: max_value = i if min_value &gt; i: min_value = i return min_value,max_value 11.请修改列表生成式，通过添加if语句保证列表生成式能正确地执行： 12345678910# -*- coding: utf-8 -*-L1 = ['Hello', 'World', 18, 'Apple', None]L2 = [i.lower() for i in L1 if isinstance(i,str)]# 测试:print(L2)if L2 == ['hello', 'world', 'apple']: print('测试通过!')else: print('测试失败!') 12.杨辉三角定义如下： 1 / \\ 1 1 / \\ / \\ 1 2 1 / \\ / \\ / \\ 1 3 3 1 / \\ / \\ / \\ / \\ 1 4 6 4 1 / \\ / \\ / \\ / \\ / \\1 5 10 10 5 1 把每一行看做一个list，试写一个生成器generator，不断输出下一行的list： 12345678910111213141516171819202122232425# -*- coding: utf-8 -*-def triangles(): result = [1] while True: yield result result = [result[x] + result[x+1] for x in range(len(result)-1)] result.append(1) result.insert(0,1) if n&gt;10: break``` 输出:``` python&gt;&gt;&gt; [1]&gt;&gt;&gt; [1, 1]&gt;&gt;&gt; [1, 2, 1]&gt;&gt;&gt; [1, 3, 3, 1]&gt;&gt;&gt; [1, 4, 6, 4, 1]&gt;&gt;&gt; [1, 5, 10, 10, 5, 1]&gt;&gt;&gt; [1, 6, 15, 20, 15, 6, 1]&gt;&gt;&gt; [1, 7, 21, 35, 35, 21, 7, 1]&gt;&gt;&gt; [1, 8, 28, 56, 70, 56, 28, 8, 1]&gt;&gt;&gt; [1, 9, 36, 84, 126, 126, 84, 36, 9, 1] 13.利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[‘adam’, ‘LISA’, ‘barT’]，输出：[‘Adam’, ‘Lisa’, ‘Bart’]： 12345678910# -*- coding: utf-8 -*-def normalize(name): return name[0].upper()+name[1:].lower()# 测试:L1 = ['adam', 'LISA', 'barT']L2 = list(map(normalize, L1))print(L2)&gt;&gt;&gt;['Adam', 'Lisa', 'Bart'] 14.编写一个prod()函数，可以接受一个list并利用reduce()求积： 1234# -*- coding: utf-8 -*-from functools import reducedef prod(L): return reduce(lambda x, y : x * y, L) 15.利用map和reduce编写一个str2float函数，把字符串’123.456’转换成浮点数123.456： 12345678910# -*- coding: utf-8 -*-from functools import reducedef str2float(s): n = s.index('.') s1 = list(map(int, [x for x in s[:n]])) s2 = list(map(int,[x for x in s[n+1:]])) return reduce(lambda x, y : x * 10 + y, s1) + reduce(lambda x, y : x * 10 + y, s2)/10**len(s2)&gt;&gt;&gt; str2float('123.456') = 123.456 16.回数是指从左向右读和从右向左读都是一样的数，例如12321，909。请利用filter()筛选出回数： 1234567# -*- coding: utf-8 -*-def is_palindrome(n): n = str(n) return n == n[::-1]list(filter(is_palindrome, range(1, 200)))&gt;&gt;&gt;&gt;[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191] 17.假设我们用一组tuple表示学生名字和成绩： L = [(‘Bob’, 75), (‘Adam’, 92), (‘Bart’, 66), (‘Lisa’, 88)]请用sorted()对上述列表分别按名字排序： 123456789# -*- coding: utf-8 -*-L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]def by_name(t): return t[0]L2 = sorted(L, key=by_name)print(L2)&gt;&gt;&gt; [('Adam', 92), ('Bart', 66), ('Bob', 75), ('Lisa', 88)] 再按成绩从高到低排序： 1234def by_name(t): return -t[1]&gt;&gt;&gt; [('Adam', 92), ('Lisa', 88), ('Bob', 75), ('Bart', 66)] 18.利用闭包返回一个计数器函数，每次调用它返回递增整数： 12345678# -*- coding: utf-8 -*-def createCounter(): n = 0 def counter(): nonlocal n n = n + 1 return n return counter 内层函数”可以使用”外层作用域中的变量,内层函数”无法修改”外层变量,使用 nonlocal 修改外层变量.通常情况下不要在内部函数中对外部作用域的变量重新赋值。 19.请设计一个decorator，它可作用于任何函数上，并打印该函数的执行时间： 12345678910# -*- coding: utf-8 -*-import time, functoolsdef metric(fn): def wrapper(*args,**wk): time_start = time.time() fn(*args,**wk) time_end = time.time() print('%s executed in %s ms' % (fn.__name__, time_end - time_start)) return fn(*args,**wk) return wrapper 20.安装常用的第三方模块Anaconda 21.请把下面的Student对象的gender字段对外隐藏起来，用get_gender()和set_gender()代替，并检查参数有效性： 123456789101112# -*- coding: utf-8 -*-class Student(object): def __init__(self, name, gender): self.name = name self.__gender = gender def get_gender(self): return self.__gender def set_gender(self, gende): if not isinstance(gende, str): raise ValueError('Bad Value') else: self.__gender = gende 22.为了统计学生人数，可以给Student类增加一个类属性，每创建一个实例，该属性自动增加： 12345678# -*- coding: utf-8 -*-class Student(object): count = 0 def __init__(self, name): self.name = name Student.count = Student.count + 1 print(Student.count) 测试:123456789101112131415161718if Student.count != 0: print('测试失败!')else: bart = Student('Bart') if Student.count != 1: print('测试失败!') else: lisa = Student('Bart') if Student.count != 2: print('测试失败!') else: print('Students:', Student.count) print('测试通过!')&gt;&gt;&gt; 1&gt;&gt;&gt; 2&gt;&gt;&gt; Students: 2&gt;&gt;&gt; 测试通过! 实例属性属于各个实例所有，互不干扰； 类属性属于类所有，所有实例共享一个属性； 23.请利用装饰器@property给一个Screen对象加上width和height属性，以及一个只读属性resolution： 123456789101112131415161718192021# -*- coding: utf-8 -*-class Screen(object): @property def width(self): return self._width @width.setter def width(self,value): self._width = value @property def height(self): return self._height @height.setter def height(self,value): self._height = value @property def resolution(self): self._resolution = 786432 return self._resolution 测试: 123456789101112s = Screen()s.width = 1024s.height = 768print('resolution =', s.resolution)if s.resolution == 786432: print('测试通过!')else: print('测试失败!') #结果：&gt;&gt;&gt; resolution = 786432&gt;&gt;&gt; 测试通过! 24.利用os模块编写一个能实现dir -l输出的程序。(显示当前目录下所有的文件和文件夹) &gt;&gt;&gt; import os &gt;&gt;&gt; print([x for x in os.listdir('.')]) ['.deploy_git', '.DS_Store', '.gitignore', '_config.yml', 'db.json', 'debug.log', 'node_modules', 'package.json', 'public', 'scaffolds', 'source', 'themes']","tags":[]},{"title":"ES6的babel转码器","date":"2017-10-14T01:43:06.000Z","path":"2017/10/14/ES6的babel转码器/","text":"我使用的是Mac系统，webstorm，在webstorm上创建一个新的项目ES6，安装babel。（首先要安装node）1.在ES6项目下执行npm init -y (根据权限不同，有的时候前面需要加sudo：sudo npm init -y，然后输入管理员密码) 这样是为了生成一个package.json的文件 2.本地安装babel命令行工具，这样就可以命令行使用babel。babel命令行工具可以全局安装也可本地安装，不过官方推荐本地安装，原因有两点： 本地安装不同的项目可以使用不同版本的babel，你也可以单独对某个项目的babel进行升级等操作 每个项目单独安装的意味着对计算机环境没有依赖，便于移植 安装： npm install --save-dev babel-cli 这时项目里面又了node_modules文件夹 如果你已经全局安装了babel-cli,可以使用下面的命令卸载： npm uninstall --global babel-cli 这时的package.json文件如下： 12345678910111213141516&#123; \"name\": \"ES6-babel\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"babel-cli\": \"^6.26.0\" &#125;&#125; 3.在命令行中调用babel本地安装的babel是不能够在直接命令行中运行的，为了在命令行中运行babel，有两种方法，不过推荐第一种： 方法一：配置package.json文件的scripts项（在script中添加 “build”: “babel src -d lib”,”babel”: “babel”） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990 &#123; \"name\": \"ES6-babel\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"babel src -d lib\", \"babel\": \"babel\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"babel-cli\": \"^6.26.0\" &#125; &#125;``` 方法二：进入node_modules文件夹，再进入.bin文件夹，然后执行在命令行中执行babel src -d lib。#### 4.创建 .babelrc 配置文件 type nul&gt;.babelrc或者： mkfile -n 1m .babelrc都能创建.babelrc文件 #### 5.安装babel转译器把ES6代码转换为ES5的代码必须要用转译器，装好需要的转译器还需要在babelrc进行配置这些转译器(presets)选项。下面是一些转译器，可以选择一个或多个，根据自己需要安装： ##ES2015转码规则``` jsnpm install --save-dev babel-preset-es2015``` ##react转码规则``` js npm install --save-dev babel-preset-react``` ##ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个``` js npm install --save-dev babel-preset-stage-0 npm install --save-dev babel-preset-stage-1 npm install --save-dev babel-preset-stage-2 npm install --save-dev babel-preset-stage-3``` #### 6.配置.babelrc文件.babelrc用于配置除回调以外的所有babel api 选项。例如plugins和presets。plugins用于配置我们转译所需要的插件，presets用于配置我们所需要的转译器。添加：``` json &#123; \"presets\": [ \"es2015\" ], \"plugins\": [] &#125; ``` #### 7.这样我们就可以来转码了由于\"build\": \"babel src -d lib\",所以我们要创建src文件夹，里面是要转码的es6内容例如在 ES6/src/es6.js里面添加如下内容： input.map(item =&gt; item + 1);执行命令： npm run build就会自动生成一个lib文件夹，里面是已经转码好的内容：``` js \"use strict\"; input.map(function (item) &#123; return item + 1; &#125;);","tags":[]},{"title":"bind","date":"2017-10-11T08:33:37.000Z","path":"2017/10/11/bind/","text":"bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 语法： 1fun.bind(thisArg[, arg1[, arg2[, ...]]]) 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 返回由指定的this值和初始化参数改造的原函数拷贝。 bind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的call属性）。当新函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。绑定函数被调用时，bind() 也接受预设的参数提供给原函数。一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。","tags":[]},{"title":"Array.prototype.slice.call(obj)","date":"2017-10-11T06:01:38.000Z","path":"2017/10/11/Array-prototype-slice-call-obj/","text":"Array.prototype.slice.call(obj)能将具有length属性的对象obj转换为数组。 1.首先我们看Array.prototype.slice() Array.prototype.slice()返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。如果开始和结束都省略，那就是返回一个新的数组，是原来数组（从头到尾浅拷贝原数组） 2.然后我们看Function.prototype.call() call()方法的语法是： 12fun.call(thisArg, arg1, arg2, ...) applay()方法的语法： 12fun.apply(thisArg, [argsArray]) （两者差不多，唯一的区别就是call接受的是若干个参数的列表，而apply接受的是一个参数数组,这样实现了对象的继承） thisArg是在fun函数运行时指定的this值，后面的arg1, arg2, …是指定的参数列表。 这样很清楚了，Array.prototype.slice.call(obj)就是把obj这个类似数组的对象转换为数组，让它可以有数组的方法来进行其他操作。 也就相当于： 12obj.slice() 看栗子： 12345678var a = &#123;length:4,0:'a',1:'b',2:'c',3:'d'&#125;Array.prototype.slice.call(a)//[\"a\", \"b\", \"c\", \"d\"]Array.prototype.slice.call(a,2) //[\"c\", \"d\"]Array.prototype.slice.call(a,2,3)//[\"c\"] 用在函数参数中： 1234567function comp(a,b,c,d) &#123; var newArr = Array.prototype.slice.call(arguments); console.log(arguments); console.log(newArr); &#125; comp('a','b','c','d','e'); 这样从控制台看到：arguments是一个对象，而newArr则是一个数组。","tags":[]},{"title":"关于ES6语法","date":"2017-09-28T02:39:20.000Z","path":"2017/09/28/关于ES6语法/","text":"1.let和const命令let1.let用法类似var，但是let声明的变量只在let代码块内有效。用let很适用于for循环。 2.for循环有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 12345678for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了3次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 3.let不存在变量提升，即不可以没有声明就使用。否则会报错。 12345678// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 这表示在let声明bar之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 4.暂时性死区 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 5.不允许重复声明 let不允许在相同作用域内，重复声明同一个变量。 123456789101112// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。 12345678910function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 块级作用域ES5的作用域只有全局作用域和函数作用域ES6中的let相当于增加了块级作用域 1.块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。 123456789101112// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 2.块级作用域与函数声明 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。 123456789101112// 情况一（在ES5规定中是非法的，但是实际可以运行不会报错）if (true) &#123; function f() &#123;&#125;&#125;// 情况二（在ES5规定中是非法的，但是实际可以运行不会报错）try &#123; function f() &#123;&#125;&#125; catch(e) &#123; // ...&#125; ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。 注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 12345678910111213141516// 函数声明语句&#123; let a = 'secret'; function f() &#123; return a; &#125;&#125;// 函数表达式&#123; let a = 'secret'; let f = function () &#123; return a; &#125;;&#125; const 声明一个只读的常量1.一旦声明，常量的值不能改变。并且声明的时候必须赋值，不能先声明后赋值。 123456const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 2.const与let的作用域一样，只在声明所在的块级作用域内有效。 12345if (true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not defined 3.const同样存在暂时性死区，只能在声明的位置后面使用。 4.const声明的常量，也与let一样不可重复声明。 5.const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。 ES6声明对象的六种方法ES5有:var,function两种方法 ES6有:var,function,let,const,import,class六种方法 顶层对象的属性ES5之中，顶层对象的属性与全局变量是等价的。 123456window.a = 1;a // 1a = 2;window.a // 2 顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。 12345678var a = 1;// 如果在Node的REPL环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined 全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。 2.变量的结构赋值数组的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 let [a, b, c] = [1, 2, 3]; 从数组中提取值，按照对应位置，对变量赋值。如果解构不成功，变量的值就等于undefined。如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。 解构赋值允许指定默认值。（如果一个数组成员不严格等于undefined，默认值是不会生效的。） 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 对象的解构赋值对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 1234567let &#123; bar, foo &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\"let &#123; baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz // undefined 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 字符串的解构赋值字符串被转换成了一个类似数组的对象。 let {length : len} = &apos;hello&apos;; len // 5 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 圆括号的问题ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。因此，建议只要有可能，就不要在模式中放置圆括号。 不可以使用圆括号的情况： 1.变量声明语句2.函数参数3.赋值语句的模式 可以使用圆括号的情况： 只有一种：赋值语句的非模式部分，可以使用圆括号。 1234[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 变量解构赋值的用途1.交换变量的值 1234let x = 1;let y = 2;[x, y] = [y, x]; 2.从函数返回多个值 123456789101112131415// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 3.函数参数的定义 12345678// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 4.提取JSON数据 1234567891011let jsonData = &#123; id: 42, status: \"OK\", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, \"OK\", [867, 5309] 5.函数参数的默认值 123456789101112jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 6.遍历Map结构 1234567891011// 任何部署了Iterator接口的对象，都可以用for...of循环遍历。const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + \" is \" + value);&#125;// first is hello// second is world 7.输入模块的指定方法 const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;); 3.字符串的扩展codePointAt() —返回一个字符的码点。String.fromCodePoint() —从码点返回对应字符。字符串的遍历器接口 —字符串可以被for…of循环遍历。normalize() —将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。includes(), startsWith(), endsWith()repeat(n) —返回一个新字符串，表示将原字符串重复n次。padStart()，padEnd() —头部补全，尾部补全模板字符串 —使用In JavaScript &#39;\\n&#39; is a line-feed.模板字符串中嵌入变量，需要将变量名写在${}之中。使用&lt;%…%&gt;放置JavaScript代码，使用&lt;%= … %&gt;输出JavaScript表达式。标签模板String.raw() —模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串 4.正则的扩展1.RegExp构造函数在ES5中RegExp构造函数的参数有两种表现形式： var regex = new RegExp(&apos;xyz&apos;, &apos;i&apos;); var regex = new RegExp(/xyz/i); 在第二种参数为正则表达式时，不允许有第二个参数。 但是在ES6中，如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。并且会忽略第一个参数正则里面的修饰符，只使用新的修饰符。 new RegExp(/abc/ig, &apos;i&apos;).flags // &quot;i&quot; 2.字符串的正则方法match()replace()search()split() 3.u修饰符ES6 对正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于\\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。 1.点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。 var s = &apos;𠮷&apos;; /^.$/.test(s) // false /^.$/u.test(s) // true 2.Unicode 字符表示法：ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。 /\\u{61}/.test(&apos;a&apos;) // false /\\u{61}/u.test(&apos;a&apos;) // true /\\u{20BB7}/u.test(&apos;𠮷&apos;) // true 3.量词:使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。 /a{2}/.test(&apos;aa&apos;) // true /a{2}/u.test(&apos;aa&apos;) // true /𠮷{2}/.test(&apos;𠮷𠮷&apos;) // false /𠮷{2}/u.test(&apos;𠮷𠮷&apos;) // true 4.预定义模式 /^\\S$/.test(&apos;𠮷&apos;) // false /^\\S$/u.test(&apos;𠮷&apos;) // true 上面代码的\\S是预定义模式，匹配所有不是空格的字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的 Unicode 字符。 5.i 修饰符:有些 Unicode 字符的编码不同，但是字型很相近，比如，\\u004B与\\u212A都是大写的K。 /[a-z]/i.test(&apos;\\u212A&apos;) // false /[a-z]/iu.test(&apos;\\u212A&apos;) // true 上面代码中，不加u修饰符，就无法识别非规范的K字符。 y修饰符—“粘连”（sticky）修饰符y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。 单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。 &apos;a1a2a3&apos;.match(/a\\d/y) // [&quot;a1&quot;] &apos;a1a2a3&apos;.match(/a\\d/gy) // [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;] 5.数值的扩展1.二进制和八进制表示法：ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。 如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。 Number(&apos;0b111&apos;) // 7 Number(&apos;0o10&apos;) // 8 2.Number.isFinite(), Number.isNaN()3.Number.parseInt(), Number.parseFloat()// ES5的写法 parseInt(&apos;12.34&apos;) // 12 parseFloat(&apos;123.45#&apos;) // 123.45 // ES6的写法 Number.parseInt(&apos;12.34&apos;) // 12 Number.parseFloat(&apos;123.45#&apos;) // 123.45 4.Number.isInteger()判断一个值是否为整数5.Number.EPSILONES6在Number对象上面，新增一个极小的常量Number.EPSILON。 Number.EPSILON // 2.220446049250313e-16 Number.EPSILON.toFixed(20) // &apos;0.00000000000000022204&apos; Number.EPSILON的实质是一个可以接受的误差范围。 function withinErrorMargin (left, right) { return Math.abs(left - right) &lt; Number.EPSILON; } withinErrorMargin(0.1 + 0.2, 0.3) // true withinErrorMargin(0.2 + 0.2, 0.3) // false 上面的代码为浮点数运算，部署了一个误差检查函数。 6.Math对象的扩展Math.trunc()去除一个数的小数部分，返回整数部分Math.sign()判断一个数是正数(返回+1)、负数(返回-1)、还是0(返回0)，非数值转换为数值，无法转换为数值返回NaN。Math.cbrt()计算一个数的立方根Math.clz32()返回一个数的32位无符号整数形式有多少个前导0,如果是小数的话，则只考虑整数部分。Math.imul()返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。Math.fround()返回一个数的单精度浮点数形式。Math.hyot()返回所有参数的平方之和的平方根。如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回NaN。 对数方法：Math.expm1()返回ex - 1，即Math.exp(x) - 1（e的x次方减1）.Math.log1p()返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。Math.log10()返回以10为底的x的对数。如果x小于0，则返回NaN。Math.log2()返回以2为底的x的对数。如果x小于0，则返回NaN。 双曲函数方法：Math.sinh(x)返回x的双曲正弦Math.cosh(x)返回x的双曲余弦Math.tanh(x)返回x的双曲正切Math.asinh(x)返回x的反双曲正弦Math.acosh(x)返回x的反双曲余弦Math.atanh(x)返回x的反双曲正切 7.Math.signbit()判断值是否是负值（包括-0，判断符号位）如果参数是NaN，返回false如果参数是-0，返回true如果参数是负值，返回true其他情况返回false 8.指数运算符**ES6新增的指数运算符： a ** b //a的b次幂 注：在V8引擎中，指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。 Math.pow(99,99) //3.697296376497263e+197 99 ** 99 //3.697296376497268e+197 9.integer数据类型JavaScript 所有数字都保存成64位浮点数，这决定了整数的精确程度只能到53个二进制位。大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。 为了与 Number 类型区别，Integer 类型的数据必须使用后缀n表示。 6.函数的扩展1.函数参数的默认值在ES6以前是不能给参数指定默认值的，但在ES6可以，即直接写着参数定义的后面。参数变量是默认声明的，所以不能用let或const再次声明。参数不能有同名参数出现 function(x,y = &apos;world&apos;){ console.log(x,y); } 优点：1.可以明显得知那些参数是可以省略的2.利于代码的优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。 2.函数的length属性arguments.length是函数实际接收到的参数个数Function.length 是函数形参的个数，即期望得到的参数的个数 当函数制定了默认值，函数的length属性将失真，即不包含默认值的参数（也不包含设置默认值参数之后的参数） 1234(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。 123(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1 3.rest参数用于获取函数的多余参数（values是一个数组） 形式为 ...变量名 function add(...values){} 栗子： 1234567891011function add(...values) &#123; let sum = 0; for(var val of values)&#123; sum += val; &#125; return sum; &#125; add(1,2,3,4,5); //15 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 函数的length属性，不包括 rest 参数。 1234(function(a) &#123;&#125;).length // 1(function(...a) &#123;&#125;).length // 0(function(a, ...b) &#123;&#125;).length // 1 函数的arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。 123456789function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item); console.log(item); &#125;);&#125;var a = [];push(a, 1, 2, 3) 4.严格模式从 ES5 开始，函数内部可以设定为严格模式。 ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 两种方法可以规避这种情况： 1.设定全局性的严格模式，这是合法的。 123456'use strict';function doSomething(a, b = a) &#123; // code&#125; 2.把函数包在一个无参数的立即执行函数里面。 1234567const doSomething = (function () &#123; 'use strict'; return function(value = 42) &#123; return value; &#125;;&#125;()); 5.name属性返回函数的函数名 function foo() {} foo.name // &quot;foo&quot; 匿名函数在ES5和ES6中返回结果不一样，ES5返回空，ES6返回函数名 123456var f = function () &#123;&#125;;// ES5f.name // \"\"// ES6f.name // \"f\" 构造函数的name返回值为：anonymous (new Function).name // &quot;anonymous&quot; bind返回的函数，name属性值会加上bound前缀。 12345function foo() &#123;&#125;;foo.bind(&#123;&#125;).name // \"bound foo\"(function()&#123;&#125;).bind(&#123;&#125;).name // \"bound \" 6.箭头函数ES6允许使用“箭头”（=&gt;）定义函数。 var sum = (num1, num2) =&gt; { return num1 + num2; } (num1, num2)是参数部分， { return num1 + num2; }是函数体 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 1234var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 123456// 报错let getTempItem = id =&gt; &#123; id: id, name: \"Temp\" &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: \"Temp\" &#125;); 箭头函数的一个用处是简化回调函数。 12345678// 正常函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x); rest 参数与箭头函数结合的例子： 12345678910const numbers = (...nums) =&gt; nums;numbers(1, 2, 3, 4, 5)// [1,2,3,4,5]const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5)// [1,[2,3,4,5]] 箭头函数的注意点（箭头函数没有自己的this）： 1.函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。2.不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。3.不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。4.不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 7.绑定this函数绑定运算符::，运算符左边是对象，右边是函数，将对象绑定到函数的this对象上。 12345678910111213foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments);const hasOwnProperty = Object.prototype.hasOwnProperty;function hasOwn(obj, key) &#123; return obj::hasOwnProperty(key);&#125; 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。 12345678var method = obj::obj.foo;// 等同于var method = ::obj.foo;let log = ::console.log;// 等同于var log = console.log.bind(console); 由于双冒号运算符返回的还是原对象，因此可以采用链式写法。 123456789101112131415// 例一import &#123; map, takeWhile, forEach &#125; from \"iterlib\";getPlayers()::map(x =&gt; x.character())::takeWhile(x =&gt; x.strength &gt; 100)::forEach(x =&gt; console.log(x));// 例二let &#123; find, html &#125; = jake;document.querySelectorAll(\"div.myClass\")::find(\"p\")::html(\"hahaha\"); 8.尾调用优化尾调用就是函数的最后一步是调用另一个函数。 “尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 12345678910111213141516function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); 尾递归：尾调用自身的情况 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 1234567function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。 1234567function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 非尾递归的 Fibonacci 数列实现如下。 12345678910function Fibonacci (n) &#123; if ( n &lt;= 1 ) &#123;return 1&#125;; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;Fibonacci(10) // 89Fibonacci(100) // 堆栈溢出Fibonacci(500) // 堆栈溢出 尾递归优化过的 Fibonacci 数列实现如下。 12345678910function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123; if( n &lt;= 1 ) &#123;return ac2&#125;; return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125;Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 7.数组的扩展1.扩展运算符spread（…）它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。主要用于函数的调用 1234567891011function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;const numbers = [4, 38];add(...numbers) // 42 扩展运算符与正常的函数参数可以结合使用，非常灵活。 1234function f(v, w, x, y, z) &#123; &#125;const args = [0, 1];f(-1, ...args, 2, ...[3]); 扩展运算符可以替换apply方法（把数组转换为函数的参数）： 123456789// ES5 的写法Math.max.apply(null, [14, 3, 77])// ES6 的写法Math.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77); 上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。 扩展运算符的应用： 1.复制数组 对于ES5，一维数组可以用slice或者concat实现深拷贝。 123456const a1 = [1, 2];const a2 = a1.concat();a2[0] = 2;a1 // [1, 2] 用扩展运算符…实现： const a1 = [1,2,3]; const a2 = [...a1]; 2.合并数组 12345// ES5[1, 2].concat(more)// ES6[1, 2, ...more] 3.与解构赋值结合 4.将字符串转换为数组 [...&apos;hello&apos;] // [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ] 5.实现了 Iterator 接口的对象 任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组。 let nodeList = document.querySelectorAll(&apos;div&apos;); let array = [...nodeList]; 2.Array.from将类数组对象和可遍历的对象转换为数组 123456Array.from('hello')// ['h', 'e', 'l', 'l', 'o']let namesSet = new Set(['a', 'b'])Array.from(namesSet) // ['a', 'b'] 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。 Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。 Array.from({ length: 2 }, () =&gt; &apos;jack&apos;) // [&apos;jack&apos;, &apos;jack&apos;] 3.Array.of将一组值，转换为数组。 1234Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 4.数组实例的copyWithin()数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 [1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5] 语法： Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。 target（必需）：从该位置开始替换数据。start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 5.数组实例的find()和findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 [1, 4, -5, 10].find((n) =&gt; n &lt; 0) // -5 [1, 5, 10, 15].findIndex(function(value, index, arr) { return value &gt; 9; }) // 2 这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。 [NaN].indexOf(NaN) // -1 [NaN].findIndex(y =&gt; Object.is(NaN, y)) // 0 6.数组实例的fill()fill方法使用给定值，填充一个数组。 fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2) // [&apos;a&apos;, 7, &apos;c&apos;] 7.数组实例的 entries(),keys(),values()ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 123456789101112131415161718for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 8.数组实例的 includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。 [1, 2, 3].includes(2) // true [1, 2, 3].includes(4) // false [1, 2, NaN].includes(NaN) // true 9.数组的空位数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。 Array(3) // [, , ,] 由于空位的处理规则非常不统一，所以建议避免出现空位。 8.对象的扩展1.属性的简洁表示法ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。 123456789101112function f(x, y) &#123; return &#123;x, y&#125;;&#125;// 等同于function f(x, y) &#123; return &#123;x: x, y: y&#125;;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125; 方法的简写： 1234567891011121314let birth = '2000/01/01';const Person = &#123; name: '张三', //等同于birth: birth birth, // 等同于hello: function ()... hello() &#123; console.log('我的名字是', this.name); &#125;&#125;; 2.属性名表达式ES6允许用表达式定义对象的属性名。 123456let propKey = 'foo';let obj = &#123; [propKey]: true, ['a' + 'bc']: 123&#125;; S6允许用表达式定义对象的方法名： 12345678let obj = &#123; ['h' + 'ello']() &#123; return 'hi'; &#125;&#125;;obj.hello() // hi 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。 12345678910const keyA = &#123;a: 1&#125;;const keyB = &#123;b: 2&#125;;const myObject = &#123; [keyA]: 'valueA', [keyB]: 'valueB'&#125;;myObject // Object &#123;[object Object]: \"valueB\"&#125; 上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。 3.方法的name属性函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。 12345678const person = &#123; sayName() &#123; console.log('hello!'); &#125;,&#125;;person.sayName.name // \"sayName\" 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。 有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。 1234567(new Function()).name // \"anonymous\"var doSomething = function() &#123; // ...&#125;;doSomething.bind().name // \"bound doSomething\" 4.Object.is()比较两个值是否严格相等它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。 它们的不同是(+0与-0，NaN与NaN)： 123456+0 === -0 //trueNaN === NaN //falseObject.is(+0,-0) //falseObject.is(NaN,NaN) //true 5.Object.assign()用于对象的合并12345678const target = &#123; a: 1 &#125;;const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 如果该参数不是对象，则会先转成对象，然后返回。 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。 Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。 用途： 1.为对象添加属性或方法2.克隆对象（浅拷贝）3.合并多个对象 const merge =(...sources) =&gt; Object.assign({}, ...sources); 4.为属性指定默认值 6.属性的可枚举性和遍历Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。 1234567let obj = &#123; foo: 123 &#125;;Object.getOwnPropertyDescriptor(obj, 'foo')//configurable:true//enumerable:true//value:123//writable:true 其中的enumerable枚举属性，如果为false，那么for…in,Object.keys(),JSON.stringfy(),Object.assign()这些操作都会忽略该属性。（for…in会遍历继承的属性，而Object.keys()则不会，因此当我们只关心对象自身的属性时，最好不要用for…in,而选用Object.keys()）. 7.Object.getOwnPropertyDescriptors()返回某个对象属性的描述对象（descriptor）,即返回某个对象的自身属性，而不包含继承属性 8.proto 属性，Object.setPrototypeOf()，Object.getPrototypeOf()1.proto 属性用来读取和设置当前对象的prototype属性。 一个属性的proto 值表示这个对象的原型。ES6不建议用这个方法。 2.Object.setPrototypeOf() 设置对象的prototype，ES6建议用Object.setPropertyOf().返回对象本身。 1234567891011let proto = &#123;&#125;;let obj = &#123; x: 10 &#125;;Object.setPrototypeOf(obj, proto);proto.y = 20;proto.z = 40;obj.x // 10obj.y // 20obj.z // 40 3.Object.getPrototypeOf() 用于读取一个对象的原型 9.super关键字super关键字指向当前对象的原型对象。只能用在对象的方法里面，用在其他地方会报错。 10.Object.keys(),Object.values(),Object.entries()Object.keys() 遍历对象的所有（enumerable为true，不是继承的）键名Object.values() 遍历对象的所有（enumerable为true，不是继承的）键值Object.entries() 遍历对象的所有（enumerable为true，不是继承的）键值对 10.symbolES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 let s = Symbol(); typeof s // &quot;symbol&quot; Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 Symbol值不能与其他类型的值进行运算，否则会报错。 由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 注意，Symbol 值作为对象属性名时，不能用点运算符。在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。 11.Set和Map数据结构1.SetES6提供新的数据结构SET。它类似于数组，但是其内部成员的值都是唯一的，没有重复值(判断的方法类似于全等判断)。 1234567const s = new Set();[2,3,5,4,5,2,2].forEach(x =&gt; s.add(x));for(let i of s)&#123; console.log(i);&#125; 返回结果是：2 3 5 4。结果表明 Set 结构不会添加重复的值。 Set函数可以接受一个数组作为参数来初始化： 12345678const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5 items.length //undefined 利用Set的成员唯一性，可以用来数组去重： 12345let myArray = [1,2,3,4,3,2,4,1];let arr = [...new Set(myArray)];console.log(arr);//[1, 2, 3, 4] 2.Set实例的属性和方法操作方法： 1.add(value) 添加某个值，返回Set结构本身2.delete(value) 删除某个值，返回布尔值，是否删除成功3.has(value) 判断某个值是不是Set成员，返回布尔值4.clear() 清空Set成员，没有返回值 123456789101112s.add(1).add(2).add(2);// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // false Array.from方法可以将 Set 结构转为数组。 const items = new Set([1, 2, 3, 4, 5]); const array = Array.from(items); 这样数组去重就可以这样来写： Array.from(new Set(array)) 遍历Set： 1.keys() 返回键名2.values() 返回键值3.entries() 返回键值对4.foreach() 使用回调函数遍历 3.WeakSet与Set差不多，都是不重复值的集合，但是WeakSet的值必须是对象，不能是其他类型的值。 语法： const ws = new WeakSet() 作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。这个类数组对象的成员必须是对象。否则会报错 1234567const a = [[1, 2], [3, 4]];const ws = new WeakSet(a);// WeakSet &#123;[1, 2], [3, 4]&#125;const b = [3, 4];const ws = new WeakSet(b);// Uncaught TypeError: Invalid value used in weak set(…) WeakSet的方法： 1.WeakSet.prototype.add(value)2.WeakSet.prototype.delete(value)3.WeakSet.prototype.has(value) 他没有size属性,不能遍历它的成员 4.MapObject 结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应。即对象的属性名（键）不只是字符串形式了，还可以是各种类型的值或对象。 12345678910const m = new Map();const o = &#123;p: 'Hello World'&#125;;m.set(o, 'content')m.get(o) // \"content\"m.has(o) // truem.delete(o) // truem.has(o) // false 作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。 1234567891011const map = new Map([ ['name', '张三'], ['title', 'Author']]);map.size // 2map.has('name') // truemap.get('name') // \"张三\"map.has('title') // truemap.get('title') // \"Author\" 5.WeakMapWeakMap结构与Map结构类似，也是用于生成键值对的集合。 首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。 其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。 一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。 1234567const wm = new WeakMap();const element = document.getElementById('example');wm.set(element, 'some information');wm.get(element) // \"some information\" 总之，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。 注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。 123456789const wm = new WeakMap();let key = &#123;&#125;;let obj = &#123;foo: 1&#125;;wm.set(key, obj);obj = null;wm.get(key)// Object &#123;foo: 1&#125; 上面代码中，键值obj是正常引用。所以，即使在 WeakMap 外部消除了obj的引用，WeakMap 内部的引用依然存在。 WeakMap规定不能取到键名,无法清空.即不支持clear方法。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。 1234567const wm = new WeakMap();// size、forEach、clear 方法都不存在wm.size // undefinedwm.forEach // undefinedwm.clear // undefined 12.ProxyProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。 13.ReflectReflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。 （1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。 （2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 （3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 （4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 14.Promise对象一种异步解决方案。从Promise对象，可以获取异步操作的信息。 简单来说Promise是一个容器，它包含着一个未来才会结束的事件（通常是一个异步操作） Promise分为三个状态：pending-进行中,fulfilled-已成功,rejected-已失败. Promise的特点： 1.对象的状态不受外部影响。只有异步操作的结果可以影响Promise状态。任何其他操作都无法改变这个状态。 2.一旦状态改变就不会再次改变，这时就称为 resolved（已定型）。任何时候都能得到异步结果（状态）。Promise状态的改变，只有可能有两种：pending -&gt; fulfilled 或者 pending -&gt; rejected. Promise的缺点： 1.无法取消Promise。一旦新建就会立即执行，无法中途取消。 2.如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 3.当处于pending状态时，无法得知目前进展到什么阶段（是刚刚开始海试即将完成）。 Promise基本用法Promise对象是一个构造函数。 1234567891011var promise = new Promise(function(resolve,reject)&#123; //some coding .... //如果异步操作成功resolve(value)，否则reject(err) if(win)&#123; resolve(value); &#125;else&#123; reject(err); &#125;&#125;) 其中的回调函数中的两个参数resolve和reject分别是两个函数，它们由javascript引擎提供，不需要自己部署。 resolve函数的作用：将Promise对象的状态由pending变为fulfilled，并且在异步操作成功时，将异步操作的结果value，作为参数传递出去。 reject函数的作用：将Promise对象的状态由pending变为rejected。并且在异步操作失败时，将异步操作报出的错误作为参数传递出去。","tags":[]},{"title":"CSS揭秘","date":"2017-09-25T04:07:53.000Z","path":"2017/09/25/CSS揭秘/","text":"1.background-clip:padding-boxbackground-clip默认为border-box，也就是说border的颜色会把元素背景颜色覆盖掉。如果设置background-clip:padding-box，背景颜色的范围就是在padding和containt。 2.box-shadow可以进行多重投影1234567button&#123; background: yellowgreen; box-shadow: 0 0 0 10px #655, 0 0 0 15px deeppink, 0 2px 5px 15px rgba(0,0,0,.6); &#125; box-shadow语法： box-shadow: h-shadow v-shadow blur spread color inset; h-shadow水平阴影的位置v-shadow垂直阴影的位置blur模糊距离spread阴影尺寸color阴影颜色inset将外部阴影变为内部阴影 3.使用border+outline实现两层边框123456button&#123; background: yellowgreen; border: 10px solid #655; outline: 5px solid deeppink; &#125; 不过当outline的内部border设置圆角时，outline边框就不能与border相贴合了。 4.实现边框内圆角用两个元素实现： 123456789101112131415&lt;div class=\"example\"&gt; &lt;div class=\"ex1\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .example&#123; padding: 0.5em; background: #655; &#125; .ex1&#123; background: tan; border-radius: .8em; padding: 1em; &#125; &lt;/style&gt; 用一个元素实现： 12345678.ex1&#123; background: tan; border-radius: .8em; padding: 1em; box-shadow: 0 0 0 .4em #655; outline: .6em solid #655; &#125; 原理就是outline和border圆角之间的空白用box-shadow填补上。 5.条纹背景","tags":[]},{"title":"Vue--混合","date":"2017-09-23T07:54:08.000Z","path":"2017/09/23/Vue-混合/","text":"混合 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混合对象可以包含任意组件选项。以组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。混合以一种灵活的方式为组件提供分布复用功能。混合对象可以包含任意的组件选项。当组件使用了混合对象时，混合对象的所有选项将被“混入”组件自己的选项中。两种写法都不是很容易理解，我的理解是：组件使用混合对象时，组件就拥有了混合对象里面的所有的属性，相当于把这个组件extend了。 原文示例： 1234567891011121314151617181920212223242526272829303132333435363738 // 定义一个混合对象 var myMixin = &#123; created: function () &#123; this.hello() &#125;, methods: &#123; hello: function () &#123; console.log('hello from mixin!') &#125; &#125; &#125; // 定义一个使用混合对象的组件 var Component = Vue.extend(&#123; mixins: [myMixin] &#125;) var component = new Component() // =&gt; \"hello from mixin!\"``` 1.选项合并：当组件和混合对象含有同名选项时，这些选项将以恰当的方式混合。比如，同名钩子函数将混合为一个数组，因此都将被调用。另外，混合对象的 钩子将在组件自身钩子 之前 调用 ``` js var mixin = &#123; created: function () &#123; console.log('混合对象的钩子被调用') &#125; &#125; new Vue(&#123; mixins: [mixin], created: function () &#123; console.log('组件钩子被调用') &#125; &#125;) // =&gt; \"混合对象的钩子被调用\" // =&gt; \"组件钩子被调用\" 值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。 12345678910111213141516171819202122232425var mixin = &#123; methods: &#123; foo: function () &#123; console.log('foo') &#125;, conflicting: function () &#123; console.log('from mixin') &#125; &#125;&#125;var vm = new Vue(&#123; mixins: [mixin], methods: &#123; bar: function () &#123; console.log('bar') &#125;, conflicting: function () &#123; console.log('from self') &#125; &#125;&#125;)vm.foo() // =&gt; \"foo\"vm.bar() // =&gt; \"bar\"vm.conflicting() // =&gt; \"from self\" 2.全局混合 全局注册混合对象。一旦使用全局混合对象，将会影响到 所有 之后创建的 Vue 实例。 1234567891011121314// 为自定义的选项 'myOption' 注入一个处理器。Vue.mixin(&#123; created: function () &#123; var myOption = this.$options.myOption if (myOption) &#123; console.log(myOption) &#125; &#125;&#125;)new Vue(&#123; myOption: 'hello!'&#125;)// =&gt; \"hello!\" 大多数情况下，全局混合只应当应用于自定义选项，就像上面示例一样。也可以将其用作 Plugins 以避免产生重复应用","tags":[]},{"title":"Vue组件--内容分发slot","date":"2017-09-22T02:42:35.000Z","path":"2017/09/22/Vue组件-内容分发slot/","text":"使用插槽分发内容 假如父组件需要在子组件内放一些DOM元素，那么这些DOM元素是显示、不显示、在哪个地方显示、如何显示，就是slot内容分发。Vue实现了一个内容分发API,使用特殊的&lt;slot&gt;元素作为原始内容的插槽。 1.单个插槽 除非子组件有至少一个slot插槽，否则父组件的内容会被丢弃。如果子组件有一个插槽时，父组件的整个内容片段就会插入到插槽所在的DOM位置，并替换掉插槽标签slot。最初在 &lt;slot&gt;标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。 12345678910111213141516171819&lt;div id=\"test\"&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;my-component&gt; &lt;p&gt;这是父初始内容&lt;/p&gt; &lt;p&gt;这是更多初始内容&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component', &#123; template: '&lt;div&gt;' + '&lt;h2&gt;我是子组件的标题&lt;/h2&gt;' + '&lt;slot&gt;只有在没有分发内容时我才会显示&lt;/slot&gt;' + '&lt;/div&gt;', &#125;) new Vue(&#123; el: '#test', &#125;)&lt;/script&gt; 如果子组件中没有slot插槽，那么父元素的内容（两个p标签）都会被丢弃。 2.具名插槽 &lt;slot&gt; 元素可以用一个特殊的属性 name 来配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应 slot 特性的元素。父组件在要分发的标签内添加： slot = ‘slotName’,子组件在对应分发的位置的slot标签内添加：&lt;slot name = &#39;slotName&#39;&gt;. 1234567891011121314151617181920212223&lt;div id=\"test\"&gt; &lt;my-component&gt; &lt;h1 slot=\"header\"&gt;这是slot为header&lt;/h1&gt; &lt;p&gt;这是主要内容&lt;/p&gt; &lt;p&gt;这是另一个主要片段&lt;/p&gt; &lt;p slot=\"footer\"&gt;这是slot为footer&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component', &#123; template: '&lt;div class=\"container\"&gt;' + '&lt;header&gt;&lt;slot name=\"header\"&gt;&lt;/slot&gt;&lt;/header&gt;'+ '&lt;main&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/main&gt;' + '&lt;footer&gt;&lt;slot name=\"footer\"&gt;&lt;/slot&gt;&lt;/footer&gt;' + '&lt;/div&gt;', &#125;) new Vue(&#123; el: '#test', &#125;)&lt;/script&gt; 3.作用域插槽 使用一个 (能够传递数据到) 可重用模板替换已渲染元素。在子组件中，只需将数据传递到插槽，就像你将 props 传递给组件一样在父级中，具有特殊属性 scope 的 &lt;template&gt; 元素必须存在，表示它是作用域插槽的模板。scope 的值对应一个临时变量名，此变量接收从子组件中传递的 props 对象: 123456789101112131415161718192021&lt;div id=\"test\"&gt; &lt;div class=\"parent\"&gt; &lt;child&gt; &lt;template scope=\"props\"&gt; &lt;p&gt;hello from parent&lt;/p&gt; &lt;p&gt;&#123;&#123;props.text&#125;&#125;&lt;/p&gt; &lt;/template&gt; &lt;/child&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('child', &#123; template: '&lt;div class=\"child\"&gt;' + '&lt;slot text=\"hello from child\"&gt;&lt;/slot&gt;' + '&lt;/div&gt;', &#125;) new Vue(&#123; el: '#test', &#125;)&lt;/script&gt; 作用域插槽更具代表性的用例是列表组件，允许组件自定义应该如何渲染列表每一项： 123456789101112131415161718192021222324252627&lt;div id=\"test\"&gt; &lt;my-awesome-list :items=\"items\"&gt; &lt;template slot=\"item\" scope=\"props\"&gt; &lt;li class=\"my-fancy-item\"&gt;&#123;&#123; props.text &#125;&#125;&lt;/li&gt; &lt;/template&gt; &lt;/my-awesome-list&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-awesome-list', &#123; props:['items'], template: '&lt;ul&gt;' + '&lt;slot name=\"item\" v-for=\"item in items\" v-bind:text=\"item.text\"&gt;这里是备用内容&lt;/slot&gt;' + '&lt;/ul&gt;', &#125;) new Vue(&#123; el: '#test', data:&#123; items:[ &#123;text:'apple'&#125;, &#123;text:'pear'&#125;, &#123;text:'grape'&#125; ] &#125;, &#125;)&lt;/script&gt;","tags":[]},{"title":"逻辑与或操作符","date":"2017-09-21T02:28:27.000Z","path":"2017/09/21/逻辑与或操作符/","text":"布尔操作符1.逻辑与 当操作数有一个不是布尔值时，逻辑操作就不一定返回布尔值。 例如 a &amp;&amp; b 若a是对象，则返回第二个操作数b若b是对象，则只有在a是true时才返回b对象若ab都是对象，则返回第二个操作数b若a时null，则返回null若a是NaN，则返回NaN若a是undefined，则返回undefined 2.逻辑或 与逻辑与相似，当操作数有一个不是布尔值时，逻辑操作就不一定返回布尔值。 例如 a || b 若a是对象，则返回第一个操作数a若a的求值结果为false，则返回第二个操作数b若ab都是对象，则返回第一个操作数a若ab都是null，则返回null若ab都是NaN，则返回NaN若ab都是undefined，则返回undefined 例如： var myObj = preferredObject || backupObject 变量myObj被赋予两个值中的一个，preferredObject优先赋给myObj，但是当preferredObject不包含有效值时，会把备用backupObject赋给myObj。","tags":[]},{"title":"Vue之表单输入","date":"2017-09-17T08:56:47.000Z","path":"2017/09/17/Vue之表单输入/","text":"v-model指令在表单控件元素上创建双向数据绑定。它本质上来说是一种语法糖（没有改变什么功能，只是对于程序员来说更容易理解），负责监听用户的输入事件以更新数据。它会根据控件类型自动选取正确的方法来更新元素。 注意： 1.v-model会忽略掉所有表单元素的value、checked、selected特性的初始值。因为它选择的是Vue的实力数据作为具体的值。所以应该在vue的data中声明初始值。 2.对于要求IME(input method如中文、日语、韩语等),v-model 不会在 ime 输入中得到更新。如果你也想实现更新，请使用 input 事件。 基础用法(v-model 绑定的 value 通常是静态字符串) 文本: 1234567891011&lt;div id=\"test\"&gt; &lt;input v-model=\"message\" placeholder=\"edit me\"&gt; &lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#test', data:&#123;message:\"\"&#125; &#125;) &lt;/script&gt; 多行文本 注意：在文本区域插值 (&lt;textarea&gt;&lt;/textarea&gt;) 并不会生效，应用 v-model 来代替。 123456789101112&lt;div id=\"test\"&gt; &lt;p&gt;多行文本：&lt;/p&gt; &lt;p style=\"white-space: pre-line;\"&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;textarea v-model=\"message\" placeholder=\"请输入多行文本\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#test', data:&#123;message:\"\"&#125; &#125;) &lt;/script&gt; 3.复选框 1234567891011121314151617&lt;div id=\"test\"&gt; &lt;p&gt;复选框：&lt;/p&gt; &lt;input type=\"checkbox\" value=\"Joe\" id=\"Joe\" v-model=\"checkedNames\"&gt; &lt;label for=\"Joe\"&gt;Joe&lt;/label&gt; &lt;input type=\"checkbox\" value=\"LiLei\" id=\"LiLei\" v-model=\"checkedNames\"&gt; &lt;label for=\"LiLei\"&gt;LiLei&lt;/label&gt; &lt;input type=\"checkbox\" value=\"HanMeiMei\" id=\"HanMeiMei\" v-model=\"checkedNames\"&gt; &lt;label for=\"HanMeiMei\"&gt;HanMeiMei&lt;/label&gt; &lt;p&gt;&#123;&#123;checkedNames&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#test', data:&#123;checkedNames:[]&#125; &#125;) &lt;/script&gt; for 属性规定 label 与哪个表单元素(id)绑定。 复选框v-model关联：数据为数组形式时，关联的是选中的复选框的value值。是字符串形式时，关联的则是选中的状态true／false 4.单选按钮 1234567891011121314151617&lt;div id=\"test\"&gt; &lt;p&gt;单选框：&lt;/p&gt; &lt;input type=\"radio\" value=\"Joe\" id=\"Joe\" v-model=\"checkedNames\"&gt; &lt;label for=\"Joe\"&gt;Joe&lt;/label&gt; &lt;input type=\"radio\" value=\"LiLei\" id=\"LiLei\" v-model=\"checkedNames\"&gt; &lt;label for=\"LiLei\"&gt;LiLei&lt;/label&gt; &lt;input type=\"radio\" value=\"HanMeiMei\" id=\"HanMeiMei\" v-model=\"checkedNames\"&gt; &lt;label for=\"HanMeiMei\"&gt;HanMeiMei&lt;/label&gt; &lt;p&gt;&#123;&#123;checkedNames&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#test', data:&#123;checkedNames:''&#125; &#125;) &lt;/script&gt; 单选框v-model关联的只是单选选中的value值。 5.下拉框单选： 1234567891011121314151617&lt;div id=\"test\"&gt; &lt;p&gt;下拉框：&lt;/p&gt; &lt;select name=\"\" id=\"\" v-model=\"selected\"&gt; &lt;option value=\"请选择\" disabled&gt;请选择&lt;/option&gt; &lt;option value=\"A\"&gt;A&lt;/option&gt; &lt;option value=\"B\"&gt;B&lt;/option&gt; &lt;option value=\"C\"&gt;C&lt;/option&gt; &lt;/select&gt; &lt;p&gt;选择的是：&#123;&#123;selected&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#test', data:&#123;selected:''&#125; &#125;) &lt;/script&gt; 多选下拉框只需要在select标签里面增加multiple 用v-for动态渲染： 123456789101112131415161718192021&lt;div id=\"test\"&gt; &lt;p&gt;v-for实现下拉框：&lt;/p&gt; &lt;select v-model=\"selected\"&gt; &lt;option v-for=\"option in options\" v-bind:value=\"option.value\"&gt;&#123;&#123;option.text&#125;&#125;&lt;/option&gt; &lt;/select&gt; &lt;p&gt;选择的是：&#123;&#123;selected&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#test', data:&#123; selected:'A', options:[ &#123;text:'one',value:'A'&#125;, &#123;text:'two',value:'B'&#125;, &#123;text:'three',value:'C'&#125; ] &#125; &#125;) &lt;/script&gt; 值绑定:(绑定 value 到 Vue 实例的一个动态属性上)1.复选框：v-bind:true-value=&quot;a&quot; v-bind:false-value=&quot;b&quot; 123456789101112131415&lt;div id=\"test\"&gt; &lt;p&gt;复选框：&lt;/p&gt; &lt;input type=\"checkbox\" v-model=\"checkedNames\" v-bind:true-value=\"a\" v-bind:false-value=\"b\"&gt; &lt;p&gt;&#123;&#123;checkedNames&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#test', data:&#123;checkedNames:'', a:'yes', b:'no' &#125;, &#125;) &lt;/script&gt; 2.单选按钮&lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; v-bind:value=&quot;a&quot;&gt; 1234567891011121314151617181920212223242526272829303132333435363738 &lt;div id=\"test\"&gt; &lt;p&gt;单选按钮：&lt;/p&gt; &lt;input type=\"radio\" v-model=\"select\" v-bind:value=\"a\"&gt; &lt;p&gt;&#123;&#123;select&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#test', data:&#123;select:'', a:'selected' &#125;, &#125;) &lt;/script&gt;``` 3.下拉列表：``` html &lt;div id=\"test\"&gt; &lt;p&gt;v-for实现下拉框：&lt;/p&gt; &lt;select v-model=\"selected\"&gt; &lt;option v-bind:value=\"&#123;number:123&#125;\"&gt;123&lt;/option&gt; &lt;option v-bind:value=\"&#123;number:456&#125;\"&gt;456&lt;/option&gt; &lt;option v-bind:value=\"&#123;number:789&#125;\"&gt;789&lt;/option&gt; &lt;/select&gt; &lt;p&gt;选择的是：&#123;&#123;selected&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#test', data:&#123; selected:'', &#125; &#125;) &lt;/script&gt; v-model的修饰符.lazy 转变为在 change 事件中同步.number 自动将用户的输入值转为 Number 类型(如果原值的转换结果为 NaN 则返回原值).trim 自动过滤用户输入的首尾空格","tags":[]},{"title":"Vue之事件处理","date":"2017-09-17T07:58:58.000Z","path":"2017/09/17/Vue之事件处理/","text":"1.方法事件处理器 用 v-on 指令监听 DOM 事件来触发一些 JavaScript 代码.当事件处理的逻辑很复杂时，v-on 可以接收一个定义的方法来调用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445 &lt;div id=\"test\"&gt; &lt;button v-on:click=\"greet\"&gt;Greet&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#test', data:&#123; name:'Vue.js' &#125;, methods:&#123; greet:function (event) &#123; alert('hello'+this.name+'!'); if(event)&#123; alert(event.target.tagName); &#125; &#125; &#125; &#125;) &lt;/script&gt;``` 2.内联事件处理器如果需要在内联语句里面访问原生DOM事件，可以使用特殊变量$event把它传入方法：``` js &lt;div id=\"test\"&gt; &lt;button v-on:click=\"warn('Form cannot be submmit yet',$event)\"&gt;warn&lt;/button&gt; &lt;/div&gt; var vm = new Vue(&#123; el:'#test', methods:&#123; warn:function (msg,event) &#123; if(event)&#123; event.preventDefault(); &#125; alert(msg); &#125; &#125; &#125;) 3.事件修饰符 在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在 methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。为了解决这个问题，Vue.js 为 v-on 提供了 事件修饰符。通过由点 (.) 表示的指令后缀来调用修饰符。 .stop.prevent.capture.self.once 12345678910111213141516171819202122232425262728293031323334353637 &lt;!-- 阻止单击事件冒泡 --&gt; &lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt; &lt;!-- 提交事件不再重载页面 --&gt; &lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt; &lt;!-- 修饰符可以串联 --&gt; &lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt; &lt;!-- 只有修饰符 --&gt; &lt;form v-on:submit.prevent&gt;&lt;/form&gt; &lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt; &lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt; &lt;!-- 只当事件在该元素本身 (比如不是子元素) 触发时触发回调 --&gt; &lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt; &lt;!-- 点击事件将只会触发一次 --&gt; &lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt;``` 4.键值修饰符监听键盘事件的键值，Vue 为最常用的按键提供了别名。``` html &lt;div id=\"test\"&gt; &lt;input v-on:keyup.enter=\"sub\"&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#test', methods:&#123; sub:function () &#123; alert('回车事件'); &#125; &#125; &#125;) &lt;/script&gt; 全部的按键别名： .enter.tab.delete (捕获“删除”和“退格”键).esc.space.up.down.left.right 可以通过全局 config.keyCodes 对象自定义键值修饰符别名： // 可以使用 v-on:keyup.f1 Vue.config.keyCodes.f1 = 112 5.修饰键 可以用如下修饰符开启鼠标或键盘事件监听，使在按键按下时发生响应。 .ctrl.alt.shift.meta 注意：在 Mac 系统键盘上，meta 对应命令键 (⌘)。在 Windows 系统键盘 meta 对应 windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 键盘及其后续，比如 Knight 键盘，space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。 6.鼠标按钮修饰符 .left.right.middle这些修饰符会限制处理程序监听特定的滑鼠按键。","tags":[]},{"title":"Mac下chrome快捷键","date":"2017-09-17T01:54:27.000Z","path":"2017/09/17/Mac下chrome快捷键/","text":"1.标签页和窗口快捷键 快捷键 对应操作 ⌘-N 打开新窗口 ⌘-T 打开新标签页 ⌘-Shift-N 在隐身模式下打开新窗口 按 ⌘-O，然后选择文件 在 Chrome 浏览器中打开计算机中的文件 按住 ⌘ 的同时点击链接。或用鼠标中键（或鼠标滚轮）点击链接 从后台在新标签页中打开链接 按住 Shift 键的同时点击链接 在新窗口中打开链接 ⌘-Shift-T 重新打开上次关闭的标签页 同时按 ⌘-Option 和向右箭头键 切换到下一个标签页 同时按 ⌘-Option 和向左箭头键 切换到上一个标签页 2.Chrome 浏览器功能快捷键 快捷键 对应操作 ⌘-Shift-B 打开和关闭书签栏 ⌘-Option-B 打开书签管理器 ⌘-, 打开“偏好设置”对话框 ⌘-Y 打开“历史记录”页 ⌘-Shift-J 打开“下载内容”页 ⌘-Shift-Delete 打开“清除浏览数据”对话框 3.地址栏快捷键 快捷键 对应操作 ⌘-Shift-B 打开和关闭书签栏 ⌘-L 突出显示网址 ⌘-Option-F 在地址栏中输入“?”。在问号后键入搜索字词可用默认搜索引擎执行搜索 同时按 Option 和向左箭头键 将光标移到地址栏中的前一个关键字词 同时按 Option 和向右箭头键 在地址栏中将光标移到下一个关键字词 同时按 Shift-Option 和向左箭头键 在地址栏中突出显示上一关键字词 同时按 Shift-Option 和向右箭头键 在地址栏中突出显示下一关键字词 4.网页快捷键 快捷键 对应操作 ⌘-Shift-I 通过电子邮件发送当前网页 ⌘-R 重新载入当前网页 ⌘-, 停止载入当前网页 ⌘-Option-I 打开“开发人员工具” ⌘-Option-J 打开“JavaScript 控制台” ⌘-Option-U 打开当前网页的源代码 按住 Option 键，然后点击链接 下载链接目标 ⌘-D 将当前网页保存为书签&lt; ⌘-Shift-F 在全屏模式下打开网页。再按一次 ⌘-Shift-F 可退出全屏模式 ⌘-+ 放大网页上的所有内容 ⌘– 缩小网页上的所有内容 ⌘-0 将网页上的所有内容恢复到正常大小 ⌘-Shift-H 在当前标签页中打开主页 5.文本快捷键 快捷键 对应操作 ⌘-C 将突出显示的内容复制到剪贴板中 ⌘-V 从剪贴板中粘贴内容 ⌘-X 删除突出显示的内容并将其复制到剪贴板中 ⌘-Z 撤消最后一步操作 ⌘-Shift-Z 重复最后一步操作 ⌘-A 选择当前网页上的所有文本 ⌘-: 打开“拼写和语法”对话框","tags":[{"name":"mac","slug":"mac","permalink":"https://shleyz.github.io/tags/mac/"}]},{"title":"Vue之绑定属性样式","date":"2017-09-15T08:06:12.000Z","path":"2017/09/15/Vue之绑定属性样式/","text":"1.绑定Class: 对象语法： 123456789101112131415&lt;div id=\"app\"&gt; &lt;div class=\"static\" v-bind:class=\"classObj\"&gt;aaaa&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; classObj: &#123; 'active': true, 'text-danger': true &#125; &#125; &#125;) &lt;/script&gt; 数组语法： 12345678910111213&lt;div id=\"app\"&gt; &lt;div class=\"static\" v-bind:class=\"[activeClass,errorClass]\"&gt;aaaa&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; activeClass: 'active', errorClass: 'text-danger' &#125; &#125;) &lt;/script&gt; 绑定到组件上时，这些类将被添加到根元素上面。这个元素上已经存在的类不会被覆盖。 2.绑定到内联样式： 对象语法： 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;div v-bind:style=\"styleObj\"&gt;aaa&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; styleObj:&#123; width: '100px', height: '100px', color: 'red', backgroundColor: 'orange' &#125; &#125; &#125;) &lt;/script&gt; 数组语法： 1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;div v-bind:style=\"[baseStyles, overridingStyles]\"&gt;aaa&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; baseStyles:&#123; width: '200px', height: '200px' &#125;, overridingStyles:&#123; color: 'white', backgroundColor: 'red', transform: 'rotate(7deg)' //旋转 &#125; &#125; &#125;) &lt;/script&gt; 当 v-bind:style 使用需要特定前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。 多重值: 12&lt;div :style=\"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;\"&gt;&lt;/div&gt;","tags":[]},{"title":"Vue之计算属性","date":"2017-09-14T07:57:09.000Z","path":"2017/09/14/Vue之计算属性/","text":"当模版比较复杂，不容易理解的时候可以使用计算属性： 123456789101112131415161718&lt;div id=\"app\"&gt; &lt;p&gt;message:\"&#123;&#123;msg&#125;&#125;\"&lt;/p&gt; &lt;p&gt;reverseMessage:\"&#123;&#123;reversedMessage&#125;&#125;\"&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; msg: '我是msg', &#125;, computed:&#123; reversedMessage:function () &#123; return this.msg.split('').reverse().join(''); &#125; &#125; &#125;)&lt;/script&gt; 这样模版reversedMessage的属性值就与模版msg的属性值进行绑定。 计算属性的缓存VS方法：上面的计算属性可以用方法表示如下： 123456789101112131415161718&lt;div id=\"app\"&gt; &lt;p&gt;message:\"&#123;&#123;msg&#125;&#125;\"&lt;/p&gt; &lt;p&gt;reverseMessage:\"&#123;&#123;reversedMessage()&#125;&#125;\"&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; msg: '我是msg', &#125;, methods:&#123; reversedMessage:function () &#123; return this.msg.split('').reverse().join(''); &#125; &#125; &#125;) &lt;/script&gt; 这里计算属性和方法的结果都是一致的。计算属性是基于它们的依赖进行缓存的,当msg的值没有改变时,多次访问reversedMessage时,计算属性会立即返回之前缓存的计算结果,而不会执行reversedMessage函数。而方法(methods),每次访问reversedMessage时，都会执行一次reversedMessage函数。 计算属性VS被观察的属性(watch)watch属性： 123456789101112131415161718192021&lt;div id=\"watch\"&gt;FullName:&#123;&#123;fullName&#125;&#125;&lt;/div&gt;&lt;script&gt; var vmWatch = new Vue(&#123; el:'#watch', data:&#123; firstName:'xiao', lastName:'hong', fullName:'xiao hong' &#125;, watch:&#123; firstName: function (val) &#123; this.fullName = val + \" \" + this.lastName; &#125;, lastName:function (val) &#123; this.fullName = this.firstName + \" \" + val; &#125; &#125; &#125;)&lt;/script&gt; 如果用计算属性来实现相同的效果(相对watch属性来说简单)： 123456computed:&#123; fullName: function () &#123; return this.firstName + \" \" + this.lastName; &#125; &#125; 计算属性默认只有getter,但是可以自定义setter:12345678910111213141516171819202122232425&lt;div id=\"watch\"&gt;FullName:&#123;&#123;fullName&#125;&#125;&lt;/div&gt;&lt;script&gt; var vmWatch = new Vue(&#123; el:'#watch', data:&#123; firstName:'xiao', lastName:'hong', fullName:'xiao hong' &#125;, computed:&#123; fullname:&#123; get: function () &#123; return this.firstName + \" \" + this.lastName; &#125;, set: function (newValue) &#123; var names = newValue.split(\" \"); this.firstName = names[0]; this.lastName = names[names.length - 1]; &#125; &#125; &#125; &#125;)&lt;/script&gt; 运行 vm.fullName = ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也相应地会被更新。 watch12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id=\"watch-example\"&gt; &lt;p&gt; 提出问题: &lt;input v-model=\"question\"&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123;answer&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js\"&gt;&lt;/script&gt; &lt;script&gt; var watchExampleVM = new Vue(&#123; el:'#watch-example', data:&#123; question: \"\", answer: \"提问以后会有回答\" &#125;, watch:&#123; question: function (newQuestion) &#123; this.answer = '等待你的输入...'; this.getAnswer(); &#125; &#125;, methods:&#123; // _.debounce 是一个通过 lodash 限制操作频率的函数。 // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率 // ajax 请求直到用户输入完毕才会发出 getAnswer: _.debounce(function () &#123; if(this.question.indexOf('?') === -1)&#123; this.answer = '问题需要一个问号来表示...'; return &#125; this.answer = '认真思考中...'; var vm = this; axios.get('https://yesno.wtf/api').then(function (response) &#123; vm.answer = _.capitalize(response.data.answer) &#125;).catch(function (error) &#123; vm.answer = '错误！不能获取API' + error; &#125;) &#125;,500) &#125; &#125;) &lt;/script&gt; 这里,使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这是计算属性无法做到的。 注：axios—–一个打包好的XMLHttpRequests，也就是说，是一个ajax库。可以实现: 1.在浏览器里建立XHR 2.通过nodejs进行http请求 甚至可以实现: 3.转换或者拦截请求数据或响应数据 4.支持Promise的API 5.可以取消请求 6.自动转换JSON 7.可以防御XSRF攻击！ lodash—–一套工具库，它内部封装了诸多对字符串、数组、对象等常见数据类型的处理函数，其中部分是目前 ECMAScript 尚未制定的规范，但同时被业界所认可的辅助函数。","tags":[]},{"title":"sass学习笔记","date":"2017-09-11T06:06:10.000Z","path":"2017/09/11/sass学习笔记/","text":"Sass 实时编译 sass –watch &lt;要编译的Sass文件路径&gt;/style.scss:&lt;要输出CSS文件路径&gt;/style.css Grunt 和 Gulp 自动化编译 Sass 编译常见的错误 在Sass的编译的过程中，是不是支持“GBK”编码的。所以在创建 Sass 文件时，就需要将文件编码设置为“utf-8”。 路径中的中文字符，建议在项目中文件命名或者文件目录命名不要使用中文字符 不同样式风格的输出方法 嵌套输出方式 nested 展开输出方式 expanded 紧凑输出方式 compact 压缩输出方式 compressed 默认变量sass 的默认变量仅需要在值后面加上 !default 即可。 1234$baseLineHeight:1.5 !default;body&#123;line-height: $baseLineHeight;&#125; sass 的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可。默认变量的价值在进行组件化开发的时候会非常有用。 Sass嵌套 选择器嵌套 123456789nav &#123; a &#123; color: red; header &amp; &#123; color:green; &#125; &#125;&#125; 属性嵌套 123456.box &#123; border: &#123; top: 1px solid red; bottom: 1px solid green; &#125;&#125; 伪类嵌套 1234567891011.clearfix&#123; &amp;:before, &amp;:after &#123; content:\"\"; display: table; &#125; &amp;:after &#123; clear:both; overflow: hidden; &#125;&#125; 编译出来的 CSS： 12345678clearfix:before, .clearfix:after &#123; content: \"\"; display: table;&#125;.clearfix:after &#123; clear: both; overflow: hidden;&#125; 混合宏 声明混合宏 1234@mixin border-radius&#123; -webkit-border-radius: 5px; border-radius: 5px;&#125; 使用“@mixin”来声明一个混合宏。 调用混合宏 123button &#123; @include border-radius;&#125; 关键词“@include”来调用声明好的混合宏 混合宏的参数–传多个参数 123456789101112131415161718192021222324252627282930313233@mixin center($width,$height)&#123; width: $width; height: $height; position: absolute; top: 50%; left: 50%; margin-top: -($height) / 2; margin-left: -($width) / 2;&#125;.box-center &#123; @include center(500px,300px);&#125;``` 有一个特别的参数“…”。当混合宏传的参数过多之时，可以使用参数来替代``` scss@mixin box-shadow($shadows...)&#123; @if length($shadows) &gt;= 1 &#123; -webkit-box-shadow: $shadows; box-shadow: $shadows; &#125; @else &#123; $shadows: 0 0 2px rgba(#000,.25); -webkit-box-shadow: $shadow; box-shadow: $shadow; &#125;&#125;.box &#123; @include box-shadow(0 0 1px rgba(#000,.5),0 0 2px rgba(#000,.2));&#125; 混合宏的不足 混合宏在实际编码中给我们带来很多方便之处，特别是对于复用重复代码块。但其最大的不足之处是会生成冗余的代码块。 12345678910111213@mixin border-radius&#123; -webkit-border-radius: 3px; border-radius: 3px;&#125;.box &#123; @include border-radius; margin-bottom: 5px;&#125;.btn &#123; @include border-radius;&#125; 编译出来的 CSS： 12345678910.box &#123; -webkit-border-radius: 3px; border-radius: 3px; margin-bottom: 5px;&#125;.btn &#123; -webkit-border-radius: 3px; border-radius: 3px;&#125; 不能智能的将相同的样式代码块合并在一起 Sass扩展/继承通过关键词 “@extend”来继承已存在的类样式块，从而实现代码的继承。 123456789101112131415161718//SCSS.btn &#123; border: 1px solid #ccc; padding: 6px 10px; font-size: 14px;&#125;.btn-primary &#123; background-color: #f36; color: #fff; @extend .btn;&#125;.btn-second &#123; background-color: orange; color: #fff; @extend .btn;&#125; 编译出来之后： 123456789101112131415161718//CSS.btn, .btn-primary, .btn-second &#123; border: 1px solid #ccc; padding: 6px 10px; font-size: 14px;&#125;.btn-primary &#123; background-color: #f36; color: #fff;&#125;.btn-second &#123; background-clor: orange; color: #fff;&#125; Sass占位符%%placeholder 声明的代码，如果不被 @extend 调用的话，不会产生任何代码。 1234567891011121314151617181920//SCSS%mt5 &#123; margin-top: 5px;&#125;%pt5&#123; padding-top: 5px;&#125;.btn &#123; @extend %mt5; @extend %pt5;&#125;.block &#123; @extend %mt5; span &#123; @extend %pt5; &#125;&#125; 编译出来的CSS 123456789//CSS.btn, .block &#123; margin-top: 5px;&#125;.btn, .block span &#123; padding-top: 5px;&#125; Sass插值#{}123456789$properties: (margin, padding);@mixin set-value($side, $value) &#123; @each $prop in $properties &#123; #&#123;$prop&#125;-#&#123;$side&#125;: $value; &#125;&#125;.login-box &#123; @include set-value(top, 14px);&#125; 上面的代码编译成 CSS： 1234.login-box &#123; margin-top: 14px; padding-top: 14px;&#125; #{}语法并不是随处可用，不能在 mixin 中调用可以使用 @extend 中使用插值 123456789101112%updated-status &#123; margin-top: 20px; background: #F00;&#125;.selected-status &#123; font-weight: bold;&#125;$flag: \"status\";.navigation &#123; @extend %updated-#&#123;$flag&#125;; @extend .selected-#&#123;$flag&#125;;&#125; 上面的 Sass 代码是可以运行的，代码编译出来的 CSS: 12345678.navigation &#123; margin-top: 20px; background: #F00;&#125;.selected-status, .navigation &#123; font-weight: bold;&#125; Sass数据类型 数字 字符串 颜色 布尔值 空值 值列表 Sass指令 @if 12345678910111213141516171819//SCSS@mixin blockOrHidden($boolean:true) &#123; @if $boolean &#123; @debug \"$boolean is #&#123;$boolean&#125;\"; display: block; &#125; @else &#123; @debug \"$boolean is #&#123;$boolean&#125;\"; display: none; &#125;&#125;.block &#123; @include blockOrHidden;&#125;.hidden&#123; @include blockOrHidden(false);&#125; 编译出来的CSS: 1234567.block &#123; display: block;&#125;.hidden &#123; display: none;&#125; @for循环 12@for $i from &lt;start&gt; through &lt;end&gt;@for $i from &lt;start&gt; to &lt;end&gt; $i 表示变量，start 表示起始值，end 表示结束值。关键字 through 表示包括 end 这个数，而 to 则不包括 end 这个数。 123456through:@for $i from 1 through 3&#123; .item-#&#123;$i&#125;&#123; width:2em * $i; &#125;&#125; 编译出来的 CSS: 1234567891011.item-1 &#123; width: 2em;&#125;.item-2 &#123; width: 4em;&#125;.item-3 &#123; width: 6em;&#125; to: 12345@for $i from 1 to 3&#123; .item-#&#123;$i&#125;&#123; width:2em * $i; &#125;&#125; 编译出来的 CSS: 1234567.item-1 &#123; width: 2em;&#125;.item-2 &#123; width: 4em;&#125; @while 只要 @while 后面的条件为 true 就会执行 @each 遍历一个列表，然后从列表中取出对应的值 1@each $var in &lt;list&gt; Sass函数 unquote()函数 删除字符串中的引号； quote()函数 给字符串添加引号。如果字符串包含引号，不论单引号还是双引号，会统一替换为双引号。字符串中间有单引号或者空格时，需要用单引号或双引号括起，否则编译的时候将会报错。quote() 碰到特殊符号，比如： !、?、&gt; 等，除中折号-和下划线_都需要使用双引号括起，否则编译器在进行编译的时候同样会报错。 123.test2 &#123; content: quote(\"today is sunday!\")&#125; To-upper-case() 函数将字符串小写字母转换成大写字母。 To-lower-case() 将字符串转换成小写字母 12345//SCSS.test &#123; text: to-upper-case(aaaaa); text: to-lower-case(aA-aAAA-aaa);&#125; percentage() 数字函数 将一个不带单位的数字转换成百分比形式 123.footer&#123; width : percentage(.2)&#125; 如果转换的值是一个带有单位的值，那么在编译的时候会报错 round()函数 将一个数四舍五入为一个最接近的整数 1234567.footer1 &#123; width:round(15.8px)&#125;//CSS.footer1 &#123; width: 16px; &#125; ceil()函数向上取整 123456789.footer1 &#123; width:ceil(18.1px);&#125;//CSS.footer1 &#123; width:19px;&#125; floor()函数向下取整 abs()函数取绝对值 12345678.footer &#123; width:abs(-8.9px);&#125;//CSS.footer &#123; width:8.9px;&#125; min()函数、max()函数 函数中同时出现两种不同类型的单位，将会报错误 random()函数 获取一个0-1随机数 length()函数 列表函数 nth()函数 列表函数 12&gt;&gt; nth(10px 20px 30px,1)10px //从1开始 join()函数 列表函数 12&gt;&gt; join(10px 20px, 30px 40px)(10px 20px 30px 40px) 只能将两个列表连接成一个列表，如果直接连接两个以上的列表将会报错 append()函数 列表函数 将某个值插入到列表中，并且处于最末位 123456789101112&gt;&gt; append((blue green),red,comma)(#0000ff, #008000, #ff0000)&gt;&gt; append((blue green),red,space)(#0000ff #008000 #ff0000)&gt;&gt; append((blue, green),red,comma)(#0000ff, #008000, #ff0000)&gt;&gt; append((blue, green),red,space)(#0000ff #008000 #ff0000)&gt;&gt; append(blue,red,comma)(#0000ff, #ff0000)&gt;&gt; append(blue,red,space)(#0000ff #ff0000) zip()函数 列表函数将多个列表值转成一个多维的列表 使用zip()函数时，每个单一的列表个数值必须是相同的 12&gt;&gt; zip(1px 2px 3px,solid dashed dotted,green blue red)((1px \"solid\" #008000), (2px \"dashed\" #0000ff), (3px \"dotted\" #ff0000)) index()函数 列表函数 123456&gt;&gt; index(1px solid red, 1px)1&gt;&gt; index(1px solid red, solid)2&gt;&gt; index(1px solid red, red)3 如果指定的值不在列表中（没有找到相应的值），那么返回的值将是 false，相反就会返回对应的值在列表中所处的位置。 type-of() Introspection 函数 判断一个值是属于什么类型： 返回值： number 为数值型。string 为字符串型。bool 为布尔型。color 为颜色型。 unit()函数 Introspection 函数 获取一个值所使用的单位 1234567891011121314&gt;&gt; unit(100)\"\"&gt;&gt; unit(100px)\"px\"&gt;&gt; unit(20%)\"%\"&gt;&gt; unit(1em)\"em\"&gt;&gt; unit(10px * 3em)\"em*px\"&gt;&gt; unit(10px / 3em)\"px/em\"&gt;&gt; unit(10px * 2em / 3cm / 1rem)\"em/rem\" unitless()函数 Introspection 函数 判断一个值是否带有单位，如果不带单位返回的值为 true，带单位返回的值为 false代码实现：用户在调用混合宏时，如果用户没有给参数值加上单位，程序会自动加入单位。 123456789101112131415@mixin adjust-location($x, $y) &#123; @if unitless($x) &#123; $x: 1px * $x; &#125; @if unitless($y) &#123; $y: 1px * $y; &#125; position: relative; left: $x; top: $y;&#125;.botton&#123; @include adjust-location(20px, 30);&#125; comparable()函数 Introspection 函数 判断两个数是否可以进行“加，减”以及“合并”。如果可以返回的值为 true，如果不可以返回的值是 false 12345678910&gt;&gt; comparable(2px,1%)false&gt;&gt; comparable(2px,1em)false&gt;&gt; comparable(2rem,1em)false&gt;&gt; comparable(2px,1cm)true&gt;&gt; comparable(2px,1mm)true Miscellaneous函数 if($condition,$if-true,$if-false)当 $condition 条件成立时，返回的值为 $if-true，否则返回的是 $if-false 值。 1234&gt;&gt; if(true,1px,2px)1px&gt;&gt; if(false,1px,2px)2px map-get($map,$key) Maps的函数返回 $key 在 $map 中对应的 value 值。如果 $key 不存在 $map中，将返回 null 值。 12345678910$social-colors: ( dribble: #ea4c89, facebook: #3b5998, github: #171515, google: #db4437, twitter: #55acee);.btn-dribble&#123; color: map-get($social-colors,facebook);&#125; 如果 $key 不在 $map 中，不会编译出 CSS map-has-key($map,$key) Maps的函数函数将返回一个布尔值。当 $map 中有这个 $key，则函数返回 true，否则返回 false。 1234567891011121314151617181920212223@function colors($color)&#123; @if not map-has-key($social-colors,$color)&#123; @warn \"No color found for `#&#123;$color&#125;` in $social-colors map. Property omitted.\"; &#125; @return map-get($social-colors,$color);&#125;.btn-dribble &#123; color: colors(dribble);&#125;.btn-facebook &#123; color: colors(facebook);&#125;.btn-github &#123; color: colors(github);&#125; ``` - map-keys($map) Maps的函数返回 $map 中的所有 key``` scssmap-keys($social-colors); map-values($map) Maps的函数获取的是 $map 的所有 value 值，可以说是一个列表。 1map-values($social-colors) map-merge($map1,$map2) Maps的函数 map-merge($map1,$map2)将 $map1 和 $map2 合并，然后得到一个新的 $map。如果 $map1 和 $map2 中有相同的 $key 名，那么将 $map2 中的 $key 会取代 $map1 中的 1234567891011121314151617181920212223$color: ( text: #f36, link: #f63, border: #ddd, backround: #fff);$typo:( font-size: 12px, line-height: 1.6, border: #ccc, background: #000); $newmap: map-merge($color,$typo);$newmap:( text: #f36, link: #f63, font-size: 12px, line-height: 1.6, border: #ccc, background: #000); map-remove($map,$key) Maps的函数 1map-remove($map,$key) 删除当前 $map 中的某一个 $key，从而得到一个新的 map。其返回的值还是一个 map。他并不能直接从一个 map 中删除另一个 map，仅能通过删除 map 中的某个 key 得到新 map。 keywords($args) RGBA()函数将一个颜色根据透明度转换成 rgba 颜色 12rgba($red,$green,$blue,$alpha) //将一个rgba颜色转译出来，和未转译的值一样rgba($color,$alpha) //将一个Hex颜色转换成rgba颜色 @import引入 SCSS 和 Sass 文件。 所有引入的 SCSS 和 Sass 文件都会被合并并输出一个单一的 CSS 文件。 被导入的文件中所定义的变量或 mixins 都可以在主文件中使用。 @media在样式中使用 @media 指令，它将冒泡到外面 123456.sidebar &#123; width: 300px; @media screen and (orientation: landscape) &#123; width: 500px; &#125;&#125; 编译出来： 12345678.sidebar &#123; width: 300px; &#125;@media screen and (orientation: landscape) &#123; .sidebar &#123; width: 500px; &#125; &#125; @extend Sass 中的 @extend 是用来扩展选择器或占位符。比如： 1234567891011.error &#123; border: 1px #f00; background-color: #fdd;&#125;.error.intrusion &#123; background-image: url(\"/image/hacked.png\");&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 被编译为： 12345678910111213.error, .seriousError &#123; border: 1px #f00; background-color: #fdd; &#125;.error.intrusion, .seriousError.intrusion &#123; background-image: url(\"/image/hacked.png\"); &#125;.seriousError &#123; border-width: 3px; &#125; @at-root跳出根元素 123456789101112131415.a &#123; color: red; .b &#123; color: orange; .c &#123; color: yellow; @at-root .d &#123; color: green; &#125; &#125; &#125; &#125; 编译出来的CSS 123456789101112131415.a &#123; color: red;&#125;.a .b &#123; color: orange;&#125;.a .b .c &#123; color: yellow;&#125;.d &#123; color: green;&#125; @debug @debug 在 Sass 中是用来调试的，当你的在 Sass 的源码中使用了 @debug 指令之后，Sass 代码在编译出错时，在命令终端会输出你设置的提示 Bug: @debug 10em + 12em;会输出： Line 1 DEBUG: 22em @warn @warn 和 @debug 功能类似，用来帮助我们更好的调试 Sass。如： 1234567891011@mixin adjust-location($x, $y) &#123; @if unitless($x) &#123; @warn \"Assuming #&#123;$x&#125; to be in pixels\"; $x: 1px * $x; &#125; @if unitless($y) &#123; @warn \"Assuming #&#123;$y&#125; to be in pixels\"; $y: 1px * $y; &#125; position: relative; left: $x; top: $y;&#125; @error 12345678910111213@mixin error($x)&#123; @if $x &lt; 10 &#123; width: $x * 10px; &#125; @else if $x == 10 &#123; width: $x; &#125; @else &#123; @error \"你需要将#&#123;$x&#125;值设置在10以内的数\"; &#125;&#125;.test &#123; @include error(15);&#125;","tags":[]},{"title":"正则表达式贪婪模式与非贪婪模式","date":"2017-09-04T15:43:04.000Z","path":"2017/09/04/正则表达式贪婪模式与非贪婪模式/","text":"源字符串： 1var url = 'http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;d&amp;enabled' 正则表达式一：12url.match(/user=(\\S*)&amp;/)[1] 匹配结果一： 12\"anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;d\" 正则表达式二： 12url.match(/user=(\\S*?)&amp;/)[1] 匹配结果二： 12\"anonymous\"（这里指的是一次匹配结果，所以没包括&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;d\"） 正则表达式一采用的是贪婪模式，在匹配到第一个“&amp;”时已经可以使整个表达式匹配成功，但是由于采用的是贪婪模式，所以仍然要向右尝试匹配，查看是否还有更长的可以成功匹配的子串，匹配到第五个“&amp;”后，向右再没有可以成功匹配的子串，匹配结束，匹配结果为 1\"anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;d\"。 正则表达式二采用的是非贪婪模式，在匹配到第一个“&amp;”时使整个表达式匹配成功，由于采用的是非贪婪模式，所以结束匹配，不再向右尝试，匹配结果为”anonymous”。","tags":[{"name":"正则","slug":"正则","permalink":"https://shleyz.github.io/tags/正则/"}]},{"title":"JSON长度","date":"2017-09-01T08:38:28.000Z","path":"2017/09/01/JSON长度/","text":"JSON没有length属性 var json = {name:\"xiaoming\",sex:\"male\"} function getJsonLength(jsonData){ var jsonLength = 0; for(var item in jsonData){ jsonLength++; } return jsonLength; } getJsonLength(json); //2","tags":[]},{"title":"伪元素和伪类","date":"2017-08-28T06:54:18.000Z","path":"2017/08/28/伪元素和伪类/","text":"伪元素 :first-letter向文本的第一个字母添加特殊样式。 :first-line向文本的首行添加特殊样式。 :before在元素之前添加内容。 :after在元素之后添加内容。 伪类锚伪类 a:link a:visited a:hover a:active 在 CSS 定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。 在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。 伪类名称对大小写不敏感。 其他 :first-child 选择元素的第一个子元素 :lang 为不同的语言定义特殊的规则 &lt;html&gt; &lt;head&gt; &lt;style type=\"text/css\"&gt; q:lang(no) { quotes: \"~\" \"~\" } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;文字&lt;q lang=\"no\"&gt;段落中的引用的文字&lt;/q&gt;文字&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"CSS中的rem","date":"2017-08-28T06:06:49.000Z","path":"2017/08/28/CSS中的rem/","text":"rem是CSS3引进的一个新的单位，在W3C官网上是这样描述rem的——“font size of the root element” . rem相对于的是根元素html. 不能兼容IE6-8，可以px和rem同时使用。","tags":[]},{"title":"about","date":"2017-08-26T16:23:46.000Z","path":"2017/08/27/index/","text":"","tags":[]},{"title":"jquery组件开发","date":"2017-08-15T07:12:20.000Z","path":"2017/08/15/jquery组件开发/","text":"jQuery插件就是用来扩展jQuery原型对象的一个方法，即是jQuery对象的一个方法。jQuery插件的使用方法就是jQuery对象方法的调用。 基础版jQuery插件知道了上面这些知识，我们就可以来写一个简单的jQuery插件。假如我现在需要一个jQuery插件用来改变标签内容颜色，就可以按下面的方式来实现这个插件： 1234$.fn.changeStyle = function(colorStr)&#123; this.css(\"color\",colorStr);&#125; 然后按下面的方式来使用插件： 12$(\"p\").changeStyle(\"red\"); 插件调用的时候，插件内部的this就是当前调用插件的jQuery对象，这样的话每个使用$()方法选择的标签，在调用changeStyle()插件时都会使用css()方法重设color样式。 满足链式调用的jQuery插件链式调用时jQuery的一大特色，一个通用的插件应该遵循jQuery风格，满足链式调用要求。实现链式调用的方式也很简单： 12345$.fn.changeStyle = function(colorStr)&#123; this.css(\"color\",colorStr); return this;&#125; 然后使用的时候就可以链式调用其他方法了： 12$(\"p\").changeStyle(\"red\").addClass(\"red-color\"); 实现链式调用的关键点就一行代码return this，插件中加了这行代码，那么在插件执行完之后，就会把当前的jQuery对象返回，然后就可以在插件方法后面继续调用其它jQuery方法。 防止$符号污染的jQuery插件有很多js库都会使用$符号，虽然jQuery可以使用jQuery.noConflict()方法交出$符号的使用权，但是如果定义插件的时候，使用$.fn对象来定义的，那么这些插件使用的时候就会受到其它使用$变量的js库的影响。对于这种情况，我们可以使用立即执行函数通过传参的方式封装插件。形式如下： 1234567(function($)&#123; $.fn.changeStyle = function(colorStr)&#123; this.css(\"color\",colorStr); return this; &#125;&#125;(jQuery)); 因为使用了立即执行函数，所以此时的$只属于这个立即执行函数的函数作用域，这样就可以避免$符号的污染。 可以接受参数的jQuery插件继续上面的例子，假如我还想为这个插件添加一个设置标签元素内容文字大小的功能，那么我可以这么来实现： 1234567(function($)&#123; $.fn.changeStyle = function(colorStr，fontSize)&#123; this.css(\"color\",colorStr).css(\"fontSize\",fontSize+\"px\"); return this; &#125;&#125;(jQuery)); 上面这种插件传参方式适用于参数比较少的情况，如果需要传给插件内部的参数比较多，我们可以定义一个参数对象，然后把需要传给插件的参数放在参数对象中。插件定义时如下： 1234567(function($)&#123; $.fn.changeStyle = function(option)&#123; this.css(\"color\",option.colorStr).css(\"fontSize\",option.fontSize+\"px\"); return this; &#125;&#125;(jQuery)); 使用方式：$(“p”).changeStyle({colorStr:”red”,fontSize:14});把参数放到一个对象中传给插件还有一个好处就是我们可以在插件内部为一些参数定义一些缺省值，例如： 123456789(function($)&#123; $.fn.changeStyle = function(option)&#123; var defaultSetting = &#123; colorStr:\"green\",fontSize:12&#125;; var setting = $.extend(defaultSetting,option); this.css(\"color\",setting.colorStr).css(\"fontSize\",setting.fontSize+\"px\"); return this; &#125;&#125;(jQuery)); 上面的代码用到了$.extend方法，这个方法在这里的用法就是合并两个对象，即把后面一个对象的存在的属性值赋值给第一个对象。$.extend方法还有一种作用是用来扩展jQuery对象本身。 这样定义的插件，我们在使用时如果不传fontSize，那么使用这个插件的jQuery对象标签的内容会被设置成默认的12px。使用方式： 12$(\"p\").changeStyle(&#123;colorStr:\"red\"&#125;); 注意：在为插件定义默认参数时，一定要把默认参数写在插件方法内部，这样默认参数的作用域就在插件内部。 定义插件的方式除了上面说的用$.fn来定义，还有另外一种方式来定义插件，那就是使用$.fn.extend方法。类似下面的写法： 1234567891011(function($)&#123; $.fn.extend(&#123; changeStyle:function(option)&#123; var defaultSetting = &#123; colorStr:\"green\",fontSize:12&#125;; var setting = $.extend(defaultSetting,option); this.css(\"color\",setting.colorStr).css(\"fontSize\",setting.fontSize+\"px\"); return this; &#125; &#125;);&#125;(jQuery)); PS:$.extend方法和$.fn.extend方法都可以用来扩展jQuery功能，通过阅读jQuery源码我们可以发现这两个方法的本质区别，那就是$.extend方法是在jQuery全局对象上扩展方法，$.fn.extend方法是在$选择符选择的jQuery对象上扩展方法。所以扩展jQuery的公共方法一般用$.extend方法，定义插件一般用$.fn.extend方法。 文章源自：留七七 http://www.jianshu.com/p/518d424d4994","tags":[{"name":"jquery","slug":"jquery","permalink":"https://shleyz.github.io/tags/jquery/"}]},{"title":"html5特性","date":"2017-07-12T07:53:19.000Z","path":"2017/07/12/html5新特性/","text":"1.新的文档类型 xhtml1.0:1&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt; 在html5中上面的方法失效： &lt;!DOCTYPE html&gt; 2.脚本和链接无需type 在HTML4或XHTML中：12&lt;link rel=\"stylesheet\" href=\"path/to/stylesheet.css\" type=\"text/css\" /&gt; &lt;script type=\"text/javascript\" src=\"path/to/script.js\"&gt;&lt;/script&gt; 在html5中：12&lt;link rel=\"stylesheet\" href=\"path/to/stylesheet.css\" /&gt; &lt;script src=\"path/to/script.js\"&gt;&lt;/script&gt; 3.新增语义化标签Header,Footer ,nav,aside,article,section。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889[&lt;article&gt;&lt;/article&gt;](http://www.w3school.com.cn/tags/tag_article.asp) ##article标签规定独立的自包含内容[&lt;aside&gt;&lt;/aside&gt;](http://www.w3school.com.cn/tags/tag_aside.asp) ##aside 的内容应该与附近的内容相关,可用作文章的侧栏。[&lt;audio src=\"\"&gt;提示&lt;/audio&gt;](http://www.w3school.com.cn/tags/tag_audio.asp) ##定义声音，比如音乐或其他音频流。[&lt;bdi dir=\"\"&gt;&lt;/bdi&gt;](http://www.w3school.com.cn/tags/tag_bdi.asp) ##定义文本的文本方向，使其脱离其周围文本的方向设置。[&lt;canvas&gt;&lt;/canvas&gt;](http://www.w3school.com.cn/tags/tag_canvas.asp) ##定义图形[&lt;command&gt;&lt;/command&gt;](http://www.w3school.com.cn/tags/tag_command.asp) ##定义命令按钮，比如单选按钮、复选框或按钮。[&lt;datalist&gt;&lt;/datalist&gt;](http://www.w3school.com.cn/tags/tag_datalist.asp) ##datalist 及其选项不会被显示出来，它仅仅是合法的输入值列表。[&lt;details&gt;&lt;/details&gt;](http://www.w3school.com.cn/tags/tag_details.asp) ##用于描述文档或文档某个部分的细节。其内部搭配使用summary标签和p标签。[&lt;summary&gt;&lt;/summary&gt;](http://www.w3school.com.cn/tags/tag_summary.asp) ##包含 details 元素的标题[&lt;dialog&gt;&lt;/dialog&gt; ](http://www.w3school.com.cn/tags/tag_dialog.asp) ##定义对话框或窗口。[&lt;embed src=\"\" type=\"\" /&gt;](http://www.w3school.com.cn/tags/tag_embed.asp) ##定义嵌入的内容，比如插件。[&lt;figcaption&gt;&lt;/figcaption&gt;](http://www.w3school.com.cn/tags/tag_figcaption.asp) ##定义 figure 元素的标题[&lt;figure&gt;&lt;/figure&gt;](http://www.w3school.com.cn/tags/tag_figure.asp) ##规定独立的流内容（图像、图表、照片、代码等等）[&lt;footer&gt;&lt;/footer&gt;](http://www.w3school.com.cn/tags/tag_footer.asp) ##页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等[&lt;header&gt;&lt;/header&gt;](http://www.w3school.com.cn/tags/tag_header.asp) ##定义文档的页眉（介绍信息）[&lt;keygen&gt;&lt;/keygen&gt;](http://www.w3school.com.cn/tags/tag_keygen.asp) ##规定用于表单的密钥对生成器字段[&lt;mark&gt;&lt;/mark&gt;](http://www.w3school.com.cn/tags/tag_mark.asp) ##定义带有记号的文本。[&lt;meter&gt;&lt;/meter&gt;](http://www.w3school.com.cn/tags/tag_meter.asp) ##使用 meter 元素来度量给定范围（gauge）内的数据[&lt;nav&gt;&lt;/nav&gt;](http://www.w3school.com.cn/tags/tag_nav.asp) ##定义导航链接的部分。[&lt;output&gt;&lt;/output&gt;](http://www.w3school.com.cn/tags/tag_output.asp) ##定义不同类型的输出，比如脚本的输出。[&lt;progress&gt;&lt;/progress&gt;](http://www.w3school.com.cn/tags/tag_progress.asp) ##标示任务的进度（进程）[&lt;rp&gt;&lt;/rp&gt;](http://www.w3school.com.cn/tags/tag_rp.asp) ##支持 \"ruby\" 元素的浏览器不会显示 \"rp\" 元素的内容。[&lt;rt&gt;&lt;/rt&gt;](http://www.w3school.com.cn/tags/tag_rt.asp) ##定义字符（中文注音或字符）的解释或发音[&lt;ruby&gt;&lt;/ruby&gt;](http://www.w3school.com.cn/tags/tag_ruby.asp) ##定义 ruby 注释（中文注音或字符）[&lt;section&gt;&lt;/section&gt;](http://www.w3school.com.cn/tags/tag_section.asp) ##文档中的区段[&lt;source /&gt;](http://www.w3school.com.cn/tags/tag_source.asp) ##为媒介元素（比如video和audio）定义媒介资源[&lt;time&gt;&lt;/time&gt;](http://www.w3school.com.cn/tags/tag_time.asp) ##定义公历的时间（24 小时制）或日期，时间和时区偏移是可选的。在任何浏览器中不会呈现任何特殊效果[&lt;track&gt;&lt;/track&gt;](http://www.w3school.com.cn/tags/tag_track.asp) ##为诸如 video 元素之类的媒介规定外部文本轨道[&lt;video src=\"\"&gt;&lt;/video&gt;](http://www.w3school.com.cn/tags/tag_video.asp) ##定义视频，比如电影片段或其他视频流[&lt;wbr&gt;&lt;/wbr&gt;](http://www.w3school.com.cn/tags/tag_wbr.asp) ##规定在文本中的何处适合添加换行符 4.window.navigator.geolocation","tags":[]},{"title":"CSS之盒子模型","date":"2017-07-10T06:22:32.000Z","path":"2017/07/10/CSS之盒子模型/","text":"1.盒子的内部结构：在一个文档中，每个元素都被表示为一个矩形的盒子。确定这些盒子的尺寸, 属性像它的颜色，背景，边框方面和位置是渲染引擎的目标。 模型是对某种事物本质特性的抽象。 一个独立的盒子模型由：content（内容），padding（内边距），border（边框）和margin（外边距）组成。 一个盒子的宽度由“content + 2 x（padding+border+margin）”组成。 2.内容区域content包含元素的真实内容，它通常包含背景，颜色和图片等，它的宽度为content-box的宽度。 如果 box-sizing 为默认值， width, min-width, max-width, height, min-height 与 max-height 控制内容大小。 3.内边距区域padding作用域content的背景、颜色等会延伸到padding上。即元素的背景颜色等属性的作用范围是content+padding。 他的宽是padding-box的宽度 4.边框border包含了边框的区域，他的宽是border-box的宽度 5 外边距margin用空白区域扩展元素，以分开相邻的元素。 它的大小为 margin-box 的高宽。 6.外边距塌陷块的顶部外边距和底部外边距有时被组合(折叠)为单个外边距，其大小是组合到其中的最大外边距，这种行为称为外边距塌陷(margin collapsing)，有的地方翻译为外边距合并。 发生外边距塌陷的三种情况 1.相邻的兄弟元素 123&lt;p style=\"margin-bottom: 30px;\"&gt;这个段落的下外边距被合并...&lt;/p&gt;&lt;p style=\"margin-top: 20px;\"&gt;...这个段落的上外边距被合并。&lt;/p&gt; 2.块级元素与它的第一个或最后一个子元素（前提是父元素与子元素中间没有border、padding、inline content、height、min-height、 max-height来分隔时）3.一个空的块级元素，其 border、padding、inline content、height、min-height 都不存在。那么此时它的上下边距中间将没有任何阻隔，此时它的上下外边距将会合并。 1234&lt;p style=\"margin-bottom: 0px;\"&gt;这个段落的和下面段落的距离将为20px&lt;/p&gt;&lt;div style=\"margin-top: 20px; margin-bottom: 20px;\"&gt;&lt;/div&gt;&lt;p style=\"margin-top: 0px;\"&gt;这个段落的和上面段落的距离将为20px&lt;/p&gt; 当有负边距存在时，合并后的外边距将是最大正边距加上最小负边距（即负边距中绝对值最大的一个）。 7.box-sizing用于更改用于计算元素宽度和高度的默认CSS盒子模型。box-sizing默认值：content-box。 默认是当设置元素的宽度width为100px时，实际是元素的content宽度是100px。 box-sizing设置为border-box时： 当设置元素的宽度width为100px时，其实是congtent+padding+border的宽度是100px。 box-sizing设置为padding-box时：(只有Firefox实现了这个值，它在Firefox 50中被删除。) 当设置元素的宽度width为100px时，其实是congtent+padding的宽度是100px。 因此box-sizing只有默认值content-box和border-box 实现兼容各个浏览器： 1234567891011121314151617Element &#123; -moz-box-sizing: content-box; -webkit-box-sizing: content-box; -o-box-sizing: content-box; -ms-box-sizing: content-box; box-sizing: content-box; &#125; Element &#123; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; -o-box-sizing: border-box; -ms-box-sizing: border-box; box-sizing: border-box; &#125; margin越界当父元素没有边框border时，设置第一个子元素的margin-top值的时候，会出现margin-top值加在父元素上的现象，解决方法有四个： （1）给父元素加边框border （副作用） （2）给父元素设置padding值 （副作用） （3）父元素添加 overflow：hidden （副作用） （4）父元素加前置内容生成。（推荐） 第四种方法的实现： 12345678910111213141516.parent&#123; width: 300px; height: 300px; background-color: cadetblue;&#125;.parent:before &#123; content : \"\"; display : table;&#125;.child&#123; width: 50px; height: 50px; margin: 20px; background-color: #9ea040;&#125; 绘制三角形123456.child&#123; width: 0; height: 0; border: 100px solid transparent; border-right: 100px solid yellow;&#125; 子元素浮动后父元素高度为0（父元素不设置高度）1234567891011.parent&#123; width: 300px; background-color: cadetblue;&#125;.child&#123; width: 50px; height: 50px; float:left; background-color: #4932ff;&#125; css如上,这时parent高度为0，不显示。 要解决这个问题 （1）overflow：hidden，但是这样有副作用。（2）为父元素设置后置内容生成： 12345678910111213141516.parent&#123; width: 300px; background-color: cadetblue;&#125;.parent:after&#123; content:' '; display: table; clear: both;&#125;.child&#123; width: 50px; height: 50px; float:left; background-color: #4932ff;&#125;","tags":[]}]