<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>雪林的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shleyz.github.io/"/>
  <updated>2021-02-03T06:05:38.000Z</updated>
  <id>https://shleyz.github.io/</id>
  
  <author>
    <name>雪林</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js路由跳转不刷新页面实现</title>
    <link href="https://shleyz.github.io/2021/02/02/interview-js%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E4%B8%8D%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E5%AE%9E%E7%8E%B0/"/>
    <id>https://shleyz.github.io/2021/02/02/interview-js路由跳转不刷新页面实现/</id>
    <published>2021-02-02T05:18:39.000Z</published>
    <updated>2021-02-03T06:05:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>利用 history API： state, pushState, replaceState。</p><h2 id="history-state"><a href="#history-state" class="headerlink" title="history.state"></a>history.state</h2><p>当前 url 的状态信息。如果当前 url 不是通过 pushState, replaceState 跳转过来的，那么 history.state 就是 null。</p><h2 id="history-pushState-state-title-url"><a href="#history-pushState-state-title-url" class="headerlink" title="history.pushState(state, title, url)"></a>history.pushState(state, title, url)</h2><p>将当前 URL 和 history.state 加入到 history 中，并用新的 state 和 URL 替换当前。不会造成页面刷新。<br>state：与要跳转到的URL对应的状态信息。<br>title：当前大多数浏览器都忽略此参数，但是将来可能会使用它。 在此处传递空字符串应该可以防止将来对方法的更改。 或者，您可以为要跳转到的地址传递简短标题。 如果需要更改标题，可以使用document.title。<br>url：要跳转到的URL地址，不能跨域。</p><h2 id="history-replaceState"><a href="#history-replaceState" class="headerlink" title="history.replaceState"></a>history.replaceState</h2><p>用新的state和URL替换当前。不会造成页面刷新。<br>state：与要跳转到的 URL 对应的状态信息。<br>title：当前大多数浏览器都忽略此参数，但是将来可能会使用它。 在此处传递空字符串应该可以防止将来对方法的更改。 或者，您可以为要跳转到的地址传递简短标题。 如果需要更改标题，可以使用document.title。<br>url：要跳转到的URL地址，不能跨域。</p><h2 id="window-onpop"><a href="#window-onpop" class="headerlink" title="window.onpop"></a>window.onpop</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;利用 history API： state, pushState, replaceState。&lt;/p&gt;
&lt;h2 id=&quot;history-state&quot;&gt;&lt;a href=&quot;#history-state&quot; class=&quot;headerlink&quot; title=&quot;history.sta
      
    
    </summary>
    
      <category term="javascript" scheme="https://shleyz.github.io/categories/javascript/"/>
    
    
      <category term="js基础" scheme="https://shleyz.github.io/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>antdPro</title>
    <link href="https://shleyz.github.io/2020/05/08/antdPro/"/>
    <id>https://shleyz.github.io/2020/05/08/antdPro/</id>
    <published>2020-05-08T02:21:02.000Z</published>
    <updated>2020-05-08T02:48:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者是这样描述的：dva 是 react 和 redux 的最佳实践。</p><p>而 antd-pro 就是作者把 UI 工具 antd，打包工具 roadhog，路由 react-router，状态管理器 dva 整合在一起</p><h2 id="dva-数据流"><a href="#dva-数据流" class="headerlink" title="dva 数据流"></a>dva 数据流</h2><ul><li><p>service：请求定义，并且按照 model 的维度进行拆分</p></li><li><p>utils/request.ts：统一的请求发送和错误处理</p></li><li><p>model: 处理数据逻辑部分，包含 state 初始值 和 reducers（相当于 redux 里面的 reducer，根据 action 来更新 state）</p></li></ul><h4 id="创建一个页面，除了需要配置相应的路由和权限，还需要两个部分，一个是-ui-组件，另一个就是-model-部分。"><a href="#创建一个页面，除了需要配置相应的路由和权限，还需要两个部分，一个是-ui-组件，另一个就是-model-部分。" class="headerlink" title="创建一个页面，除了需要配置相应的路由和权限，还需要两个部分，一个是 ui 组件，另一个就是 model 部分。"></a>创建一个页面，除了需要配置相应的路由和权限，还需要两个部分，一个是 ui 组件，另一个就是 model 部分。</h4><h4 id="在组件内部调用-dispatch-方法，根据传的-type-来执行-model-里面的对应的命名空间的-effects，进而可以修改-state-值。"><a href="#在组件内部调用-dispatch-方法，根据传的-type-来执行-model-里面的对应的命名空间的-effects，进而可以修改-state-值。" class="headerlink" title="在组件内部调用 dispatch 方法，根据传的 type 来执行 model 里面的对应的命名空间的 effects，进而可以修改 state 值。"></a>在组件内部调用 dispatch 方法，根据传的 type 来执行 model 里面的对应的命名空间的 effects，进而可以修改 state 值。</h4><h4 id="在-UI-组件内部使用高阶组件-connect-包裹组件，可以在组件内部使用-model-里面的-state。"><a href="#在-UI-组件内部使用高阶组件-connect-包裹组件，可以在组件内部使用-model-里面的-state。" class="headerlink" title="在 UI 组件内部使用高阶组件 connect 包裹组件，可以在组件内部使用 model 里面的 state。"></a>在 UI 组件内部使用高阶组件 connect 包裹组件，可以在组件内部使用 model 里面的 state。</h4><h2 id="1-组件内部调用-dispatch-一个-action，需要指定命名空间的-model-里面的-action："><a href="#1-组件内部调用-dispatch-一个-action，需要指定命名空间的-model-里面的-action：" class="headerlink" title="1. 组件内部调用 dispatch 一个 action，需要指定命名空间的 model 里面的 action："></a>1. 组件内部调用 dispatch 一个 action，需要指定命名空间的 model 里面的 action：</h2><p><img src="https://user-images.githubusercontent.com/11802509/81363902-fbead280-9116-11ea-80fc-172b86c984f1.png" alt="dispatch"></p><h2 id="2-model-部分"><a href="#2-model-部分" class="headerlink" title="2. model 部分"></a>2. model 部分</h2><p><img src="https://user-images.githubusercontent.com/11802509/81364365-0a85b980-9118-11ea-886a-3d73f3b95c8f.png" alt="dispatch"></p><h2 id="3-services-里面进行-请求的定义"><a href="#3-services-里面进行-请求的定义" class="headerlink" title="3. services 里面进行 请求的定义"></a>3. services 里面进行 请求的定义</h2><p><img src="https://user-images.githubusercontent.com/11802509/81364456-43259300-9118-11ea-908d-4536a8f756a3.png" alt="dispatch"></p><h3 id="一个-model-里面会有这些属性"><a href="#一个-model-里面会有这些属性" class="headerlink" title="一个 model 里面会有这些属性:"></a>一个 model 里面会有这些属性:</h3><ul><li><p>state：model 的状态数据，一般是不可变的，只有 action 才能修改 state 值</p></li><li><p>action：改变 state 的唯一途径，需要 dispatch 来触发 action，需要传一个 type 值，来指定 state 的修改。 dispatch 一般在组件 connect 以后从 props 里面可以获取到</p></li><li><p>dispatch：触发 action 的函数，在组件 connect 以后从 props 里面可以获取到 dispatch</p></li><li><p>reducers：是一个纯函数，接收 state 和 action，返回新的 state , 同步修改状态</p></li><li><p>effect：多用于异步修改状态，将异步操作转换成同步的写法，来实现纯函数</p></li><li>subscription：订阅一个数据源，根据条件来 dispacth 一个 action，一般用来监听路由变化</li></ul><p>此外每个 model 还需要定义一个 namespace 命名空间，也是全局 state 里面的属性，</p><p>例如 connect 指定的 state 时会用到，dispatch 指定的命名空间的 effects 也会用到</p><h3 id="model-里面的-effect-的使用"><a href="#model-里面的-effect-的使用" class="headerlink" title="model 里面的 effect 的使用:"></a>model 里面的 effect 的使用:</h3><ul><li>call 一般用来调用 api 接口，并可以获取到返回值</li><li>put 大致与 dispatch 相同，可让 effects 里的方法调用修改 state 的方法</li><li>select 用于获取 state 变量<br>此外 antd-pro 引入了 typescript，对 js 代码进行的类型检测，配合 tslint，能够严格约束代码的编写，虽然有些时候遇到的一些类型警报，可以用 any 类型解决，但是非常不建议这样做。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者是这样描述的：dva 是 react 和 redux 的最佳实践。&lt;/p&gt;
&lt;p&gt;而 antd-pro 就是作者把 UI 工具 antd，打包工具 roadhog，路由 react-router，状态管理器 dva 整合在一起&lt;/p&gt;
&lt;h2 id=&quot;dva-数据流&quot;&gt;
      
    
    </summary>
    
      <category term="antdPro" scheme="https://shleyz.github.io/categories/antdPro/"/>
    
    
      <category term="antdPro" scheme="https://shleyz.github.io/tags/antdPro/"/>
    
  </entry>
  
  <entry>
    <title>js单线程和事件循环</title>
    <link href="https://shleyz.github.io/2020/04/02/interview-js%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/"/>
    <id>https://shleyz.github.io/2020/04/02/interview-js单线程相关/</id>
    <published>2020-04-02T06:06:14.000Z</published>
    <updated>2021-02-03T06:05:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js单线程"><a href="#js单线程" class="headerlink" title="js单线程"></a>js单线程</h2><p>javascript 作为一个浏览器端语言，最主要任务是处理用户的交互，而用户的交互主要就是对 dom 的增删改查。如果设计成多线程，一个线程在某个DOM节点上面新增内容，另一个线程删除了这个节点。那浏览器要怎么显示，以哪个为准。</p><p>单线程意味着，所有的任务都要排队，在一个队列里面。前一个任务结束，后一个任务才能开始。如果前一个任务耗时很长，后面的任务就得一直等待，例如一个接口请求等待读取数据时。</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>后面的任务完全可以在前一个任务没有完成前执行，也就是把等待中的任务暂时挂起，先运行排在后面的任务，等挂起的任务完成或有了返回，再继续执行挂起的任务。</p><p>因此有了两种任务：</p><ul><li>同步任务： 立即执行的任务，同步任务一般会直接进入到主线程中执行。</li><li>异步任务： 例如 Ajax回调函数、DOM 事件回调函数、setTimeout/setInterval回调函数等, 通过任务队列来进行协调。</li></ul><p>同步任务和异步任务分别进入不同的执行环境:</p><ul><li>同步任务进入主线程，也就是主执行栈。</li><li>异步任务进入 Event Quene。</li></ul><p>主执行栈内的任务执行完毕，会去 Event Quene 读取对应的任务，推入主程执行。上面的过程重复执行就是 Event Loop <strong>事件循环</strong>。</p><p>在事件循环中，每进行一次循环成为一次 tick。每一次 tick 的任务处理模型都是很复杂的：</p><ul><li>在此次 tick 中选择最先进入队列的任务（oldest）。如果有则执行。</li><li>检查是否存在 microtasks（微任务），如果存在则不停的执行，直至清空 microtasks 队列。</li><li>更新 Render</li><li>主线程重复执行上述步骤</li></ul><p>宏任务：setTimeout、setInterval, Ajax，DOM事件<br>微任务：Promise async/await</p><h2 id="例子1-简单："><a href="#例子1-简单：" class="headerlink" title="例子1 简单："></a>例子1 简单：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure><p>分析上面代码：</p><ol><li>整体 script 作为第一个宏任务进入主线程，遇到 console.log(‘script start’), 输出 script start；</li><li>遇到 setTimeout， 其回调函数被分发到宏任务的 Event Quene中；</li><li>遇到 Promise, 其 then 函数被分到微任务 Event Quene 中，记为 then1, 之后又遇到了 then 函数，将其分到微任务 Event Quene 中，记为 then2；</li><li>遇到 console.log(‘script end’), 输出 script end；</li></ol><p>现在 Event Quene 中存在三个任务：</p><table><thead><tr><th>宏任务</th><th style="text-align:right">微任务</th></tr></thead><tbody><tr><td>setTimeout</td><td style="text-align:right">then1</td></tr><tr><td>—</td><td style="text-align:right">then2</td></tr></tbody></table><p>然后：</p><ol start="5"><li>执行微任务， 首先执行 then1, 输出 promise1， 然后执行 then2, 输出 promise2；此时清空了所有的微任务；</li><li>执行 setTimeout，输出 setTimeout。</li></ol><p>所以执行完输出顺序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure><h2 id="例子2-复杂："><a href="#例子2-复杂：" class="headerlink" title="例子2 复杂："></a>例子2 复杂：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout1'</span>);</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'timeout2'</span>), <span class="number">10</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure><p>分析：</p><ol><li>整体 script 作为第一个宏任务进入主线程，遇到 console.log(‘script start’), 输出 script start；</li><li>遇到 setTimeout， 其回调函数被分发到宏任务的 Event Quene中， 记为 setTimeout1；</li><li>遇到 Promise，new Promise 中代码立即执行， 输出 promise1 </li><li>将 Promise 的 then 放到微任务中去，记为 then1</li><li>遇到 console.log(‘script end’)， 输出 script end</li></ol><p>现在 Event Quene 中存在三个任务：</p><table><thead><tr><th>宏任务</th><th style="text-align:right">微任务</th></tr></thead><tbody><tr><td>setTimeout1</td><td style="text-align:right">then1</td></tr><tr><td>setTimeout2</td><td style="text-align:right">—–</td></tr></tbody></table><ol start="6"><li>依次执行微任务，直至清空微任务，输出： then1</li><li>依次执行宏任务，输出： timeout1， timeout2</li></ol><p>所以执行完输出顺序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// then1</span></span><br><span class="line"><span class="comment">// timeout1</span></span><br><span class="line"><span class="comment">// timeout2</span></span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>微任务优先于宏任务，所以有需要优先执行的逻辑，放入微任务队列会更早的执行。</p><p>最后：JS是单线程语言，所有的任务都放在事件循环队列里面，等待主执行栈来执行，并没有专门的异步线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;js单线程&quot;&gt;&lt;a href=&quot;#js单线程&quot; class=&quot;headerlink&quot; title=&quot;js单线程&quot;&gt;&lt;/a&gt;js单线程&lt;/h2&gt;&lt;p&gt;javascript 作为一个浏览器端语言，最主要任务是处理用户的交互，而用户的交互主要就是对 dom 的增删改查。
      
    
    </summary>
    
      <category term="javascript" scheme="https://shleyz.github.io/categories/javascript/"/>
    
    
      <category term="js基础" scheme="https://shleyz.github.io/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>js实现图片懒加载</title>
    <link href="https://shleyz.github.io/2020/04/02/interview-js%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <id>https://shleyz.github.io/2020/04/02/interview-js实现图片懒加载/</id>
    <published>2020-04-02T05:17:48.000Z</published>
    <updated>2021-02-03T06:09:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要原理是判断图片是否在可视区域内部，图片移动到可视区域内部，进行加载。</p><p>有三种判断方法：</p><ul><li><ol><li>offsetTop &lt; clientHeight + scrollTop</li></ol></li><li><ol start="2"><li>element.getBoundingClientRect().top &lt; clientHeight. 缺点是，由于 scroll 事件密集发生，计算量很大，容易造成性能问题。</li></ol></li><li><ol start="3"><li>IntersectionObserver, 使用方法：</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(callback, option);</span><br></pre></td></tr></table></figure><p>IntersectionObserver 是浏览器原生提供的构造函数，接受两个参数：callback 是可见性变化时的回调函数，option 是配置对象（该参数可选）。</p><p>使用方法三实现懒加载的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> query = <span class="function">(<span class="params">selector</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(selector));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">changes</span>) =&gt;</span> &#123;</span><br><span class="line">  changes.forEach(<span class="function">(<span class="params">change</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> container = change.target;</span><br><span class="line">    <span class="keyword">const</span> content = container.querySelector(<span class="string">'template'</span>).content;</span><br><span class="line">    container.appendChild(content);</span><br><span class="line">    observer.unobserve(container)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">query(<span class="string">'.lazy-load'</span>).forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  observer.observer(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，只有目标区域可见时，才会将模板内容插入真实 DOM，从而引发静态资源的加载。</p><p>注：<br><strong>clientHeight</strong><br>  表示页面可见区域的高度, 只包括 padding, 不包括 border<br><strong>offsetHeight</strong><br>  表示页面可见区域的高度，包括 border<br><strong>scrollTop</strong><br>  表示网页被卷去的高，就是滚动条上滚的页面高度<br><strong>element.getBoundingClientRect()</strong><br>  表示获取某个元素 element 相对于视窗的位置集合。<br><strong>element.getBoundingClientRect().top</strong><br>  表示获取某个元素 element 相对于视窗的顶部的距离。<br><strong>window.screen.height</strong><br>  表示屏幕分辨率高</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要原理是判断图片是否在可视区域内部，图片移动到可视区域内部，进行加载。&lt;/p&gt;
&lt;p&gt;有三种判断方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;offsetTop &amp;lt; clientHeight + scrollTop&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;
      
    
    </summary>
    
      <category term="javascript" scheme="https://shleyz.github.io/categories/javascript/"/>
    
    
      <category term="js基础" scheme="https://shleyz.github.io/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>dart学习</title>
    <link href="https://shleyz.github.io/2020/02/13/dart%E5%AD%A6%E4%B9%A0/"/>
    <id>https://shleyz.github.io/2020/02/13/dart学习/</id>
    <published>2020-02-13T09:36:57.000Z</published>
    <updated>2020-03-13T10:18:10.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>Dart 要求以 main 函数作为执行的入口</p></li><li><p>变量的声明可以用 var 或者 具体的类型，当使用 var 定义变量时，编译器会推断决定变量的类型。</p></li><li><p>默认未初始化的变量都是 null</p></li><li><p>Dart 是类型安全的语言，所有的类型都是对象，继承自 Object。一切类型的值都是对象的实例，包括数字，布尔，函数和 null</p></li><li><p>Dart 内置数据类型: num</p><ul><li>num 只有两种子类： 64 位 int 和 64 位 double（符合 IEEE 754 标准的）</li><li>64 位 int 代表整数类型， 64 位 double 代表浮点数</li><li>继承自num的运算符有 +,-,*,/,%,abs()绝对值,round()取整,还有&lt;,&gt;等比较运算符</li><li>dart:math 库提供了诸如三角函数、指数、对数、平方根等高级函数</li></ul></li><li><p>Dart 内置数据类型: bool</p><p>  因为 Dart 类型是安全的，所以不能在 if 判断或者 assert 中使用非布尔类型。</p></li><li><p>Dart 内置数据类型: String</p><p>  使用 ‘ 或者 “ 来表示字符串字面量<br>  ${express} 可以在字符串中嵌入变量<br>  ‘+’ 可以实现字符串的拼接<br>  ‘’’jksdhk<br>  jashdkjas<br>  dgkhjas’’’可以实现多行字符输出</p></li><li><p>Dart 内置数据类型: List</p><ul><li>声明方法一： var arr1 = <string>[“Tom”, “Andy”, “Jack”];</string></li><li>声明方法二： var arr2 = new List<int>.of([1,2,3]);</int></li><li>数组添加元素： arr2.add(499); // 添加的元素类型必须与数组里面元素类型一致。</li><li>数组遍历： arr2.forEach((v) =&gt; print(‘${v}’));</li></ul></li><li><p>Dart 内置数据类型: Map</p><ul><li>声明方法一： var map1 = {‘name’: ‘Tom’,’sex’: ‘male’,};;</li><li>声明方法二： var map2 = new Map<string string>();</string></li><li>数组添加元素： map2[‘name’] = ‘Tom’; // 添加的元素类型必须与Map里面元素类型一致。</li><li>数组遍历： map2.forEach((k,v) =&gt; print(‘${k}: ${v}’));</li></ul></li><li><p>Dart 常量，使用 final 或者 const 声明</p><ul><li>const，表示变量在编译期间即能确定的值；</li><li>final 则不太一样，用它定义的变量可以在运行时确定值，而一旦确定后就不可再变。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;Dart 要求以 main 函数作为执行的入口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;变量的声明可以用 var 或者 具体的类型，当使用 var 定义变量时，编译器会推断决定变量的类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;默认未初始化的变量都是 null&lt;/p
      
    
    </summary>
    
      <category term="dart" scheme="https://shleyz.github.io/categories/dart/"/>
    
    
      <category term="dart" scheme="https://shleyz.github.io/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>前端安全问题-CSRF跨站请求伪造</title>
    <link href="https://shleyz.github.io/2020/02/04/interview-%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-CSRF%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
    <id>https://shleyz.github.io/2020/02/04/interview-前端安全问题-CSRF跨站请求伪造/</id>
    <published>2020-02-04T09:10:19.000Z</published>
    <updated>2021-02-04T10:24:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>攻击者盗用了受害者的身份，以受害者的名义发送恶意请求。例如以受害者的名义发送邮件、发消息，盗取账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。</p><p>CSRF 攻击必须具备两个流程：</p><ul><li>用户访问了受信任网站A， 并在本地生成 cookie</li><li>在不登出 A 的情况下，访问危险网站 B, B 会在接收到请求后，返回一些攻击性代码，并发出请求访问网站 A</li></ul><p>预防，一般由服务端来解决：</p><ul><li>服务端同源策略，设置受信任网站白名单，禁止外域访问</li><li>只允许同源网站提交请求携带 cookie</li><li>尽量使用 POST 请求</li><li>请求携带 tooken</li><li>通过请求头中的 Referer，来识别请求来源是否合法</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;攻击者盗用了受害者的身份，以受害者的名义发送恶意请求。例如以受害者的名义发送邮件、发消息，盗取账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。&lt;/p&gt;
&lt;p&gt;CSRF 攻击必须具备两个流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户访问了受信任网站A， 并在本地生成 cooki
      
    
    </summary>
    
      <category term="javascript" scheme="https://shleyz.github.io/categories/javascript/"/>
    
    
      <category term="js基础" scheme="https://shleyz.github.io/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>前端安全问题-XSS跨站脚本攻击</title>
    <link href="https://shleyz.github.io/2020/02/04/interview-%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/"/>
    <id>https://shleyz.github.io/2020/02/04/interview-前端安全问题-XSS跨站脚本攻击/</id>
    <published>2020-02-04T06:37:33.000Z</published>
    <updated>2021-02-04T09:10:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XSS（Cross-Site-Scripting）跨站脚本攻击"><a href="#XSS（Cross-Site-Scripting）跨站脚本攻击" class="headerlink" title="XSS（Cross Site Scripting）跨站脚本攻击"></a>XSS（Cross Site Scripting）跨站脚本攻击</h2><p>攻击者在 WEB 页面插入恶意 script 代码，在用户浏览页面时，被执行，从而达到某些目的。</p><p>例如攻击者在输入框内输入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="string">'hey, you are attacked!'</span>)&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这样这段代码很可能会在浏览器解析的时候被执行，今天弹出信息框。</p><p>在实际情况中，攻击者不会简单的这样操作，恶意植入代码的作用有很多，例如：</p><ul><li>窃取用户信息，cookie 或者本地 用户认证</li><li>劫持流量实现恶意跳转等</li></ul><p>XSS种类分为： </p><ul><li>反射型 XSS： 通过在访问的 url 中加入恶意脚本传递给服务器</li><li>存储型 XSS： 攻击者将恶意代码提交到服务器中，普通用户访问时服务器将恶意代码返回，浏览器默认执行。</li></ul><h3 id="REACT-本身对-XSS攻-击的处理："><a href="#REACT-本身对-XSS攻-击的处理：" class="headerlink" title="REACT 本身对 XSS攻 击的处理："></a>REACT 本身对 XSS攻 击的处理：</h3><ol><li><strong>在React中，React 虚拟 DOM 会在渲染所有输入内容之前，进行转义(‘’，””, &amp;, &lt;, &gt;)，所有内容在渲染之前都变成了字符串，因此恶意代码无法注入，从而有效防止了 XSS 攻击。</strong></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一段恶意代码</span></span><br><span class="line">&lt;img src=<span class="string">"empty.png"</span> onerror =<span class="string">"alert('xss')"</span>&gt; </span><br><span class="line"><span class="comment">// 转义后输出到 html 中</span></span><br><span class="line">&amp;lt;img src=&amp;quot;empty.png&amp;quot; onerror =&amp;quot;alert(&amp;#x27;xss&amp;#x27;)&amp;quot;&amp;gt;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>React 的 JSX 语法， 在经过babel 编译后变成 React.createElement() 调用：</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1 className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 通过 babel 编译后的代码</span></span><br><span class="line"><span class="regexp">const element = React.createElement(</span></span><br><span class="line"><span class="regexp">  'h1',</span></span><br><span class="line"><span class="regexp">  &#123;className: 'greeting'&#125;,</span></span><br><span class="line"><span class="regexp">  'Hello, world!'</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ React.createElement() 方法返回的 ReactElement</span></span><br><span class="line"><span class="regexp">const element = &#123;</span></span><br><span class="line"><span class="regexp">  $$typeof: Symbol('react.element'),</span></span><br><span class="line"><span class="regexp">  type: 'h1',</span></span><br><span class="line"><span class="regexp">  key: null,</span></span><br><span class="line"><span class="regexp">  props: &#123;</span></span><br><span class="line"><span class="regexp">    children: 'Hello, world!',</span></span><br><span class="line"><span class="regexp">      className: 'greeting'   </span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  ...</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="REACT-中可能引起漏洞的写法："><a href="#REACT-中可能引起漏洞的写法：" class="headerlink" title="REACT 中可能引起漏洞的写法："></a>REACT 中可能引起漏洞的写法：</h3><ol><li>使用 dangerouslySetInnerHTML</li></ol><p>dangerouslySetInnerHTML 是 React 为浏览器 DOM 提供的直接修改 innerHTML 的替换方案。</p><p>使用代码直接设置 HTML 会有风险，如果一定要使用，需要手动设置过滤、转义等。</p><ol start="2"><li>通过用户设置图片的 src 值，或者链接的 href。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> site = <span class="string">"javascript:alert('xss');"</span>;</span><br><span class="line">&lt;a href=&#123;site&#125;&gt;&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure><p>如果没有对 URL 进行 javascript: 和 data: 过滤， 就可能会造成 XSS 攻击。</p><h3 id="服务器需要做的对-XSS攻-击的处理："><a href="#服务器需要做的对-XSS攻-击的处理：" class="headerlink" title="服务器需要做的对 XSS攻 击的处理："></a>服务器需要做的对 XSS攻 击的处理：</h3><ol><li>接收浏览器端数据进行过滤处理，移除特殊的 HTML 标签，和 JS 关键字。</li><li>返回数据时针对类型，进行转义</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;XSS（Cross-Site-Scripting）跨站脚本攻击&quot;&gt;&lt;a href=&quot;#XSS（Cross-Site-Scripting）跨站脚本攻击&quot; class=&quot;headerlink&quot; title=&quot;XSS（Cross Site Scripting）跨站脚本攻
      
    
    </summary>
    
      <category term="javascript" scheme="https://shleyz.github.io/categories/javascript/"/>
    
    
      <category term="js基础" scheme="https://shleyz.github.io/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>https的对称加密和非对称加密</title>
    <link href="https://shleyz.github.io/2020/02/04/interview-https%E7%9A%84%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    <id>https://shleyz.github.io/2020/02/04/interview-https的对称加密和非对称加密/</id>
    <published>2020-02-04T06:02:49.000Z</published>
    <updated>2021-02-04T06:28:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>加密类型：</p><ul><li>对称加密， 加密解密用的是同样的钥匙</li><li>非对称加密， 加密解密用的是不同的钥匙</li></ul><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>A 把一个箱子锁上， 用钥匙AY.<br>然后把箱子寄给B<br>B 用同样的钥匙 AY, 可以打开箱子，同样可以锁上箱子，寄给 A.</p><p>对称加密分为两种，一种是一个一个加密，一种是分块加密。</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>B 有钥匙（私钥），B 把开着的箱子（和公钥）寄给 A;<br>A 把信息放在箱子里， 然后锁上（用公钥加密），寄给 B;<br>B 拿自己的钥匙（私钥）把箱子打开。</p><p>这种方式的好处是，不需要你不需要别人的钥匙。也就避免了出现在钥匙发送过程中复制钥匙，窃取信息。<br>信息接受者有两把钥匙：一把“公匙”，一把“私匙”。公匙是给信息发送者用来加密的，私匙是自己用来解密的。<br>这样最大的好处是：不必通过不安全的渠道发送私密的东西。公匙本来就是给别人用的，不用藏好。你的私匙在你产生私匙的电脑里保存着</p><h2 id="https-的-SSL-加密-运用了对称加密和非对称加密"><a href="#https-的-SSL-加密-运用了对称加密和非对称加密" class="headerlink" title="https 的 SSL 加密(运用了对称加密和非对称加密)"></a>https 的 SSL 加密(运用了对称加密和非对称加密)</h2><p>SSL (Secure Sockets Layer) 是用来保障浏览器和网站服务器之间安全通信，免受网络“中间人”窃取信息。</p><p>SSL原理：</p><ul><li>当你的浏览器向服务器请求一个安全的网页(通常是 https://)；</li><li>服务器返回证书和公钥</li><li>浏览器检测证书是否有效，是否属于访问的域名</li><li>浏览器确认证书有效后，使用公钥加密 URL 和 一个随机对称密钥， 发送到服务器。<br><strong>URL + 随机生成的对称密钥A ==》 公钥加密 ==》 发送到服务器</strong></li><li>服务器用私钥解密了收到的信息<br><strong>服务器私钥解密 ==》 得到 URL + 随机生成的对称密钥 ==》 对称密钥A解密 URL ==&gt; 得到解密后的 URL</strong></li><li>服务器把整合的需要的资源 用对称密钥加密，发送给浏览器。<br><strong>需要返回的资源 ==》 对称密钥A加密 ==》 浏览器接收</strong></li><li>浏览器使用对称密钥解密资源<br><strong>接收的加密资源 ==》 对称密钥A解密 ==》 得到解密后的信息</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;加密类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对称加密， 加密解密用的是同样的钥匙&lt;/li&gt;
&lt;li&gt;非对称加密， 加密解密用的是不同的钥匙&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;对称加密&quot;&gt;&lt;a href=&quot;#对称加密&quot; class=&quot;headerlink&quot; title=&quot;对称加
      
    
    </summary>
    
      <category term="javascript" scheme="https://shleyz.github.io/categories/javascript/"/>
    
    
      <category term="js基础" scheme="https://shleyz.github.io/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>js性能优化相关</title>
    <link href="https://shleyz.github.io/2020/02/03/interview-js%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/"/>
    <id>https://shleyz.github.io/2020/02/03/interview-js性能优化相关/</id>
    <published>2020-02-03T10:05:05.000Z</published>
    <updated>2021-02-04T03:36:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="性能优化有："><a href="#性能优化有：" class="headerlink" title="性能优化有："></a>性能优化有：</h2><h3 id="nginx-开启-gzip-压缩。"><a href="#nginx-开启-gzip-压缩。" class="headerlink" title="nginx 开启 gzip 压缩。"></a>nginx 开启 gzip 压缩。</h3><h3 id="非核心代码异步加载"><a href="#非核心代码异步加载" class="headerlink" title="非核心代码异步加载:"></a>非核心代码异步加载:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"script.js"</span>&gt;&lt;<span class="regexp">/script&gt;  /</span><span class="regexp">/ 正常加载脚本</span></span><br><span class="line"><span class="regexp">&lt;script async src="script.js"&gt;&lt;/</span>script&gt; <span class="comment">// 使用 async 异步加载</span></span><br><span class="line">&lt;script defer src=<span class="string">"myscript.js"</span>&gt;&lt;<span class="regexp">/script&gt; /</span><span class="regexp">/ 使用 defer 异步加载</span></span><br></pre></td></tr></table></figure><p>async 和 defer 的区别：</p><p>两者的读取都是在加载其他后续文档和渲染时一起加载，都是异步加载。<br>但是执行的时间不同：</p><ul><li>async 是异步加载完成后立即异步执行</li><li>defer 要等其他元素解析完成之后才能执行</li></ul><h3 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h3><p>webpack 3/4 自带按需加载</p><ul><li>对于 import 的内容进行处理，新建一个chunk。</li><li>当代码执行到 import 才会加载对应的 chunk 内容。</li><li>import 返回的是一个 Promise， 只有加载成功才能获取到加载的内容。</li></ul><h3 id="提取公共-chunk"><a href="#提取公共-chunk" class="headerlink" title="提取公共 chunk"></a>提取公共 chunk</h3><p>对于 webpack 的chunks, 可能出现公用的组件，如果不进行处理，会出现：</p><ul><li>相同的资源被重复的加载，浪费用户的流量和服务器的成本；</li><li>每个页面需要加载的资源太大，导致首次加载缓慢，影响用户体验；</li></ul><p>这里就需要用到 提取公共 chunks。</p><p><strong>（要知道这样并不会降低页面首次加载的资源大小，反而有可能加大资源的大小。但是对于后面子页面资源的加载性能会有显著性提升。）</strong></p><p>公共组件提取的实现：</p><ul><li>使用 webpack3 内置的 CommonsChunkPlugin， 需要说明哪些chunk需要单独提取出来，以及拆分出来 chunks 的命名；</li><li>使用 webpack4 的 optimization.splitChunks: 需要在 缓存组 cacheGroups 里面定义拆分规则：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">optimization: &#123;</span><br><span class="line">  minimize: <span class="literal">true</span>,</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    chunks: <span class="string">'all'</span>,</span><br><span class="line">    minSize: <span class="number">30000</span>, <span class="comment">// 提取出的 chunk 的最小大小</span></span><br><span class="line">    minChunks: <span class="number">3</span>,  <span class="comment">// 模块被引用 3 次以上的才抽离</span></span><br><span class="line">    automaticNameDelimiter: <span class="string">'.'</span>, </span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">      vendor: &#123;</span><br><span class="line">        name: <span class="string">`vendors`</span>, <span class="comment">// chunk 名</span></span><br><span class="line">        test: <span class="regexp">/[\\/]node_modules[\\/]/</span>, <span class="comment">// 提取所有 node_modules 里面的引用</span></span><br><span class="line">        priority: <span class="number">10</span>, </span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="使用-CDN-加载"><a href="#使用-CDN-加载" class="headerlink" title="使用 CDN 加载"></a>使用 CDN 加载</h3><p>浏览器第一次打开页面时，缓存是起不了作用的。这个时候，CDN就上场了。</p><h3 id="DNS预解析：-http-equiv"><a href="#DNS预解析：-http-equiv" class="headerlink" title="DNS预解析： http-equiv"></a>DNS预解析： http-equiv</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-dns-prefetch-control"</span> <span class="attr">content</span>=<span class="string">"on"</span>&gt;</span> <span class="comment">&lt;!-- 强制打开 DNS 预解析 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"http://www.smyhvae.com/"</span>&gt;</span>  <span class="comment">&lt;!-- 对指定的域名（第三方资源）进行DNS预解析 --&gt;</span></span><br></pre></td></tr></table></figure><p>需要说明的是在一些高级浏览器里面对于超链接<a>标签， 默认开启了DNS预解析，</a></p><p>但是如果是 https 协议，很多浏览器是关闭了DNS预解析， 如果加上 meta 会强制打开 DNS 预解析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;性能优化有：&quot;&gt;&lt;a href=&quot;#性能优化有：&quot; class=&quot;headerlink&quot; title=&quot;性能优化有：&quot;&gt;&lt;/a&gt;性能优化有：&lt;/h2&gt;&lt;h3 id=&quot;nginx-开启-gzip-压缩。&quot;&gt;&lt;a href=&quot;#nginx-开启-gzip-压缩。&quot; c
      
    
    </summary>
    
      <category term="javascript" scheme="https://shleyz.github.io/categories/javascript/"/>
    
    
      <category term="js基础" scheme="https://shleyz.github.io/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>js/css实现持续动画,以及对比</title>
    <link href="https://shleyz.github.io/2020/02/03/interview-js%E5%AE%9E%E7%8E%B0%E6%8C%81%E7%BB%AD%E5%8A%A8%E7%94%BB/"/>
    <id>https://shleyz.github.io/2020/02/03/interview-js实现持续动画/</id>
    <published>2020-02-03T06:06:23.000Z</published>
    <updated>2021-02-03T06:33:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用-window-requestAnimationFrame"><a href="#使用-window-requestAnimationFrame" class="headerlink" title="使用 window.requestAnimationFrame()"></a>使用 window.requestAnimationFrame()</h2><p>告诉浏览器你希望执行一个动画， 并且要求浏览器在下次重绘之前调用指定的回调函数执行动画。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Animate: React.FC&lt;&#123;&#125;&gt; = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// const ele = document.getElementById('animal');</span></span><br><span class="line">  <span class="keyword">const</span> [translateX, settranslateX] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">var</span> start = <span class="literal">undefined</span> <span class="keyword">as</span> any;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> step = <span class="function">(<span class="params">timestamp: number</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(start === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      start = timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> elapsed = timestamp - start;</span><br><span class="line">    settranslateX(<span class="built_in">Math</span>.min(<span class="number">0.1</span>*elapsed, <span class="number">200</span>))</span><br><span class="line">    <span class="keyword">if</span>(elapsed &lt; <span class="number">2000</span>) &#123;</span><br><span class="line">      <span class="built_in">window</span>.requestAnimationFrame(step)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onBegin = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(step)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;&#123;<span class="attr">width</span>: <span class="string">'100%'</span>, <span class="attr">textAlign</span>: <span class="string">'center'</span>&#125;&#125;&gt;</span><br><span class="line">      &lt;div </span><br><span class="line">        id=<span class="string">"animal"</span> </span><br><span class="line">        style=&#123;&#123;</span><br><span class="line">          width: <span class="number">100</span>,</span><br><span class="line">          height: <span class="number">100</span>,</span><br><span class="line">          borderRadius: <span class="string">'50%'</span>,</span><br><span class="line">          backgroundColor: <span class="string">'#000'</span>,</span><br><span class="line">          transform: <span class="string">`translateX(<span class="subst">$&#123;translateX&#125;</span>px)`</span></span><br><span class="line">        &#125;&#125; /&gt;</span><br><span class="line">      &lt;Button onClick=&#123;onBegin&#125;&gt;</span><br><span class="line">        开始</span><br><span class="line">      &lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Animate;</span><br></pre></td></tr></table></figure><h2 id="使用css3来实现动画"><a href="#使用css3来实现动画" class="headerlink" title="使用css3来实现动画:"></a>使用css3来实现动画:</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.animal</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="comment">/* position: absolute; */</span></span><br><span class="line">  <span class="attribute">animation</span>: horizonMove <span class="number">5s</span> linear infinite;</span><br><span class="line">  <span class="attribute">-moz-animation</span>: horizonMove <span class="number">5s</span> linear infinite;<span class="comment">/* Firefox */</span></span><br><span class="line">  <span class="attribute">-webkit-animation</span>: horizonMove <span class="number">5s</span> linear infinite;<span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">  <span class="attribute">-o-animation</span>: horizonMove <span class="number">5s</span> linear infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> horizonMove &#123;</span><br><span class="line">  <span class="selector-tag">form</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">500px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"animal"</span> className=&#123;style.animal&#125; /&gt;</span><br></pre></td></tr></table></figure><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>使用 js 动画：会频繁操作 js，进而频繁对 dom/css 进行操作，浏览器会频繁重绘和重排，这是一个很大的开销，使得 js 的执行效率很低。<br>使用 css3 进行动画： 不占用主线程， 可以利用硬件加速， 浏览器本身对动画的优化（不可见时不进行动画，减少每秒传输帧数fps）</p><p>css3 比较适用于 2D 动画，3D以上的动画的执行效率会比js要低。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用-window-requestAnimationFrame&quot;&gt;&lt;a href=&quot;#使用-window-requestAnimationFrame&quot; class=&quot;headerlink&quot; title=&quot;使用 window.requestAnimationFram
      
    
    </summary>
    
      <category term="javascript" scheme="https://shleyz.github.io/categories/javascript/"/>
    
    
      <category term="js基础" scheme="https://shleyz.github.io/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>js类型检测</title>
    <link href="https://shleyz.github.io/2020/02/02/interview-js%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B/"/>
    <id>https://shleyz.github.io/2020/02/02/interview-js类型检测/</id>
    <published>2020-02-02T09:23:20.000Z</published>
    <updated>2021-02-04T01:13:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="typeof-用来判断大部分基础数据类型和Function："><a href="#typeof-用来判断大部分基础数据类型和Function：" class="headerlink" title="typeof 用来判断大部分基础数据类型和Function："></a>typeof 用来判断大部分基础数据类型和Function：</h2><ul><li>Number </li><li>String </li><li>Boolean </li><li>Null     // 使用 typeof 返回的是 “object”, 并不能准确分辨</li><li>Undefined </li><li>Symbol (本质上是一种唯一标识符) </li></ul><p>但是对于下面的部分引用类型： </p><ul><li>Array</li><li>Object</li><li>Function // 使用 typeof 返回的是 “function”， 可以分辨</li><li>Date</li><li>RegExp</li></ul><p>typeof 返回都是 “object”, 无法直接得到类型。。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>        <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'123'</span>      <span class="comment">// "string"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span>      <span class="comment">// "boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>  <span class="comment">// "undefined"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>()   <span class="comment">// "symbol"</span></span><br><span class="line"><span class="keyword">typeof</span> () =&gt; &#123;&#125;   <span class="comment">// "function"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>       <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> []         <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;         <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> /w/g       <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure><p>因此对于引用类型的数据判断类型的话，可以用 <strong>instanceof</strong></p><h2 id="instanceof-可以来检测主要的引用类型-即判断一个对象是否在另一个对象的原型链上。"><a href="#instanceof-可以来检测主要的引用类型-即判断一个对象是否在另一个对象的原型链上。" class="headerlink" title="instanceof 可以来检测主要的引用类型,即判断一个对象是否在另一个对象的原型链上。"></a>instanceof 可以来检测主要的引用类型,即判断一个对象是否在另一个对象的原型链上。</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// true</span></span><br><span class="line">obj = []</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>  <span class="comment">// true</span></span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Date</span> <span class="comment">// true</span></span><br><span class="line">obj = <span class="regexp">/w/g</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span> <span class="comment">// true</span></span><br><span class="line">obj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但是下面这种也都成立：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// true</span></span><br><span class="line">obj = []</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// true</span></span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">obj = <span class="regexp">/w/g</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">obj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>因为所有引用类型其实都是继承自 Object 对象的</p><p>下面这个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'123'</span>)</span><br><span class="line"><span class="keyword">typeof</span> str  <span class="comment">// "object"</span></span><br><span class="line">obj = []</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// true</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">String</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>这就尴尬了，这到底是什么类型？</p><h2 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h2><p>直接看例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj)  <span class="comment">// "[object Object]"</span></span><br><span class="line">obj = []</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj)  <span class="comment">// "[object Array]"</span></span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj)  <span class="comment">// "[object Date]"</span></span><br><span class="line">obj = <span class="regexp">/w/g</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj)  <span class="comment">// "[object RegExp]"</span></span><br><span class="line">obj = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj)  <span class="comment">//"[object Function]"</span></span><br><span class="line">obj = <span class="literal">null</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj)  <span class="comment">//"[object Null]"</span></span><br><span class="line">obj = <span class="literal">undefined</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj)  <span class="comment">//"[object Undefined]"</span></span><br><span class="line">obj = <span class="number">123</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj)  <span class="comment">// "[object Number]"</span></span><br><span class="line">obj = <span class="string">'abc'</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj)  <span class="comment">// "[object String]"</span></span><br><span class="line">obj = <span class="literal">false</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj)  <span class="comment">// "[object Boolean]"</span></span><br><span class="line">obj = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj)  <span class="comment">// "[object Symbol]"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;typeof-用来判断大部分基础数据类型和Function：&quot;&gt;&lt;a href=&quot;#typeof-用来判断大部分基础数据类型和Function：&quot; class=&quot;headerlink&quot; title=&quot;typeof 用来判断大部分基础数据类型和Function：&quot;&gt;
      
    
    </summary>
    
      <category term="javascript" scheme="https://shleyz.github.io/categories/javascript/"/>
    
    
      <category term="js基础" scheme="https://shleyz.github.io/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>@bigtest/react</title>
    <link href="https://shleyz.github.io/2020/01/08/bigtest-react/"/>
    <id>https://shleyz.github.io/2020/01/08/bigtest-react/</id>
    <published>2020-01-08T05:14:24.000Z</published>
    <updated>2020-02-28T05:44:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>进行大型测试的 React DOM 助手：@bigtest/react</p><p>github 地址： <a href="https://github.com/bigtestjs/react" target="_blank" rel="noopener">https://github.com/bigtestjs/react</a></p><p>这个软件包的目的是提供一套帮助程序，使得能够更加容易的测试 React 程序</p><h2 id="mount-方法"><a href="#mount-方法" class="headerlink" title="mount 方法"></a>mount 方法</h2><p>在一个新的 DOM 节点异步加载一个组件，返回 promise， 一连串的使用将清除所有先前安装的组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@bigtest/react'</span>;</span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'../src/components/button'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'My button'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// `mount` 返回Promise: 渲染后resolves</span></span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> mount(<span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Button</span> /&gt;</span></span>));</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'renders'</span>, () =&gt; &#123;</span><br><span class="line">    expect(<span class="built_in">document</span>.querySelector(<span class="string">'.button'</span>)).to.exist;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="setupAppForTesting"><a href="#setupAppForTesting" class="headerlink" title="setupAppForTesting"></a>setupAppForTesting</h2><p>setupAppForTesting 不仅会 mount 应用程序组件，还将使用该组件的实例进行解析，并提供一个内存重的 history 对象，供 React Router 在测试期间使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; setupAppForTesting &#125; <span class="keyword">from</span> <span class="string">'@bigtest/react'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../src/app'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'My Application'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> app;</span><br><span class="line">  beforeEach(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    app = <span class="keyword">await</span> setupAppForTesting(App);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'renders'</span>, () =&gt; &#123;</span><br><span class="line">    expect(<span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>)).to.exist;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="string">'has a history prop'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// this prop is only provided if defined in `propTypes`</span></span><br><span class="line">    expect(app.props).to.have.property(<span class="string">'history'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="visit"><a href="#visit" class="headerlink" title="visit"></a>visit</h2><p>只有在使用 setupAppForTesting，并与应用程序的 history 属性进行交互以在路由之间导航后，才会起作用。（visit, goBack, goForward, and location 都是这样）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; setupAppForTesting, visit, location &#125; <span class="keyword">from</span> <span class="string">'@bigtest/react'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../src/app'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'My Application'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> app;</span><br><span class="line">  beforeEach(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    app = <span class="keyword">await</span> setupAppForTesting(App);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  describe(<span class="string">'navigating'</span>, () =&gt; &#123;</span><br><span class="line">    beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> visit(<span class="string">'/some-route'</span>));</span><br><span class="line"></span><br><span class="line">    it(<span class="string">'is at the new route'</span>, () =&gt; &#123;</span><br><span class="line">      expect(location()).to.have.property(<span class="string">'pathname'</span>, <span class="string">'/some-route'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup"></a>cleanup</h2><p>在每次 mount 和 setupAppForTesting 调用开始时都会调用 cleanup，以清除以前安装的任何组件或应用程序。 如果您需要自己清理以前安装的组件，也可以单独使用它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mount, cleanup &#125; <span class="keyword">from</span> <span class="string">'@bigtest/react'</span>;</span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'../src/components/button'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'My Button'</span>, () =&gt; &#123;</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> mount(<span class="xml"><span class="tag">&lt;<span class="name">Button</span> /&gt;</span></span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了可以在测试运行后调查并使用组件进行调试，最好不要这样做</span></span><br><span class="line">  afterEach(<span class="function"><span class="params">()</span> =&gt;</span> cleanup());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>mount 和 setupAppForTesting 都有第二个参数： 一个对象包含一系列的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mount(<span class="xml"><span class="tag">&lt;<span class="name">Button</span> /&gt;</span></span>, &#123;</span><br><span class="line">  mountId: <span class="string">'testing-root'</span>,  <span class="comment">// 作为加载的DOM节点的id</span></span><br><span class="line">  rootElement: <span class="built_in">document</span>.body, <span class="comment">// 加载的DOM节点的位置</span></span><br><span class="line">  setup: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,  <span class="comment">// 在组件加载好之前调用， 如果返回的是promise，则组件会在resolve之后加载</span></span><br><span class="line">  teardown: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;  <span class="comment">// 在下一个 cleanup 调用时调用，或者在下一个mount或setupAppForTesting开始时调用，或者在直接调用 cleanup 时调用。 和“ setup”一样，如果返回的是promise，则组件会在resolve之后加载</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此外， setupAppForTesting 接受一个 props 选项， 该选项将与所有用户定义的 props 一起传递给应用程序组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setupAppForTesting(App, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    store: createStore(),</span><br><span class="line">    <span class="comment">// you can provide your own history object as well</span></span><br><span class="line">    history: createHistory(historyOptions)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="可重用性"><a href="#可重用性" class="headerlink" title="可重用性"></a>可重用性</h2><p>为了在测试应用程序时获得最佳体验，任何不属于组件生命周期中的必需的逻辑，都应该是可重用的。通过提供必要的 setup 和 teardown 选项，或者将逻辑移入组件生命周期挂钩中。</p><p>除此之外，在您自己的 test helper 中使用 setupAppForTesting 可能很有意义，因为它可以处理任何其他必要的设置。 这也使我们不必导入应用程序并在每个测试文件中重复设置逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test/helper.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; setupAppForTesting &#125; <span class="keyword">from</span> <span class="string">'@bigtest/react'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; visit, goBack, goForward, location &#125; <span class="keyword">from</span> <span class="string">'@bigtest/react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../src/app'</span>;</span><br><span class="line"><span class="keyword">import</span> createServer <span class="keyword">from</span> <span class="string">'./mocks/server'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setupApplicationForTesting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  beforeEach(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) =&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.app = <span class="keyword">await</span> setupAppForTesting(App, () =&gt; &#123;</span><br><span class="line">      setup: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.server = createServer(),</span><br><span class="line">      teardown: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.server.shutdown()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更好的测试"><a href="#更好的测试" class="headerlink" title="更好的测试"></a>更好的测试</h2><p>这些 helpers 使您可以反复安装应用程序进行测试，而与应用程序进行交互也可能会很麻烦。</p><p><a href="https://github.com/bigtestjs/interactor" target="_blank" rel="noopener">@bigtest/interactor</a> 提供了一个更简单的方法，通过任何浏览器与应用的各个部分进行交互。就好像是用户在和你的 app 进行交互。实际上，可组合的 interactors 是测试使用可组合 components 制作的 app 的完美伴侣。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; setupAppForTesting &#125; <span class="keyword">from</span> <span class="string">'@bigtest/react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../src/app'</span>;</span><br><span class="line"><span class="keyword">import</span> HomePageInteractor <span class="keyword">from</span> <span class="string">'./interactors/home'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'My Applicaion'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> home = <span class="keyword">new</span> HomePageInteractor();</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> setupAppForTesting(App));</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'has a fancy button'</span>, () =&gt; &#123;</span><br><span class="line">    except(home.button.isPresent).to.be.true;</span><br><span class="line">    except(home.button.isFancy).to.be.true;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进行大型测试的 React DOM 助手：@bigtest/react&lt;/p&gt;
&lt;p&gt;github 地址： &lt;a href=&quot;https://github.com/bigtestjs/react&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:/
      
    
    </summary>
    
      <category term="bigtest" scheme="https://shleyz.github.io/categories/bigtest/"/>
    
    
      <category term="bigtest" scheme="https://shleyz.github.io/tags/bigtest/"/>
    
  </entry>
  
  <entry>
    <title>@bigtest/convergence</title>
    <link href="https://shleyz.github.io/2020/01/08/bigtest-convergence/"/>
    <id>https://shleyz.github.io/2020/01/08/bigtest-convergence/</id>
    <published>2020-01-08T03:21:48.000Z</published>
    <updated>2020-02-28T05:44:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://bigtestjs.io/docs/convergence/" target="_blank" rel="noopener">Convergence</a> 是强大,不可变，可重用和可组合的断言，使您可以立即知道何时达到期望的状态。<br>简而言之：它每 10 毫秒检查一次 DOM（默认情况下为 2 秒），以查看您要检查的状态是否存在。</p><p>Convergence 是 BigTest 中所有事物的基础。这就是使 interactors 可靠的原因。<br>CLI 中甚至将 Convergence 用于等待浏览器连接状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Convergence <span class="keyword">from</span> <span class="string">'@bigtest/convergence'</span>;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> (foo = <span class="string">'bar'</span>), <span class="number">100</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Convergence().when(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'bar'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// =&gt; "bar"</span></span><br></pre></td></tr></table></figure><p>默认情况下，Convergence 将在 2000ms 之前或之后 converge，具体取决于定义的断言类型。这可以通过在初始化 convergence 时提供超时或使用 #timeout() 方法来配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Convergence(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">new</span> Convergence().timeout(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>使用 #when()，断言将运行多次直到通过。同样，#always() 确保断言在一段时间内保持通过状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// converges when `foo` is equal to `'bar'` within 100ms</span></span><br><span class="line"><span class="keyword">new</span> Convergence(<span class="number">100</span>).when(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'bar'</span>);</span><br><span class="line"><span class="comment">// converges after `foo` is equal to `'bar'` for at least 100ms</span></span><br><span class="line"><span class="keyword">new</span> Convergence(<span class="number">100</span>).always(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'bar'</span>);</span><br></pre></td></tr></table></figure><p>convergence 是不可变的，因此，它的方法将返回新实例。 这使您可以组合多个 convergence，并使用各自的 #run() 方法分别启动每个 convergence。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> converge = <span class="keyword">new</span> Convergence(<span class="number">300</span>);</span><br><span class="line"><span class="keyword">let</span> convergeFoo = converge.when(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> convergeFooBar = convergeFoo.when(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">let</span> convergeFooBarBaz = convergeFooBar.when(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'baz'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> (foo = <span class="string">'foo'</span>), <span class="number">100</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> (foo = <span class="string">'bar'</span>), <span class="number">200</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> (foo = <span class="string">'baz'</span>), <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolves after 100ms</span></span><br><span class="line">convergeFoo.run();</span><br><span class="line"><span class="comment">// resolves after 200ms</span></span><br><span class="line">convergeFooBar.run();</span><br><span class="line"><span class="comment">// rejects after 300ms since it wasn't `baz` _after_ `bar`</span></span><br><span class="line">convergeFooBarBaz.run();</span><br></pre></td></tr></table></figure><p>Convergences 会立即调用#run（）。这使它们能够在大多数情况下可以使用的地方使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">onceBarAlwaysBar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> Convergence().when(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'bar'</span>).always(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'bar'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([onceBarAlwaysBar(), <span class="keyword">new</span> Convergence().when(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'baz'</span>)]);</span><br></pre></td></tr></table></figure><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><h3 id="isConvergence-obj-返回布尔值"><a href="#isConvergence-obj-返回布尔值" class="headerlink" title="isConvergence(obj) 返回布尔值"></a>isConvergence(obj) 返回布尔值</h3><p>如果对象具有正确类型的 convergence 属性，则返回 true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = maybeConvergence();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isConvergence(result)) &#123;</span><br><span class="line">  <span class="keyword">await</span> result.do(something).timeout(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  something(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="always-assertion-timeout"><a href="#always-assertion-timeout" class="headerlink" title="always(assertion, timeout)"></a>always(assertion, timeout)</h3><p>传入的参数：</p><ul><li>assertion： Function 需要 converge 的断言</li><li>timeout：Number 使用的超时时间，以剩余的超时时间为上限。</li></ul><p>返回一个新的 convergence</p><p>返回带有附加断言的新 convergence 实例。重复运行此断言以确保它在整个超时时间内通过。如果在超时期间的任何时候断言失败，那么 convergence 将失败。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// would converge after `foo` remains `'foo'` for at least 100ms</span></span><br><span class="line"><span class="keyword">new</span> Convergence(<span class="number">100</span>).always(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'foo'</span>);</span><br></pre></td></tr></table></figure><p>当 convergence 结束时遇到 always 断言时，超时默认为当前正在运行的实例的剩余时间。最少 20ms。如果不在 convergence 范围内，则默认为总超时时间的十分之一。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> convergeFooThenBar = <span class="keyword">new</span> Convergence(<span class="number">1000</span>)</span><br><span class="line">  .always(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'foo'</span>) <span class="comment">// would continue after `foo` remains `'foo'` for at least 100ms</span></span><br><span class="line">  .when(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'bar'</span>); <span class="comment">// then have any time remaining to converge on `foo` being `'bar'`</span></span><br></pre></td></tr></table></figure><p>给定一个超时时间，则将其限制为当前运行实例的剩余超时时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> convergeFooThenBar = <span class="keyword">new</span> Convergence(<span class="number">100</span>)</span><br><span class="line">  .always(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'foo'</span>, <span class="number">50</span>) <span class="comment">// 当在50ms内foo持续等于'foo'，则继续</span></span><br><span class="line">  .when(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'bar'</span>) <span class="comment">// 然后还剩下50ms</span></span><br><span class="line">  .always(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'bar'</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://bigtestjs.io/docs/convergence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Convergence&lt;/a&gt; 是强大,不可变，可重用和可组合的断言，使您可以立即知道何时达到期望的状态。&lt;br&gt;
      
    
    </summary>
    
      <category term="bigtest" scheme="https://shleyz.github.io/categories/bigtest/"/>
    
    
      <category term="bigtest" scheme="https://shleyz.github.io/tags/bigtest/"/>
    
  </entry>
  
  <entry>
    <title>@bigtest/interactor开箱即用的方法和属性</title>
    <link href="https://shleyz.github.io/2020/01/07/bigtest-interactor%E5%BC%80%E7%AE%B1%E5%8D%B3%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7/"/>
    <id>https://shleyz.github.io/2020/01/07/bigtest-interactor开箱即用的方法和属性/</id>
    <published>2020-01-07T09:36:46.000Z</published>
    <updated>2020-02-28T05:44:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下是 interactor 开箱即用可用的各种交互的简要说明。</p><h2 id="Default-Interactions"><a href="#Default-Interactions" class="headerlink" title="Default Interactions"></a>Default Interactions</h2><p>这些默认的交互属性和方法在所有 interactor 上都可用，但是在定义自己的自定义 interactor 时可以安全地覆盖它们。</p><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>如果元素不能位于 Interactions 的根元素中，则所有属性（isPresent 除外）都将引发错误。</p><ol><li>#text： 返回元素 trimmed 后的 textContent 属性</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Interactor(<span class="string">'p'</span>).text;</span><br></pre></td></tr></table></figure><ol start="2"><li>#value: 返回元素的 value 属性</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Interactor(<span class="string">'input'</span>).value;</span><br></pre></td></tr></table></figure><ol start="3"><li>#isVisible: 如果元素在文档中可见，则返回 true 否则 false</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Interactor(<span class="string">'#foo'</span>).isVisible; <span class="comment">//=&gt; true</span></span><br><span class="line"><span class="keyword">new</span> Interactor(<span class="string">'#bar'</span>).isVisible; <span class="comment">//=&gt; false</span></span><br></pre></td></tr></table></figure><ol start="4"><li>#isHidden： 如果元素存在于文档中但在视觉上被隐藏，则返回 true 否则 false</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Interactor(<span class="string">'#foo'</span>).isHidden; <span class="comment">//=&gt; false</span></span><br><span class="line"><span class="keyword">new</span> Interactor(<span class="string">'#bar'</span>).isHidden; <span class="comment">//=&gt; true</span></span><br></pre></td></tr></table></figure><ol start="5"><li>#isPresent： 如果可以在文档中找到一个元素，则返回 true 否则 false。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Interactor(<span class="string">'#foo'</span>).isPresent; <span class="comment">//=&gt; true</span></span><br><span class="line"><span class="keyword">new</span> Interactor(<span class="string">'#bar'</span>).isPresent; <span class="comment">//=&gt; false</span></span><br></pre></td></tr></table></figure><h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><p>所有默认的交互方法都接受一个可选的选择器作为第一个参数。给定一个选择器，将在父交互器的根元素内的匹配元素上进行交互。</p><p>注意：交互方法将返回交互器的新实例，并且在新实例上调用#run（）方法之前不会进行任何交互。</p><ol><li>#click([selector]) 触发元素上的点击事件。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'button'</span>).click();</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'form'</span>).click(<span class="string">'[type="submit"]'</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>#fill([selector], value) 更改元素的值并触发输入和更改事件。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'input'</span>).fill(<span class="string">'value'</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'form'</span>).fill(<span class="string">'input#name'</span>, <span class="string">'value'</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>#select([selector], option) 通过文本值选择一个选项并触发输入和更改事件。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'select'</span>).select(<span class="string">'February'</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'form'</span>).fill(<span class="string">'select#month'</span>, <span class="string">'March'</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>#focus([selector]) 在元素上触发焦点事件。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'input'</span>).focus();</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'form'</span>).focus(<span class="string">'input[type="email"]'</span>);</span><br></pre></td></tr></table></figure><ol start="5"><li>#blur([selector]) 在元素上触发失去焦点事件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'input'</span>).blur();</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'form'</span>).blur(<span class="string">'input[type="email"]'</span>);</span><br></pre></td></tr></table></figure><ol start="6"><li>#scroll([selector], { top, left }) 设置元素的 scrollTop 和 scrollLeft 属性并触发滚动事件。顶部和左侧的值指定在该方向上滚动到多少像素；必须至少指定一个方向。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'#page'</span>).scroll(&#123; <span class="attr">top</span>: <span class="number">100</span> &#125;);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'#page'</span>).scroll(<span class="string">'.nested-view'</span>, &#123; <span class="attr">left</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure><ol start="7"><li>#trigger([selector], name[, options]) 使用任何指定的事件选项在元素上触发任意事件，名称。默认情况下，气泡和可取消选项设置为 true。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'#foo'</span>).trigger(<span class="string">'customEvent'</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'#foo'</span>).trigger(<span class="string">'customEvent'</span>, &#123; ... &#125;);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'#foo'</span>).trigger(<span class="string">'#bar'</span>, <span class="string">'customEvent'</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'#foo'</span>).trigger(<span class="string">'#bar'</span>, <span class="string">'customEvent'</span>, &#123; ... &#125;);</span><br></pre></td></tr></table></figure><h2 id="Property-Creators"><a href="#Property-Creators" class="headerlink" title="Property Creators"></a>Property Creators</h2><p>使用 @interactor 类装饰器创建自己的自定义 interactors 时，可以利用 Property creators。<br>就像默认方法一样，creator 函数接受一个可选的选择器。但是，生成的实例方法没有可选的 selector 参数。</p><h3 id="Properties-1"><a href="#Properties-1" class="headerlink" title="Properties"></a>Properties</h3><p>interactor Property creators 返回一个 getter。就像默认属性一样，除了 isPresent 之外，如果元素不能位于 interactor 的根元素中，则所有属性都会引发错误。</p><ol><li>text([selector]) 返回元素 trimmed 后的 textContent 属性</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageInteractor</span> </span>&#123;</span><br><span class="line">  heading = text(<span class="string">'h1'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> PageInteractor().heading; <span class="comment">//=&gt; "Hello World!"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>value([selector]) 返回元素的 value 属性。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormInteractor</span> </span>&#123;</span><br><span class="line">  name = value(<span class="string">'input#name'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).name; <span class="comment">//=&gt; "Foo Bar"</span></span><br></pre></td></tr></table></figure><ol start="3"><li>isVisible([selector]) 如果元素在文档中可见，则返回 true 否则 false</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">style</span>=<span class="string">"display: none"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageInteractor</span> </span>&#123;</span><br><span class="line">  isFooVisible = isVisible(<span class="string">'#foo'</span>);</span><br><span class="line">  isBarVisible = isVisible(<span class="string">'#bar'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> PageInteractor().isFooVisible; <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="keyword">new</span> PageInteractor().isBarVisible; <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><ol start="4"><li>isHidden([selector]) 如果元素存在于文档中但在视觉上被隐藏，则返回 true 否则 false。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">style</span>=<span class="string">"display: none"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageInteractor</span> </span>&#123;</span><br><span class="line">  isFooHidden = isHidden(<span class="string">'#foo'</span>);</span><br><span class="line">  isBarHidden = isHidden(<span class="string">'#bar'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> PageInteractor().isFooHidden; <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="keyword">new</span> PageInteractor().isBarHidden; <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><ol start="5"><li>isPresent([selector]) 如果可以在文档中找到一个元素，则返回 true 否则 false。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageInteractor</span> </span>&#123;</span><br><span class="line">  isFooPresent = isPresent(<span class="string">'#foo'</span>);</span><br><span class="line">  isBarPresent = isPresent(<span class="string">'#bar'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> PageInteractor().isFooPresent; <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="keyword">new</span> PageInteractor().isBarPresent; <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><ol start="6"><li>attribute([selector], attr) 通过 getAttribute 返回元素的指定属性。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"card-link"</span> <span class="attr">href</span>=<span class="string">"https://example.com"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CardInteractor</span> </span>&#123;</span><br><span class="line">  id = attribute(<span class="string">'id'</span>);</span><br><span class="line">  url = attribute(<span class="string">'.card-link'</span>, <span class="string">'href'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> CardInteractor(<span class="string">'.card'</span>).id; <span class="comment">//=&gt; "foo"</span></span><br><span class="line"><span class="keyword">new</span> CardInteractor(<span class="string">'.card'</span>).url; <span class="comment">//=&gt; "https://example.com"</span></span><br></pre></td></tr></table></figure><ol start="7"><li>property([selector], prop) 返回元素的指定属性值。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span> <span class="attr">style</span>=<span class="string">"height: 100px"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"card-cta"</span> <span class="attr">disabled</span>&gt;</span>...<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CardInteractor</span> </span>&#123;</span><br><span class="line">  height = property(<span class="string">'offsetHeight'</span>);</span><br><span class="line">  isDisabled = property(<span class="string">'button.card-cta'</span>, <span class="string">'disabled'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> CardInteractor(<span class="string">'.card'</span>).height; <span class="comment">//=&gt; 100</span></span><br><span class="line"><span class="keyword">new</span> CardInteractor(<span class="string">'.card'</span>).isDisabled; <span class="comment">//=&gt; true</span></span><br></pre></td></tr></table></figure><ol start="8"><li>hasClass([selector], className) 如果元素的 classList 包含指定的类名，则返回 true 否则 false。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"error"</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"name"</span> <span class="attr">class</span>=<span class="string">"error"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">id</span>=<span class="string">"email"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormInteractor</span> </span>&#123;</span><br><span class="line">  hasErrors = hasClass(<span class="string">'error'</span>); <span class="comment">// applies to the root</span></span><br><span class="line">  hasNameError = hasClass(<span class="string">'input#name'</span>, <span class="string">'error'</span>);</span><br><span class="line">  hasEmailError = hasClass(<span class="string">'input#email'</span>, <span class="string">'error'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).hasErrors; <span class="comment">//=&gt; true</span></span><br><span class="line"><span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).hasNameError; <span class="comment">//=&gt; true</span></span><br><span class="line"><span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).hasEmailError; <span class="comment">//=&gt; false</span></span><br></pre></td></tr></table></figure><ol start="9"><li>is([selector], match) 如果指定的匹配选择器可以通过 Element.matches（）选择一个元素，则返回 true 否则 false。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"bar"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"baz"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListInteractor</span> </span>&#123;</span><br><span class="line">  isList = is(<span class="string">'.list'</span>);</span><br><span class="line">  isFooFirst = is(<span class="string">'#foo'</span>, <span class="string">':first-child'</span>);</span><br><span class="line">  isBarLast = is(<span class="string">'#bar'</span>, <span class="string">':last-child'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).hasErrors; <span class="comment">//=&gt; true</span></span><br><span class="line"><span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).hasNameError; <span class="comment">//=&gt; true</span></span><br><span class="line"><span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).hasEmailError; <span class="comment">//=&gt; false</span></span><br></pre></td></tr></table></figure><h3 id="Methods-1"><a href="#Methods-1" class="headerlink" title="Methods"></a>Methods</h3><p>interactor methods Creators 返回链式函数，这些函数随后返回具有添加到其队列中的特定交互的新实例。直到调用交互程序的 #run() 方法或使用 async/await 语法时，interactions 才会运行。</p><ol><li>clickable([selector]) =&gt; click() 触发元素的 click 事件。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"card-link"</span> <span class="attr">href</span>=<span class="string">"https://example.com"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CardInteractor</span> </span>&#123;</span><br><span class="line">  clickThrough = clickable(<span class="string">'.card-link'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> CardInteractor(<span class="string">'.card'</span>).clickThrough();</span><br></pre></td></tr></table></figure><ol start="2"><li>fillable([selector]) =&gt; fill(value) 更改元素的 value 值并触发 input 和 change 事件</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormInteractor</span> </span>&#123;</span><br><span class="line">  fillName = fillable(<span class="string">'input#name'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).fillName(<span class="string">'value'</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>selectable([selector]) =&gt; select(option) 通过 text 值选择一个选项并触发 input 和 change 事件。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"month"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>January<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span>February<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"3"</span>&gt;</span>March<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormInteractor</span> </span>&#123;</span><br><span class="line">  selectMonth = selectable(<span class="string">'select#month'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).selectMonth(<span class="string">'February'</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>focusable([selector]) =&gt; focus() 在元素上触发 focus 事件。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> /&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormInteractor</span> </span>&#123;</span><br><span class="line">  focusEmail = focusable(<span class="string">'input[type="email"]'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).focusEmail();</span><br></pre></td></tr></table></figure><ol start="5"><li>blurrable([selector]) =&gt; blur() 在元素上触发 blur 事件。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> /&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormInteractor</span> </span>&#123;</span><br><span class="line">  blurEmail = blurrable(<span class="string">'input[type="email"]'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).blurEmail();</span><br></pre></td></tr></table></figure><ol start="6"><li>scrollable([selector]) =&gt; scroll({ top, left }) 置元素的 scrollTop 和 scrollLeft 属性并触发 scroll 事件。top 和 left 的值指定在该方向上滚动到多少像素；必须至少指定一个方向</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"page"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"scrollview"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageInteractor</span> </span>&#123;</span><br><span class="line">  scrollSection = scrollable(<span class="string">'.scrollview'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> PageInteractor(<span class="string">'#page'</span>).scrollSection(&#123; <span class="attr">top</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure><ol start="7"><li>triggerable([selector], name[, options]) =&gt; trigger([options]) 使用任何指定的事件 options 在元素上触发任意事件，名称。默认情况下，bubbles 和 cancelable 选项设置为 true。运行交互程序时，两个 options 参数将合并。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageInteractor</span> </span>&#123;</span><br><span class="line">  triggerEvent = triggerable(<span class="string">'customEvent'</span>, &#123; ... &#125;);</span><br><span class="line">  triggerFooEvent = triggerable(<span class="string">'#foo'</span>, <span class="string">'customEvent'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> PageInteractor().triggerEvent();</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> PageInteractor().triggerEvent(&#123; ... &#125;);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> PageInteractor().triggerFooEvent();</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> PageInteractor().triggerFooEvent(&#123; ... &#125;);</span><br></pre></td></tr></table></figure><h3 id="Interactors"><a href="#Interactors" class="headerlink" title="Interactors"></a>Interactors</h3><p>嵌套的 interactor creators 返回范围为父 interactor 根元素的 interactor 实例。第二个参数是要添加到返回的 interactor 中的可选的参数。第二个参数也可能是一个 interactor class，在创建嵌套的，作用域的 interactor 时会使用它自己的方法和属性。</p><ol><li>scoped(selector[, properties]) 单个嵌套 interactor 的 Interactor creator。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"login-form"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">"email"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginFormInteractor</span> </span>&#123;</span><br><span class="line">  username = scope(<span class="string">'input[name="username"]'</span>);</span><br><span class="line">  email = scope(<span class="string">'input[name="email"]'</span>);</span><br><span class="line">  submit = clickable(<span class="string">'button[type="submit"]'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> LoginFormInteractor(<span class="string">'form'</span>)</span><br><span class="line">  .username.fill(<span class="string">'darklord1926'</span>)</span><br><span class="line">  .email.fill(<span class="string">'tom.riddle@hogwarts.edu'</span>)</span><br><span class="line">  .email.blur()</span><br><span class="line">  .submit();</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> LoginFormInteractor(<span class="string">'form'</span>)</span><br><span class="line">  .username.fill(<span class="string">'h4x0r'</span>)</span><br><span class="line">  .email.only().fill(<span class="string">'not@an@email'</span>)</span><br><span class="line">  .blur();</span><br></pre></td></tr></table></figure><ol start="2"><li>collection(selector[, properties]) =&gt; fn([index]) 一组嵌套 interactor 的 Interactor creator。集合 interactor 将索引作为参数，并返回作用域为该元素的 interactor。没有索引，将返回相应的 interactor 数组</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"checkboxes"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">...</span>/&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">...</span>/&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">...</span>/&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckboxGroupInteractor</span> </span>&#123;</span><br><span class="line">  items = collection(<span class="string">'input[type="checkbox"]'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> checkboxGroup</span><br><span class="line">  .items(<span class="number">0</span>).click()</span><br><span class="line">  .items(<span class="number">1</span>).click();)</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> checkboxGroup</span><br><span class="line">  .items(<span class="number">0</span>).click()</span><br><span class="line">  .items(<span class="number">1</span>).only()</span><br><span class="line">  .focus()</span><br><span class="line">  .trigger(<span class="string">'keydown'</span>, &#123; <span class="attr">which</span>: <span class="number">32</span> &#125;)</span><br></pre></td></tr></table></figure><h3 id="Helpers"><a href="#Helpers" class="headerlink" title="Helpers"></a>Helpers</h3><p>Property creator 可用于定义您自己的自定义 interactions。支持直接在 interactor class上定义 methods 和 getters。但是，使用这些帮助程序可以让您创建可重复使用的Property creator ，例如上述交互。</p><ol><li>computed(getter) 返回 Interactor Property 的 property descriptor。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">data</span>(<span class="params">key, selector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> computed(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$(selector).dataset[key];</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interactor </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageInteractor</span> </span>&#123;</span><br><span class="line">  username = data(<span class="string">'user'</span>, <span class="string">'#user-info'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>action(method) 返回一个交互方法的 property descriptor。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> action(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.click(<span class="string">`<span class="subst">$&#123;selector&#125;</span>[name="<span class="subst">$&#123;name&#125;</span>"]`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interactor </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckboxGroupInteractor</span> </span>&#123;</span><br><span class="line">  check = check(<span class="string">'input[type="checkbox"]'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> CheckboxGroupinteractor(<span class="string">'.checkboxes'</span>).check(<span class="string">'option-1'</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是 interactor 开箱即用可用的各种交互的简要说明。&lt;/p&gt;
&lt;h2 id=&quot;Default-Interactions&quot;&gt;&lt;a href=&quot;#Default-Interactions&quot; class=&quot;headerlink&quot; title=&quot;Default Inte
      
    
    </summary>
    
      <category term="bigtest" scheme="https://shleyz.github.io/categories/bigtest/"/>
    
    
      <category term="bigtest" scheme="https://shleyz.github.io/tags/bigtest/"/>
    
  </entry>
  
  <entry>
    <title>@bigtest/interactor使用</title>
    <link href="https://shleyz.github.io/2020/01/07/bigtest-interactor%E4%BD%BF%E7%94%A8/"/>
    <id>https://shleyz.github.io/2020/01/07/bigtest-interactor使用/</id>
    <published>2020-01-07T08:42:05.000Z</published>
    <updated>2020-02-28T05:44:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自定义-interactor"><a href="#自定义-interactor" class="headerlink" title="自定义 interactor"></a>自定义 interactor</h2><p>虽然使用默认的 Interactor 对于简单和较小的组件可能很好，但是使用类装饰器和 interactor interaction creators 很容易创建自定义 interaction。</p><p>自定义 Interactor 使我们能够将所有选择器都放在一个位置，并具有与其他 Interactor 可组合以与更多复杂结构交互的好处。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  interactor,</span><br><span class="line">  text,</span><br><span class="line">  value,</span><br><span class="line">  property,</span><br><span class="line">  fillable,</span><br><span class="line">  focusable,</span><br><span class="line">  blurrable</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@bigtest/interactor'</span>;</span><br><span class="line"></span><br><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiledInteractor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// custom properties are lazy like the default properties</span></span><br><span class="line">  label = text(<span class="string">'[data-test-label]'</span>);</span><br><span class="line">  value = value(<span class="string">'[data-test-input]'</span>);</span><br><span class="line">  type = property(<span class="string">'[data-test-input]'</span>, <span class="string">'type'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `*able` property creators create chainable interactor methods</span></span><br><span class="line">  focus = focusable(<span class="string">'[data-test-input]'</span>);</span><br><span class="line">  fill = fillable(<span class="string">'[data-test-input]'</span>);</span><br><span class="line">  blur = blurrable(<span class="string">'[data-test-input]'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的属性和方法集具有相应的 interactor creators。还有其他几个可用的 interactor creators 可供选择。</p><h2 id="自定义方法和属性"><a href="#自定义方法和属性" class="headerlink" title="自定义方法和属性"></a>自定义方法和属性</h2><p>也可以在修饰的类上直接定义其他方法和获取属性的方法。但是，请谨慎使用 property initializers 和 this，因为它会引用未修饰的类实例，而不是您可能期望的 interactor 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FieldInteractor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// methods that return new instances of itself will be chainable with other methods</span></span><br><span class="line">  fillIn(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.focus()</span><br><span class="line">      .fill(value)</span><br><span class="line">      .blur();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// using getters ensures that properties will not be invoked until necessary</span></span><br><span class="line">  <span class="keyword">get</span> isPassword() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.type === <span class="string">'password'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// the following will not work because `this` references the undecorated class</span></span><br><span class="line">  <span class="comment">// foo = () =&gt; this.doesntWork()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义-Interaction-Creators"><a href="#自定义-Interaction-Creators" class="headerlink" title="自定义 Interaction Creators"></a>自定义 Interaction Creators</h2><p>对于常用的自定义属性和方法，存在两个 helpers，可用于定义自己的可重用 interaction creators：</p><ul><li>针对属性的 computed</li><li>针对方法的 action</li></ul><p>除了默认方法外，interaction 还具有一些自己的辅助方法。</p><ol><li>this.\$(selector)</li></ol><p>使用 interaction 的根元素和 querySelector 查找嵌套元素。当找不到元素时，将引发错误。如果未定义选择器，则返回根元素。</p><ol start="2"><li>this.\$\$(selector)</li></ol><p>也使用 interaction 的根元素，但使用 querySelectorAll 并返回匹配元素的数组。仅当找不到根元素时才会引发错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">'@bigtest/interactor'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns a specific data attribute of an element</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">data</span>(<span class="params">selector, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// to align with other interaction creators, `selector` is optional</span></span><br><span class="line">  <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">    key = selector;</span><br><span class="line">    selector = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the `computed` helper creates a getter</span></span><br><span class="line">  <span class="keyword">return</span> computed(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$(selector).dataset[key];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Interactor methods: #find（selector）和#findAll（selector）的行为与上述方法相同，只是它们返回用于链式调用的新实例。找到的元素将传递到链中的下一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; action &#125; <span class="keyword">from</span> <span class="string">'@bigtest/interactor'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// triggers a keypress event for each character in a given string</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">typeable</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// the `action` helper returns an interactor method</span></span><br><span class="line">  <span class="keyword">return</span> action(<span class="function"><span class="keyword">function</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="keyword">this</span>.find(selector)</span><br><span class="line">        <span class="comment">// `#do` executes a callback within the queue</span></span><br><span class="line">        .do(<span class="function"><span class="params">$node</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> string) &#123;</span><br><span class="line">            $node.dispatchEvent(</span><br><span class="line">              <span class="keyword">new</span> Event(<span class="string">'keypress'</span>, &#123;</span><br><span class="line">                charChode: char.charCodeAt(),</span><br><span class="line">                cancelable: <span class="literal">true</span>,</span><br><span class="line">                bubbles: <span class="literal">true</span></span><br><span class="line">              &#125;)</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用自定义-interactor"><a href="#使用自定义-interactor" class="headerlink" title="使用自定义 interactor"></a>使用自定义 interactor</h2><p>可以像使用普通 interactor 一样使用自定义 interactor。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="keyword">new</span> FieldInteractor(<span class="string">'[data-test-username-field]'</span>);</span><br><span class="line"><span class="keyword">let</span> password = <span class="keyword">new</span> FieldInteractor(<span class="string">'[data-test-password-field]'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// focuses, fills, and blurs the field input</span></span><br><span class="line"><span class="keyword">await</span> username.fillIn(<span class="string">'bigtester'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// property access could trigger "element not found" errors like default properties</span></span><br><span class="line">expect(username.type).to.equal(<span class="string">'text'</span>);</span><br><span class="line">expect(password.isPassword).to.be.true;</span><br></pre></td></tr></table></figure><p>如果一个 interactor 通常只属于一个元素，则定义一个静态的 defaultScope 属性使我们不必每次都使用范围选择器初始化该 interactor。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePageInteractor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> defaultScope = <span class="string">'[data-test-home-page]'</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defaults scope to "[data-test-home-page]"</span></span><br><span class="line"><span class="keyword">let</span> homePage = <span class="keyword">new</span> HomePageInteractor();</span><br></pre></td></tr></table></figure><p>自定义 interactor 也可以通过相互嵌套来构成其他 interactor。诸如 scoped 和 collection 之类的帮助程序还允许您将一个或一组 interactor 范围限定于父 interactor 中的特定元素。</p><h2 id="Interactors-组合"><a href="#Interactors-组合" class="headerlink" title="Interactors 组合"></a>Interactors 组合</h2><p>在定义自定义 Interactors 时，可以通过组合较小的 Interactors 来创建更复杂的 Interactors。默认情况下，嵌套 Interactors 的作用域不限于其父 Interactors。这是因为在某些情况下，例如模式或弹出窗口，元素已被附加到文档的不同部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModalInteractor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignUpFormInteractor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// the default scope is used when a new instance's selector is omitted</span></span><br><span class="line">  <span class="keyword">static</span> defaultScope = <span class="string">'[data-test-sign-up-form]'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the modal element exists outside of the form</span></span><br><span class="line">  confirmation = <span class="keyword">new</span> ModalInteractor(<span class="string">'[data-test-modal]'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Scoped-Interactors-范围交互器"><a href="#Scoped-Interactors-范围交互器" class="headerlink" title="Scoped Interactors 范围交互器"></a>Scoped Interactors 范围交互器</h2><p>使用 scoped 属性创建器，您可以创建在父 Interactors 范围内的嵌套 Interactors。第二个参数允许我们完全指定其他嵌套属性或甚至另一个 Interactors 类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignUpFormInteractor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// scoped interactors look for an element within the parent element</span></span><br><span class="line">  submit = scoped(<span class="string">'[data-test-submit]'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// a hash of other properties may be provided as the second argument</span></span><br><span class="line">  email = scoped(<span class="string">'[data-test-email-field] input'</span>, &#123;</span><br><span class="line">    placeholder: property(<span class="string">'placeholder'</span>)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// using a class is preferred for maximum composability</span></span><br><span class="line">  password = scoped(<span class="string">'[data-test-password-field]'</span>, FieldInteractor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>collection 属性创建器返回一个函数，该函数接受一个索引，并将为该索引处的元素返回一个嵌套的 Interactors。就像普通的 Interactors 一样，此 Interactors 是惰性的，在交互运行或访问属性之前，它不会尝试在索引处查找元素。如果不提供任何参数，则 collection 函数将返回一个 Interactors 数组；调用时找到的每个匹配元素都会添加一个。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignUpFormInteractor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// collections also accept additional properties or a class as the second argument</span></span><br><span class="line">  interests = collection(<span class="string">'[data-test-interests-item]"]'</span>, &#123;</span><br><span class="line">    toggle: click(<span class="string">'input[type="checkbox"]'</span>),</span><br><span class="line">    label: text(<span class="string">'[data-test-label]'</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="嵌套方法和属性"><a href="#嵌套方法和属性" class="headerlink" title="嵌套方法和属性"></a>嵌套方法和属性</h2><p>嵌套的 Interactors 方法（无论是否作用域）都会返回根 Interactors 的实例以进行其他链接。嵌套属性在访问时仍会延迟计算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> signUp = <span class="keyword">new</span> SignUpFormInteractor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// `await` will immediately invoke `#run()`, we could also save a reference</span></span><br><span class="line"><span class="comment">// to this specific interaction to re-use elsewhere</span></span><br><span class="line"><span class="keyword">await</span> signUp.email</span><br><span class="line">  .fill(<span class="string">'foo@bar.baz'</span>)</span><br><span class="line">  .password.fillIn(<span class="string">'53cr3t'</span>)</span><br><span class="line">  .interests(<span class="number">3</span>)</span><br><span class="line">  .toggle()</span><br><span class="line">  .submit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// nested interactors may be broken from the parent chain using `#only()`</span></span><br><span class="line"><span class="keyword">await</span> signUp.email</span><br><span class="line">  .only()</span><br><span class="line">  .focus()</span><br><span class="line">  .fill(<span class="string">'foo@bar'</span>)</span><br><span class="line">  .blur();</span><br><span class="line"></span><br><span class="line"><span class="comment">// nested properties may throw one of a few "element not found" errors</span></span><br><span class="line">signUp.interests(<span class="number">10</span>).label;</span><br><span class="line"><span class="comment">// =&gt; Error: unable to find "[data-test-label]"</span></span><br><span class="line"><span class="comment">// =&gt; Error: unable to find "[data-test-interest-item]" at index 10</span></span><br><span class="line"><span class="comment">// =&gt; Error: unable to find "[data-test-sign-up-form]"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;自定义-interactor&quot;&gt;&lt;a href=&quot;#自定义-interactor&quot; class=&quot;headerlink&quot; title=&quot;自定义 interactor&quot;&gt;&lt;/a&gt;自定义 interactor&lt;/h2&gt;&lt;p&gt;虽然使用默认的 Interactor 对于简
      
    
    </summary>
    
      <category term="bigtest" scheme="https://shleyz.github.io/categories/bigtest/"/>
    
    
      <category term="bigtest" scheme="https://shleyz.github.io/tags/bigtest/"/>
    
  </entry>
  
  <entry>
    <title>@bigtest/interactor介绍</title>
    <link href="https://shleyz.github.io/2020/01/07/bigtest-interactor/"/>
    <id>https://shleyz.github.io/2020/01/07/bigtest-interactor/</id>
    <published>2020-01-07T08:20:57.000Z</published>
    <updated>2020-02-28T05:44:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>在生物学中，interactor 被定义为自然选择所作用的有机体的一部分。 BigTest interactor 定义了要对其进行测试的应用程序的一部分。您可以将 interactor 视为现代组件的可组合页面对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; interactor &#125; <span class="keyword">from</span> <span class="string">'@bigtest/interactor'</span>;</span><br><span class="line"><span class="comment">// an interactor can be scoped directly to an element</span></span><br><span class="line"><span class="keyword">let</span> input = <span class="keyword">new</span> interactor(<span class="string">'[data-test-input]'</span>);</span><br><span class="line"><span class="keyword">let</span> submit = <span class="keyword">new</span> interactor(<span class="string">'[data-test-submit]'</span>);</span><br></pre></td></tr></table></figure><h2 id="Interactor-Properties"><a href="#Interactor-Properties" class="headerlink" title="Interactor Properties"></a>Interactor Properties</h2><p>Interactor 属性是惰性的，在访问之前不查找元素或属性。如果找不到该元素，则会引发错误。<br>这比典型的期望失败更有用，因为我们知道期望失败的原因，而不仅仅是知道期望值不正确而失败了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// when the elements do not exist in the DOM</span></span><br><span class="line">input.value; <span class="comment">//=&gt; Error: unable to find "[data-test-input]"</span></span><br><span class="line">submit.text; <span class="comment">//=&gt; Error: unable to find "[data-test-submit]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// when the elements do exist in the DOM</span></span><br><span class="line">input.value; <span class="comment">//=&gt; "foo"</span></span><br><span class="line">submit.text; <span class="comment">//=&gt; "Submit"</span></span><br></pre></td></tr></table></figure><h2 id="Immutable-Methods"><a href="#Immutable-Methods" class="headerlink" title="Immutable Methods"></a>Immutable Methods</h2><p>Interactor 是不可变的。方法返回 Interactor 的新实例，并在队列中附加一个 interaction。<br>然后您可以通过调用 #run() 方法来在 Interactor 的队列中运行所有 Interactor。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this does not actually focus the input yet</span></span><br><span class="line"><span class="keyword">let</span> focusInput = input.focus();</span><br><span class="line"></span><br><span class="line"><span class="comment">// chaining additional interactions will add to the new instance queue</span></span><br><span class="line"><span class="keyword">let</span> focusAndFill = focusInput.fill(<span class="string">'some value'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// an interactor will wait until the element exists before interacting with it</span></span><br><span class="line">focusAndFill.run()</span><br><span class="line">.then(...)  <span class="comment">// the input was succesfully focused and filled with "some value"</span></span><br><span class="line">.catch(...) <span class="comment">// something went wrong, likely the input was not found</span></span><br></pre></td></tr></table></figure><p>Interactor 也可以相互组合以产生更复杂的交互。而且由于它们是不可变的，因此可以反复使用它们。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remember, this does not actually interact with the elements yet</span></span><br><span class="line"><span class="keyword">let</span> fillInput = input</span><br><span class="line">  .focus()</span><br><span class="line">  .fill(<span class="string">'some value'</span>)</span><br><span class="line">  .blur();</span><br><span class="line"><span class="keyword">let</span> submitForm = submit.click();</span><br><span class="line"></span><br><span class="line"><span class="comment">// when this is run, it will focus, fill, and blur the input</span></span><br><span class="line"><span class="comment">// before finally clicking on the submit button</span></span><br><span class="line"><span class="keyword">let</span> fillAndSubmit = fillInput.append(submitForm);</span><br><span class="line"></span><br><span class="line"><span class="comment">// in one test...</span></span><br><span class="line">fillAndSubmit.run();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... in another</span></span><br><span class="line">fillAndSubmit.run();</span><br></pre></td></tr></table></figure><p>默认的 interaction 方法可以选择接受一个选择器作为它们的第一个参数，以便您可以与作用域内的 interaction 中的元素进行交互。</p><p>interaction 也是可异步的，它可以立即调用#run（），从而允许 interaction 使用 async/await 语法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'[data-test-form]'</span>)</span><br><span class="line">  .fill(<span class="string">'[data-test-input]'</span>, <span class="string">'some value'</span>)</span><br><span class="line">  .click(<span class="string">'[data-test-submit]'</span>);</span><br></pre></td></tr></table></figure><p>有关可用的默认属性和方法，请参阅<a href="https://bigtestjs.io/guides/interactors/available-interactions/" target="_blank" rel="noopener">Available Interactions</a>。<br>您可以通过创建自定义 interaction 来覆盖或定义自己的 interaction。<br>这可以通过直接扩展 Interactor 类或使用@interactor 类装饰器和 interaction creators 来完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在生物学中，interactor 被定义为自然选择所作用的有机体的一部分。 BigTest interactor 定义了要对其进行测试的应用程序的一部分。您可以将 interactor 视为现代组件的可组合页面对象。&lt;/p&gt;
&lt;figure class=&quot;highlight
      
    
    </summary>
    
      <category term="bigtest" scheme="https://shleyz.github.io/categories/bigtest/"/>
    
    
      <category term="bigtest" scheme="https://shleyz.github.io/tags/bigtest/"/>
    
  </entry>
  
  <entry>
    <title>@bigtest使用</title>
    <link href="https://shleyz.github.io/2020/01/07/bigtest%E4%BD%BF%E7%94%A8/"/>
    <id>https://shleyz.github.io/2020/01/07/bigtest使用/</id>
    <published>2020-01-07T07:44:08.000Z</published>
    <updated>2020-02-28T05:44:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>假设您的应用程序正在使用以下技术：</p><ul><li>React</li><li>Mocha</li><li>Webpack or Parcel</li></ul><h2 id="Installing-Dependencies"><a href="#Installing-Dependencies" class="headerlink" title="Installing Dependencies"></a>Installing Dependencies</h2><p>首先，安装 BigTest 所需的软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev @bigtest/cli @bigtest/interactor @bigtest/react</span><br></pre></td></tr></table></figure><ul><li>@bigtest/cli 将使你能够访问文章内使用的 bigtest 命令。</li><li>@bigtest/interactor 允许您的测试以类似人与应用交互的方式与应用进行交互。 他们将等待元素出现，然后再与他们进行交互，这意味着您不必担心正确地安排测试时间以与任何运行循环同步。 （谁还有时间这样做？）</li><li>@bigtest/react：React DOM helper，用于设置您的应用程序以进行验收测试。</li></ul><h2 id="初始化-BigTest"><a href="#初始化-BigTest" class="headerlink" title="初始化 BigTest"></a>初始化 BigTest</h2><p>现在已经安装了所有依赖项，然后转到项目根目录并运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx bigtest init</span><br></pre></td></tr></table></figure><p>这将创建一个新的 bigtest 目录：</p><p>bigtest/<br>├── bigtest.opts<br>├── index.js<br>├── helpers/<br>│ └── setup-app.js<br>├── interactors/<br>│ └── app.js<br>└── tests/<br>└── app-test.js</p><h2 id="导入你的应用"><a href="#导入你的应用" class="headerlink" title="导入你的应用"></a>导入你的应用</h2><p>您需要将应用程序根组件导入到 bigtest/helpers/setup-app.js 文件中。<br>导入根组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; setupAppForTesting &#125; <span class="keyword">from</span> <span class="string">'@bigtest/react'</span>;</span><br><span class="line"><span class="keyword">import</span> YourApp <span class="keyword">from</span> <span class="string">'../../src/YourApp'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">setupApplicationForTesting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> setupAppForTesting(YourApp, () =&gt; &#123;</span><br><span class="line">    mountId: <span class="string">'bigtesting-container'</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动和服务"><a href="#启动和服务" class="headerlink" title="启动和服务"></a>启动和服务</h2><p>BigTest 通过将您的应用程序与您编写的测试文件捆绑在一起来工作。<br>创建的所有测试都需要导入到 bigtest/index.js。<br>您需要通过将捆绑器的入口点更改为 bigtest/index.js 来告诉捆绑器如何将测试与应用捆绑在一起。</p><p>bigtest CLI 会设置 NODE_ENV 为您测试。以 Webpack 为例，您可以检查 NODE_ENV 是否等于 test 并根据需要更改入口点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in your webpack.config.js</span></span><br><span class="line"><span class="keyword">let</span> isTesting = process.env.NODE_ENV === <span class="string">'test'</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: isTesting ? <span class="string">'.bigtest/index.js'</span> : <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bigtest-run"><a href="#bigtest-run" class="headerlink" title="bigtest run"></a>bigtest run</h3><p>bigtest run 处理启动不同的浏览器并实际运行测试的过程。将脚本添加到 package.json：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "test": "bigtest run"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们使用的是 package.json 中指定的@bigtest/cli 项目版本，而不是全局安装。</p><h3 id="bigtest-opts"><a href="#bigtest-opts" class="headerlink" title="bigtest.opts"></a>bigtest.opts</h3><p>bigtest.opts 文件使启动器（bigtest 运行）知道：</p><ul><li>如何启动您的应用服务器（–serve）</li><li>应用服务的位置（–serve-url）</li><li>您正在使用什么测试框架（–adapter），目前最大的启动器仅适用于 mocha，但我们正在努力添加更多的适配器。</li></ul><p>bigtest.opts 文件是一个配置文件，其中包含可以作为标志传递给 BigTest CLI 的各种选项。从 CLI 传递的参数优先于 opts 文件中指定的参数。</p><p>bigtest.opts 应该看起来像这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--serve <span class="string">"yarn start"</span></span><br><span class="line">--serve-url <span class="string">"http://localhost:3000"</span></span><br><span class="line">--adapter mocha</span><br></pre></td></tr></table></figure><h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>现在，所有内容都已设置好，可以通过运行我们之前设置的测试命令进行检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn <span class="built_in">test</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设您的应用程序正在使用以下技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React&lt;/li&gt;
&lt;li&gt;Mocha&lt;/li&gt;
&lt;li&gt;Webpack or Parcel&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Installing-Dependencies&quot;&gt;&lt;a href=&quot;#Inst
      
    
    </summary>
    
      <category term="bigtest" scheme="https://shleyz.github.io/categories/bigtest/"/>
    
    
      <category term="bigtest" scheme="https://shleyz.github.io/tags/bigtest/"/>
    
  </entry>
  
  <entry>
    <title>@bigtest介绍</title>
    <link href="https://shleyz.github.io/2020/01/07/bigtest/"/>
    <id>https://shleyz.github.io/2020/01/07/bigtest/</id>
    <published>2020-01-07T06:40:06.000Z</published>
    <updated>2020-02-28T05:44:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>知道应用程序是否正常运行的最可靠方法是实际运行它。大型测试会在每个测试用例之前启动整个应用程序。</p><p>您的应用程序是否在浏览器中运行？然后，如果测试要衡量其是否有效，它还需要在真实用户可能使用的真实浏览器中运行，并且应该针对真实 DOM 分配真实的 UI 事件。</p><p>进行大型测试很困难，因为在您的应用程序中可能同时发生数百甚至数千个事情。包括用户互动。</p><p>BigTest 是一个旨在简化和快速接受所有单页应用程序（SPA）的框架，无论框架或库如何。</p><p>当我们在网络上构建应用时，我们希望能够在接近用户的地方对其进行测试。</p><p>真实用户将使用真实的浏览器来访问你的应用；那么测试是否是在真实的浏览器中进行的呢？<br>并非每个人都使用相同的浏览器，那么测试是否可以在多个不同的浏览器和设备上进行呢？<br>网络呢？您的应用可能会与网络进行对话，而您的测试也应该考虑到这一点，对吧？<br>更不用说一个人不会在组件级别上与您的应用进行交互。<br>他们正在一起使用整个应用程序。 您的所有组件相互协作以创造一种体验。</p><p>如果测试无法以与人使用应用程序相同的方式测试应用程序，那么你会对自己的 app 有信心吗？</p><p>在开始寻找最适合 SPA 的测试工具时，我们有一些要求：</p><ul><li>快速</li><li>构建组件（包括可组合的组件）</li><li>跨浏览器（Firefox，IE，Safari 等</li><li>跨设备（Windows，macOS，iOS，Android 等）</li><li>跨框架（React，Vue，Ember，Angular 等）</li><li>跨测试框架（Mocha，Jasmine 等）</li></ul><p>目前已经有类似的工具，如 Jest，但是这些测试无法在真正的浏览器中运行。还有赛普拉斯（Cypress），但截至本文撰写之时，您目前无法在 Chrome 之外使用它（其他不久将通过 webdriver 推出），并且还没有在组件中进行编写。</p><p>下面的对比：</p><table><thead><tr><th>Test Framework</th><th>Fast</th><th>Cross Browser</th><th>Cross Device</th><th>Cross Test Runner</th><th>Cross Framework</th><th>Composable</th></tr></thead><tbody><tr><td>BigTest</td><td>🏎</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>Cypress</td><td>🚗</td><td>❌</td><td>❌</td><td>❌</td><td>✅</td><td>❌</td></tr><tr><td>Selenium</td><td>🚌</td><td>✅</td><td>❌</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>Jest</td><td>🏎</td><td>❌</td><td>❌</td><td>❌</td><td>✅</td><td>❌</td></tr></tbody></table><p>大多数现有框架都选中了其中一些（或部分选中了它们），但不是全部。<br>随着移动浏览在当今世界变得如此普遍，我们需要一种可以轻松地在我们手边的任何设备上运行测试（通过访问 URL）的工具。</p><h2 id="测试理念"><a href="#测试理念" class="headerlink" title="测试理念"></a>测试理念</h2><p>使用 BigTest 编写测试时，务必像用户将使用您的应用程序一样编写测试。<br>当某人与您的应用进行交互时，他们使用的鼠标和键盘将转换为您的应用响应的浏览器事件。<br>他们正在点击事物，期望取得成果。 这也是我们应用程序的测试所要做的：发送浏览器事件并断言有反馈。<br>我们都知道存在跨浏览器的错误！</p><p>如果是要访问组件或控制状态的测试，那不是适当的 BigTest。 所有互动都应来自用户群。<br>需要注意的另一件事是，确保您断言的是用户在应用中看到或交互的状态。</p><p>目的是进行交互，并观察由交互引发的页面上的正确变更。</p><h2 id="BigTest-如何运作？"><a href="#BigTest-如何运作？" class="headerlink" title="BigTest 如何运作？"></a>BigTest 如何运作？</h2><p>BigTest 会将您的应用程序安装并呈现到浏览器中。然后将执行您编写的测试。<br>Interactor 驱动应用程序，它位于浏览器内部，带有 tests 和 render 的应用程序。<br>这是 BigTest 与其他测试框架之间的主要区别，BigTest 没有控制浏览器的单独过程。</p><p>这就是为什么您只需访问 URL 即可运行 BigTests 的原因。</p><p>在高层的 BigTest 中：</p><ul><li>启动您的应用程序服务器（捆绑测试和应用程序）</li><li>启动浏览器</li><li>开始运行测试运行器</li><li>Interactor 驱动应用程序（单击此处，访问路由等）</li><li>结果报告回 CLI</li></ul><h2 id="组成-BigTest-的软件包"><a href="#组成-BigTest-的软件包" class="headerlink" title="组成 BigTest 的软件包"></a>组成 BigTest 的软件包</h2><p>BigTest 框架由几个小程序包组成，这些程序包也可以单独使用。了解这些软件包及其在 BigTest 框架中的作用是有帮助的。</p><h3 id="Convergence"><a href="#Convergence" class="headerlink" title="Convergence"></a>Convergence</h3><p><a href="https://bigtestjs.io/docs/convergence/" target="_blank" rel="noopener">Convergence</a> 是不可变，可重用和可组合的断言，使您可以立即知道何时达到期望的状态。<br>简而言之：它每 10 毫秒检查一次 DOM（默认情况下为 2 秒），以查看您要检查的状态是否存在。</p><p>Convergence 是 BigTest 中所有事物的基础。这就是使 interactors 可靠的原因。<br>CLI 中甚至将 Convergence 用于等待浏览器连接状态。</p><h3 id="Interactor"><a href="#Interactor" class="headerlink" title="Interactor"></a>Interactor</h3><p>在生物学中， interactor 被定义为自然选择所作用的有机体的一部分。<br>BigTest interactor 定义了要对其进行测试的应用程序的一部分。<br>您可以将 interactor 视为现代组件的可组合页面对象。</p><p>interactor 是 BigTest 的灵魂，简而言之，我们将应用程序呈现到浏览器中，而交互器将其驱动。<br>他们使用 Convergence 来确保元素存在并且可以在执行所需的交互之前与之交互。</p><p>interactor 还与您使用现代组件获得的可组合性相匹配。这意味着您可以以类似于编写 UI 的方式来编写测试。</p><p>要了解有关 interactor 的更多信息，请务必查看<a href="https://bigtestjs.io/guides/interactors/introduction" target="_blank" rel="noopener">interactor guides</a>。</p><h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><p>BigTest CLI 旨在简化 SPA 中的验收测试设置（例如 setup，build tool integration 和浏览器启动）</p><p>您可以将 CLI 视为 Karma 或 Testem，但更易于设置并包含其他可与 BigTest 框架配合使用的有用 CLI 命令（例如 bigtest init）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;知道应用程序是否正常运行的最可靠方法是实际运行它。大型测试会在每个测试用例之前启动整个应用程序。&lt;/p&gt;
&lt;p&gt;您的应用程序是否在浏览器中运行？然后，如果测试要衡量其是否有效，它还需要在真实用户可能使用的真实浏览器中运行，并且应该针对真实 DOM 分配真实的 UI 事件。&lt;
      
    
    </summary>
    
      <category term="bigtest" scheme="https://shleyz.github.io/categories/bigtest/"/>
    
    
      <category term="bigtest" scheme="https://shleyz.github.io/tags/bigtest/"/>
    
  </entry>
  
  <entry>
    <title>LRU 缓存淘汰算法</title>
    <link href="https://shleyz.github.io/2019/12/19/LRU-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/"/>
    <id>https://shleyz.github.io/2019/12/19/LRU-缓存淘汰算法/</id>
    <published>2019-12-19T09:02:43.000Z</published>
    <updated>2020-02-28T05:44:47.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在移动端浏览器中避免使用100vh</title>
    <link href="https://shleyz.github.io/2019/12/06/%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8100vh/"/>
    <id>https://shleyz.github.io/2019/12/06/在移动端避免使用100vh/</id>
    <published>2019-12-06T02:21:55.000Z</published>
    <updated>2021-02-03T07:11:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>CSS中如果要设置元素的样式占据整个屏幕的高度，则可以设置height: 100vh。这样可以实现根据屏幕的高度而改变元素的高度，可以填充整个屏幕。</p><p>然而在实际中并非如此，100vh实现的功能在移动设备的浏览器中基本被破坏，使它基本没用。</p><p>核心原因就在于移动设备的浏览器中的地址栏，有时可见，有时隐藏，从而导致改变了视口的可见大小。<br>但浏览器的可见高度改变时，并不是把可见高度的部分自适应为100vh，反而是：这些浏览器将100vh设置为浏览器的高度，地址栏隐藏。导致的结果是，当地址栏可见时，屏幕的底部将被切断，从而从一开始就破坏了100vh的目的。</p><p>如下所示： </p><p><img src="http://ww1.sinaimg.cn/large/8c85763dly1g9msvf5xayj20qo0k0q3b.jpg" alt="移动端100vh"></p><p>当地址栏可见时，屏幕底部被切断，因为移动浏览器错误的将100vh设置为屏幕的高度，因此没有显示地址栏。在上图，本应该在屏幕底部被显示的按钮被隐藏了。</p><p>更糟糕的是，当用户第一次访问移动网站时，地址栏将显示在顶部，因此默认体验到的时错误的体验。</p><h2 id="更好的解决方案：window-innerhight"><a href="#更好的解决方案：window-innerhight" class="headerlink" title="更好的解决方案：window.innerhight"></a>更好的解决方案：window.innerhight</h2><p>解决此问题的一种方法是依靠javascript而不是CSS。页面加载时，将高度设置为window.innerHeight，这样可以正确的将高度设置为视口的高度。如果地址栏可见，window.innerHeight则将是全屏的高度。如果地址栏是隐藏的，window.innerHeight则将是屏幕上可见部分的高度，这正是我们所期望的。</p><p>遗憾的是，在不依赖JavaScript的情况下，仍然没有一种简单的方法来使元素占据整个视口高度。height: 100vh 非常接近，但给它在移动端浏览器上有局限性，最好避免这样使用它。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CSS中如果要设置元素的样式占据整个屏幕的高度，则可以设置height: 100vh。这样可以实现根据屏幕的高度而改变元素的高度，可以填充整个屏幕。&lt;/p&gt;
&lt;p&gt;然而在实际中并非如此，100vh实现的功能在移动设备的浏览器中基本被破坏，使它基本没用。&lt;/p&gt;
&lt;p&gt;核心原
      
    
    </summary>
    
      <category term="css" scheme="https://shleyz.github.io/categories/css/"/>
    
    
      <category term="移动端开发" scheme="https://shleyz.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
