<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shley 的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shleyz.github.io/"/>
  <updated>2020-05-08T02:48:55.368Z</updated>
  <id>https://shleyz.github.io/</id>
  
  <author>
    <name>shley</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>antdPro</title>
    <link href="https://shleyz.github.io/2020/05/08/antdPro/"/>
    <id>https://shleyz.github.io/2020/05/08/antdPro/</id>
    <published>2020-05-08T02:21:02.000Z</published>
    <updated>2020-05-08T02:48:55.368Z</updated>
    
    <content type="html"><![CDATA[<p>作者是这样描述的：dva 是 react 和 redux 的最佳实践。</p><p>而 antd-pro 就是作者把 UI 工具 antd，打包工具 roadhog，路由 react-router，状态管理器 dva 整合在一起</p><h2 id="dva-数据流"><a href="#dva-数据流" class="headerlink" title="dva 数据流"></a>dva 数据流</h2><ul><li><p>service：请求定义，并且按照 model 的维度进行拆分</p></li><li><p>utils/request.ts：统一的请求发送和错误处理</p></li><li><p>model: 处理数据逻辑部分，包含 state 初始值 和 reducers（相当于 redux 里面的 reducer，根据 action 来更新 state）</p></li></ul><h4 id="创建一个页面，除了需要配置相应的路由和权限，还需要两个部分，一个是-ui-组件，另一个就是-model-部分。"><a href="#创建一个页面，除了需要配置相应的路由和权限，还需要两个部分，一个是-ui-组件，另一个就是-model-部分。" class="headerlink" title="创建一个页面，除了需要配置相应的路由和权限，还需要两个部分，一个是 ui 组件，另一个就是 model 部分。"></a>创建一个页面，除了需要配置相应的路由和权限，还需要两个部分，一个是 ui 组件，另一个就是 model 部分。</h4><h4 id="在组件内部调用-dispatch-方法，根据传的-type-来执行-model-里面的对应的命名空间的-effects，进而可以修改-state-值。"><a href="#在组件内部调用-dispatch-方法，根据传的-type-来执行-model-里面的对应的命名空间的-effects，进而可以修改-state-值。" class="headerlink" title="在组件内部调用 dispatch 方法，根据传的 type 来执行 model 里面的对应的命名空间的 effects，进而可以修改 state 值。"></a>在组件内部调用 dispatch 方法，根据传的 type 来执行 model 里面的对应的命名空间的 effects，进而可以修改 state 值。</h4><h4 id="在-UI-组件内部使用高阶组件-connect-包裹组件，可以在组件内部使用-model-里面的-state。"><a href="#在-UI-组件内部使用高阶组件-connect-包裹组件，可以在组件内部使用-model-里面的-state。" class="headerlink" title="在 UI 组件内部使用高阶组件 connect 包裹组件，可以在组件内部使用 model 里面的 state。"></a>在 UI 组件内部使用高阶组件 connect 包裹组件，可以在组件内部使用 model 里面的 state。</h4><h2 id="1-组件内部调用-dispatch-一个-action，需要指定命名空间的-model-里面的-action："><a href="#1-组件内部调用-dispatch-一个-action，需要指定命名空间的-model-里面的-action：" class="headerlink" title="1. 组件内部调用 dispatch 一个 action，需要指定命名空间的 model 里面的 action："></a>1. 组件内部调用 dispatch 一个 action，需要指定命名空间的 model 里面的 action：</h2><p><img src="https://user-images.githubusercontent.com/11802509/81363902-fbead280-9116-11ea-80fc-172b86c984f1.png" alt="dispatch"></p><h2 id="2-model-部分"><a href="#2-model-部分" class="headerlink" title="2. model 部分"></a>2. model 部分</h2><p><img src="https://user-images.githubusercontent.com/11802509/81364365-0a85b980-9118-11ea-886a-3d73f3b95c8f.png" alt="dispatch"></p><h2 id="3-services-里面进行-请求的定义"><a href="#3-services-里面进行-请求的定义" class="headerlink" title="3. services 里面进行 请求的定义"></a>3. services 里面进行 请求的定义</h2><p><img src="https://user-images.githubusercontent.com/11802509/81364456-43259300-9118-11ea-908d-4536a8f756a3.png" alt="dispatch"></p><h3 id="一个-model-里面会有这些属性"><a href="#一个-model-里面会有这些属性" class="headerlink" title="一个 model 里面会有这些属性:"></a>一个 model 里面会有这些属性:</h3><ul><li><p>state：model 的状态数据，一般是不可变的，只有 action 才能修改 state 值</p></li><li><p>action：改变 state 的唯一途径，需要 dispatch 来触发 action，需要传一个 type 值，来指定 state 的修改。 dispatch 一般在组件 connect 以后从 props 里面可以获取到</p></li><li><p>dispatch：触发 action 的函数，在组件 connect 以后从 props 里面可以获取到 dispatch</p></li><li><p>reducers：是一个纯函数，接收 state 和 action，返回新的 state , 同步修改状态</p></li><li><p>effect：多用于异步修改状态，将异步操作转换成同步的写法，来实现纯函数</p></li><li>subscription：订阅一个数据源，根据条件来 dispacth 一个 action，一般用来监听路由变化</li></ul><p>此外每个 model 还需要定义一个 namespace 命名空间，也是全局 state 里面的属性，</p><p>例如 connect 指定的 state 时会用到，dispatch 指定的命名空间的 effects 也会用到</p><h3 id="model-里面的-effect-的使用"><a href="#model-里面的-effect-的使用" class="headerlink" title="model 里面的 effect 的使用:"></a>model 里面的 effect 的使用:</h3><ul><li>call 一般用来调用 api 接口，并可以获取到返回值</li><li>put 大致与 dispatch 相同，可让 effects 里的方法调用修改 state 的方法</li><li>select 用于获取 state 变量<br>此外 antd-pro 引入了 typescript，对 js 代码进行的类型检测，配合 tslint，能够严格约束代码的编写，虽然有些时候遇到的一些类型警报，可以用 any 类型解决，但是非常不建议这样做。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者是这样描述的：dva 是 react 和 redux 的最佳实践。&lt;/p&gt;
&lt;p&gt;而 antd-pro 就是作者把 UI 工具 antd，打包工具 roadhog，路由 react-router，状态管理器 dva 整合在一起&lt;/p&gt;
&lt;h2 id=&quot;dva-数据流&quot;&gt;
      
    
    </summary>
    
      <category term="antdPro" scheme="https://shleyz.github.io/categories/antdPro/"/>
    
    
      <category term="antdPro" scheme="https://shleyz.github.io/tags/antdPro/"/>
    
  </entry>
  
  <entry>
    <title>实现图片懒加载</title>
    <link href="https://shleyz.github.io/2020/04/02/interview-%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <id>https://shleyz.github.io/2020/04/02/interview-实现图片懒加载/</id>
    <published>2020-04-02T05:17:48.000Z</published>
    <updated>2021-02-02T05:55:15.277Z</updated>
    
    <content type="html"><![CDATA[<p>主要原理是判断图片是否在可视区域内部，图片移动到可视区域内部，进行加载。</p><p>有三种判断方法：</p><ul><li><ol><li>offsetTop &lt; clientHeight + scrollTop</li></ol></li><li><ol start="2"><li>element.getBoundingClientRect().top &lt; clientHeight. 缺点是，由于 scroll 事件密集发生，计算量很大，容易造成性能问题。</li></ol></li><li><ol start="3"><li>IntersectionObserver, 使用方法：</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(callback, option);</span><br></pre></td></tr></table></figure><p>IntersectionObserver 是浏览器原生提供的构造函数，接受两个参数：callback 是可见性变化时的回调函数，option 是配置对象（该参数可选）。</p><p>使用方法三实现懒加载的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> query = <span class="function">(<span class="params">selector</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(selector));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">changes</span>) =&gt;</span> &#123;</span><br><span class="line">  changes.forEach(<span class="function">(<span class="params">change</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> container = change.target;</span><br><span class="line">    <span class="keyword">const</span> content = container.querySelector(<span class="string">'template'</span>).content;</span><br><span class="line">    container.appendChild(content);</span><br><span class="line">    observer.unobserve(container)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">query(<span class="string">'.lazy-load'</span>).forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  observer.observer(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，只有目标区域可见时，才会将模板内容插入真实 DOM，从而引发静态资源的加载。</p><p>注：<br><strong>clientHeight</strong><br>  表示页面可见区域的高度, 只包括 padding, 不包括 border<br><strong>offsetHeight</strong><br>  表示页面可见区域的高度，包括 border<br><strong>scrollTop</strong><br>  表示网页被卷去的高，就是滚动条上滚的页面高度<br><strong>element.getBoundingClientRect()</strong><br>  表示获取某个元素 element 相对于视窗的位置集合。<br><strong>element.getBoundingClientRect().top</strong><br>  表示获取某个元素 element 相对于视窗的顶部的距离。<br><strong>window.screen.height</strong><br>  表示屏幕分辨率高</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要原理是判断图片是否在可视区域内部，图片移动到可视区域内部，进行加载。&lt;/p&gt;
&lt;p&gt;有三种判断方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;offsetTop &amp;lt; clientHeight + scrollTop&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;
      
    
    </summary>
    
      <category term="javascript" scheme="https://shleyz.github.io/categories/javascript/"/>
    
    
      <category term="面试基础" scheme="https://shleyz.github.io/tags/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>dart学习</title>
    <link href="https://shleyz.github.io/2020/02/13/dart%E5%AD%A6%E4%B9%A0/"/>
    <id>https://shleyz.github.io/2020/02/13/dart学习/</id>
    <published>2020-02-13T09:36:57.000Z</published>
    <updated>2020-03-13T10:18:10.440Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>Dart 要求以 main 函数作为执行的入口</p></li><li><p>变量的声明可以用 var 或者 具体的类型，当使用 var 定义变量时，编译器会推断决定变量的类型。</p></li><li><p>默认未初始化的变量都是 null</p></li><li><p>Dart 是类型安全的语言，所有的类型都是对象，继承自 Object。一切类型的值都是对象的实例，包括数字，布尔，函数和 null</p></li><li><p>Dart 内置数据类型: num</p><ul><li>num 只有两种子类： 64 位 int 和 64 位 double（符合 IEEE 754 标准的）</li><li>64 位 int 代表整数类型， 64 位 double 代表浮点数</li><li>继承自num的运算符有 +,-,*,/,%,abs()绝对值,round()取整,还有&lt;,&gt;等比较运算符</li><li>dart:math 库提供了诸如三角函数、指数、对数、平方根等高级函数</li></ul></li><li><p>Dart 内置数据类型: bool</p><p>  因为 Dart 类型是安全的，所以不能在 if 判断或者 assert 中使用非布尔类型。</p></li><li><p>Dart 内置数据类型: String</p><p>  使用 ‘ 或者 “ 来表示字符串字面量<br>  ${express} 可以在字符串中嵌入变量<br>  ‘+’ 可以实现字符串的拼接<br>  ‘’’jksdhk<br>  jashdkjas<br>  dgkhjas’’’可以实现多行字符输出</p></li><li><p>Dart 内置数据类型: List</p><ul><li>声明方法一： var arr1 = <string>[“Tom”, “Andy”, “Jack”];</string></li><li>声明方法二： var arr2 = new List<int>.of([1,2,3]);</int></li><li>数组添加元素： arr2.add(499); // 添加的元素类型必须与数组里面元素类型一致。</li><li>数组遍历： arr2.forEach((v) =&gt; print(‘${v}’));</li></ul></li><li><p>Dart 内置数据类型: Map</p><ul><li>声明方法一： var map1 = {‘name’: ‘Tom’,’sex’: ‘male’,};;</li><li>声明方法二： var map2 = new Map<string string>();</string></li><li>数组添加元素： map2[‘name’] = ‘Tom’; // 添加的元素类型必须与Map里面元素类型一致。</li><li>数组遍历： map2.forEach((k,v) =&gt; print(‘${k}: ${v}’));</li></ul></li><li><p>Dart 常量，使用 final 或者 const 声明</p><ul><li>const，表示变量在编译期间即能确定的值；</li><li>final 则不太一样，用它定义的变量可以在运行时确定值，而一旦确定后就不可再变。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;Dart 要求以 main 函数作为执行的入口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;变量的声明可以用 var 或者 具体的类型，当使用 var 定义变量时，编译器会推断决定变量的类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;默认未初始化的变量都是 null&lt;/p
      
    
    </summary>
    
      <category term="dart" scheme="https://shleyz.github.io/categories/dart/"/>
    
    
      <category term="dart" scheme="https://shleyz.github.io/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>@bigtest/react</title>
    <link href="https://shleyz.github.io/2020/01/08/bigtest-react/"/>
    <id>https://shleyz.github.io/2020/01/08/bigtest-react/</id>
    <published>2020-01-08T05:14:24.000Z</published>
    <updated>2020-02-28T05:44:47.718Z</updated>
    
    <content type="html"><![CDATA[<p>进行大型测试的 React DOM 助手：@bigtest/react</p><p>github 地址： <a href="https://github.com/bigtestjs/react" target="_blank" rel="noopener">https://github.com/bigtestjs/react</a></p><p>这个软件包的目的是提供一套帮助程序，使得能够更加容易的测试 React 程序</p><h2 id="mount-方法"><a href="#mount-方法" class="headerlink" title="mount 方法"></a>mount 方法</h2><p>在一个新的 DOM 节点异步加载一个组件，返回 promise， 一连串的使用将清除所有先前安装的组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@bigtest/react'</span>;</span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'../src/components/button'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'My button'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// `mount` 返回Promise: 渲染后resolves</span></span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> mount(<span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Button</span> /&gt;</span></span>));</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'renders'</span>, () =&gt; &#123;</span><br><span class="line">    expect(<span class="built_in">document</span>.querySelector(<span class="string">'.button'</span>)).to.exist;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="setupAppForTesting"><a href="#setupAppForTesting" class="headerlink" title="setupAppForTesting"></a>setupAppForTesting</h2><p>setupAppForTesting 不仅会 mount 应用程序组件，还将使用该组件的实例进行解析，并提供一个内存重的 history 对象，供 React Router 在测试期间使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; setupAppForTesting &#125; <span class="keyword">from</span> <span class="string">'@bigtest/react'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../src/app'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'My Application'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> app;</span><br><span class="line">  beforeEach(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    app = <span class="keyword">await</span> setupAppForTesting(App);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'renders'</span>, () =&gt; &#123;</span><br><span class="line">    expect(<span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>)).to.exist;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="string">'has a history prop'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// this prop is only provided if defined in `propTypes`</span></span><br><span class="line">    expect(app.props).to.have.property(<span class="string">'history'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="visit"><a href="#visit" class="headerlink" title="visit"></a>visit</h2><p>只有在使用 setupAppForTesting，并与应用程序的 history 属性进行交互以在路由之间导航后，才会起作用。（visit, goBack, goForward, and location 都是这样）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; setupAppForTesting, visit, location &#125; <span class="keyword">from</span> <span class="string">'@bigtest/react'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../src/app'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'My Application'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> app;</span><br><span class="line">  beforeEach(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    app = <span class="keyword">await</span> setupAppForTesting(App);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  describe(<span class="string">'navigating'</span>, () =&gt; &#123;</span><br><span class="line">    beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> visit(<span class="string">'/some-route'</span>));</span><br><span class="line"></span><br><span class="line">    it(<span class="string">'is at the new route'</span>, () =&gt; &#123;</span><br><span class="line">      expect(location()).to.have.property(<span class="string">'pathname'</span>, <span class="string">'/some-route'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup"></a>cleanup</h2><p>在每次 mount 和 setupAppForTesting 调用开始时都会调用 cleanup，以清除以前安装的任何组件或应用程序。 如果您需要自己清理以前安装的组件，也可以单独使用它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mount, cleanup &#125; <span class="keyword">from</span> <span class="string">'@bigtest/react'</span>;</span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'../src/components/button'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'My Button'</span>, () =&gt; &#123;</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> mount(<span class="xml"><span class="tag">&lt;<span class="name">Button</span> /&gt;</span></span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了可以在测试运行后调查并使用组件进行调试，最好不要这样做</span></span><br><span class="line">  afterEach(<span class="function"><span class="params">()</span> =&gt;</span> cleanup());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>mount 和 setupAppForTesting 都有第二个参数： 一个对象包含一系列的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mount(<span class="xml"><span class="tag">&lt;<span class="name">Button</span> /&gt;</span></span>, &#123;</span><br><span class="line">  mountId: <span class="string">'testing-root'</span>,  <span class="comment">// 作为加载的DOM节点的id</span></span><br><span class="line">  rootElement: <span class="built_in">document</span>.body, <span class="comment">// 加载的DOM节点的位置</span></span><br><span class="line">  setup: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,  <span class="comment">// 在组件加载好之前调用， 如果返回的是promise，则组件会在resolve之后加载</span></span><br><span class="line">  teardown: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;  <span class="comment">// 在下一个 cleanup 调用时调用，或者在下一个mount或setupAppForTesting开始时调用，或者在直接调用 cleanup 时调用。 和“ setup”一样，如果返回的是promise，则组件会在resolve之后加载</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此外， setupAppForTesting 接受一个 props 选项， 该选项将与所有用户定义的 props 一起传递给应用程序组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setupAppForTesting(App, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    store: createStore(),</span><br><span class="line">    <span class="comment">// you can provide your own history object as well</span></span><br><span class="line">    history: createHistory(historyOptions)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="可重用性"><a href="#可重用性" class="headerlink" title="可重用性"></a>可重用性</h2><p>为了在测试应用程序时获得最佳体验，任何不属于组件生命周期中的必需的逻辑，都应该是可重用的。通过提供必要的 setup 和 teardown 选项，或者将逻辑移入组件生命周期挂钩中。</p><p>除此之外，在您自己的 test helper 中使用 setupAppForTesting 可能很有意义，因为它可以处理任何其他必要的设置。 这也使我们不必导入应用程序并在每个测试文件中重复设置逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test/helper.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; setupAppForTesting &#125; <span class="keyword">from</span> <span class="string">'@bigtest/react'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; visit, goBack, goForward, location &#125; <span class="keyword">from</span> <span class="string">'@bigtest/react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../src/app'</span>;</span><br><span class="line"><span class="keyword">import</span> createServer <span class="keyword">from</span> <span class="string">'./mocks/server'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setupApplicationForTesting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  beforeEach(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) =&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.app = <span class="keyword">await</span> setupAppForTesting(App, () =&gt; &#123;</span><br><span class="line">      setup: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.server = createServer(),</span><br><span class="line">      teardown: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.server.shutdown()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更好的测试"><a href="#更好的测试" class="headerlink" title="更好的测试"></a>更好的测试</h2><p>这些 helpers 使您可以反复安装应用程序进行测试，而与应用程序进行交互也可能会很麻烦。</p><p><a href="https://github.com/bigtestjs/interactor" target="_blank" rel="noopener">@bigtest/interactor</a> 提供了一个更简单的方法，通过任何浏览器与应用的各个部分进行交互。就好像是用户在和你的 app 进行交互。实际上，可组合的 interactors 是测试使用可组合 components 制作的 app 的完美伴侣。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; setupAppForTesting &#125; <span class="keyword">from</span> <span class="string">'@bigtest/react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../src/app'</span>;</span><br><span class="line"><span class="keyword">import</span> HomePageInteractor <span class="keyword">from</span> <span class="string">'./interactors/home'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'My Applicaion'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> home = <span class="keyword">new</span> HomePageInteractor();</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> setupAppForTesting(App));</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'has a fancy button'</span>, () =&gt; &#123;</span><br><span class="line">    except(home.button.isPresent).to.be.true;</span><br><span class="line">    except(home.button.isFancy).to.be.true;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进行大型测试的 React DOM 助手：@bigtest/react&lt;/p&gt;
&lt;p&gt;github 地址： &lt;a href=&quot;https://github.com/bigtestjs/react&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:/
      
    
    </summary>
    
      <category term="bigtest" scheme="https://shleyz.github.io/categories/bigtest/"/>
    
    
      <category term="bigtest" scheme="https://shleyz.github.io/tags/bigtest/"/>
    
  </entry>
  
  <entry>
    <title>@bigtest/convergence</title>
    <link href="https://shleyz.github.io/2020/01/08/bigtest-convergence/"/>
    <id>https://shleyz.github.io/2020/01/08/bigtest-convergence/</id>
    <published>2020-01-08T03:21:48.000Z</published>
    <updated>2020-02-28T05:44:47.717Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://bigtestjs.io/docs/convergence/" target="_blank" rel="noopener">Convergence</a> 是强大,不可变，可重用和可组合的断言，使您可以立即知道何时达到期望的状态。<br>简而言之：它每 10 毫秒检查一次 DOM（默认情况下为 2 秒），以查看您要检查的状态是否存在。</p><p>Convergence 是 BigTest 中所有事物的基础。这就是使 interactors 可靠的原因。<br>CLI 中甚至将 Convergence 用于等待浏览器连接状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Convergence <span class="keyword">from</span> <span class="string">'@bigtest/convergence'</span>;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> (foo = <span class="string">'bar'</span>), <span class="number">100</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Convergence().when(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'bar'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// =&gt; "bar"</span></span><br></pre></td></tr></table></figure><p>默认情况下，Convergence 将在 2000ms 之前或之后 converge，具体取决于定义的断言类型。这可以通过在初始化 convergence 时提供超时或使用 #timeout() 方法来配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Convergence(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">new</span> Convergence().timeout(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>使用 #when()，断言将运行多次直到通过。同样，#always() 确保断言在一段时间内保持通过状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// converges when `foo` is equal to `'bar'` within 100ms</span></span><br><span class="line"><span class="keyword">new</span> Convergence(<span class="number">100</span>).when(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'bar'</span>);</span><br><span class="line"><span class="comment">// converges after `foo` is equal to `'bar'` for at least 100ms</span></span><br><span class="line"><span class="keyword">new</span> Convergence(<span class="number">100</span>).always(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'bar'</span>);</span><br></pre></td></tr></table></figure><p>convergence 是不可变的，因此，它的方法将返回新实例。 这使您可以组合多个 convergence，并使用各自的 #run() 方法分别启动每个 convergence。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> converge = <span class="keyword">new</span> Convergence(<span class="number">300</span>);</span><br><span class="line"><span class="keyword">let</span> convergeFoo = converge.when(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> convergeFooBar = convergeFoo.when(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">let</span> convergeFooBarBaz = convergeFooBar.when(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'baz'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> (foo = <span class="string">'foo'</span>), <span class="number">100</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> (foo = <span class="string">'bar'</span>), <span class="number">200</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> (foo = <span class="string">'baz'</span>), <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolves after 100ms</span></span><br><span class="line">convergeFoo.run();</span><br><span class="line"><span class="comment">// resolves after 200ms</span></span><br><span class="line">convergeFooBar.run();</span><br><span class="line"><span class="comment">// rejects after 300ms since it wasn't `baz` _after_ `bar`</span></span><br><span class="line">convergeFooBarBaz.run();</span><br></pre></td></tr></table></figure><p>Convergences 会立即调用#run（）。这使它们能够在大多数情况下可以使用的地方使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">onceBarAlwaysBar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> Convergence().when(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'bar'</span>).always(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'bar'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([onceBarAlwaysBar(), <span class="keyword">new</span> Convergence().when(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'baz'</span>)]);</span><br></pre></td></tr></table></figure><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><h3 id="isConvergence-obj-返回布尔值"><a href="#isConvergence-obj-返回布尔值" class="headerlink" title="isConvergence(obj) 返回布尔值"></a>isConvergence(obj) 返回布尔值</h3><p>如果对象具有正确类型的 convergence 属性，则返回 true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = maybeConvergence();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isConvergence(result)) &#123;</span><br><span class="line">  <span class="keyword">await</span> result.do(something).timeout(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  something(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="always-assertion-timeout"><a href="#always-assertion-timeout" class="headerlink" title="always(assertion, timeout)"></a>always(assertion, timeout)</h3><p>传入的参数：</p><ul><li>assertion： Function 需要 converge 的断言</li><li>timeout：Number 使用的超时时间，以剩余的超时时间为上限。</li></ul><p>返回一个新的 convergence</p><p>返回带有附加断言的新 convergence 实例。重复运行此断言以确保它在整个超时时间内通过。如果在超时期间的任何时候断言失败，那么 convergence 将失败。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// would converge after `foo` remains `'foo'` for at least 100ms</span></span><br><span class="line"><span class="keyword">new</span> Convergence(<span class="number">100</span>).always(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'foo'</span>);</span><br></pre></td></tr></table></figure><p>当 convergence 结束时遇到 always 断言时，超时默认为当前正在运行的实例的剩余时间。最少 20ms。如果不在 convergence 范围内，则默认为总超时时间的十分之一。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> convergeFooThenBar = <span class="keyword">new</span> Convergence(<span class="number">1000</span>)</span><br><span class="line">  .always(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'foo'</span>) <span class="comment">// would continue after `foo` remains `'foo'` for at least 100ms</span></span><br><span class="line">  .when(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'bar'</span>); <span class="comment">// then have any time remaining to converge on `foo` being `'bar'`</span></span><br></pre></td></tr></table></figure><p>给定一个超时时间，则将其限制为当前运行实例的剩余超时时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> convergeFooThenBar = <span class="keyword">new</span> Convergence(<span class="number">100</span>)</span><br><span class="line">  .always(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'foo'</span>, <span class="number">50</span>) <span class="comment">// 当在50ms内foo持续等于'foo'，则继续</span></span><br><span class="line">  .when(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'bar'</span>) <span class="comment">// 然后还剩下50ms</span></span><br><span class="line">  .always(<span class="function"><span class="params">()</span> =&gt;</span> foo === <span class="string">'bar'</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://bigtestjs.io/docs/convergence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Convergence&lt;/a&gt; 是强大,不可变，可重用和可组合的断言，使您可以立即知道何时达到期望的状态。&lt;br&gt;
      
    
    </summary>
    
      <category term="bigtest" scheme="https://shleyz.github.io/categories/bigtest/"/>
    
    
      <category term="bigtest" scheme="https://shleyz.github.io/tags/bigtest/"/>
    
  </entry>
  
  <entry>
    <title>@bigtest/interactor开箱即用的方法和属性</title>
    <link href="https://shleyz.github.io/2020/01/07/bigtest-interactor%E5%BC%80%E7%AE%B1%E5%8D%B3%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7/"/>
    <id>https://shleyz.github.io/2020/01/07/bigtest-interactor开箱即用的方法和属性/</id>
    <published>2020-01-07T09:36:46.000Z</published>
    <updated>2020-02-28T05:44:47.718Z</updated>
    
    <content type="html"><![CDATA[<p>以下是 interactor 开箱即用可用的各种交互的简要说明。</p><h2 id="Default-Interactions"><a href="#Default-Interactions" class="headerlink" title="Default Interactions"></a>Default Interactions</h2><p>这些默认的交互属性和方法在所有 interactor 上都可用，但是在定义自己的自定义 interactor 时可以安全地覆盖它们。</p><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>如果元素不能位于 Interactions 的根元素中，则所有属性（isPresent 除外）都将引发错误。</p><ol><li>#text： 返回元素 trimmed 后的 textContent 属性</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Interactor(<span class="string">'p'</span>).text;</span><br></pre></td></tr></table></figure><ol start="2"><li>#value: 返回元素的 value 属性</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Interactor(<span class="string">'input'</span>).value;</span><br></pre></td></tr></table></figure><ol start="3"><li>#isVisible: 如果元素在文档中可见，则返回 true 否则 false</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Interactor(<span class="string">'#foo'</span>).isVisible; <span class="comment">//=&gt; true</span></span><br><span class="line"><span class="keyword">new</span> Interactor(<span class="string">'#bar'</span>).isVisible; <span class="comment">//=&gt; false</span></span><br></pre></td></tr></table></figure><ol start="4"><li>#isHidden： 如果元素存在于文档中但在视觉上被隐藏，则返回 true 否则 false</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Interactor(<span class="string">'#foo'</span>).isHidden; <span class="comment">//=&gt; false</span></span><br><span class="line"><span class="keyword">new</span> Interactor(<span class="string">'#bar'</span>).isHidden; <span class="comment">//=&gt; true</span></span><br></pre></td></tr></table></figure><ol start="5"><li>#isPresent： 如果可以在文档中找到一个元素，则返回 true 否则 false。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Interactor(<span class="string">'#foo'</span>).isPresent; <span class="comment">//=&gt; true</span></span><br><span class="line"><span class="keyword">new</span> Interactor(<span class="string">'#bar'</span>).isPresent; <span class="comment">//=&gt; false</span></span><br></pre></td></tr></table></figure><h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><p>所有默认的交互方法都接受一个可选的选择器作为第一个参数。给定一个选择器，将在父交互器的根元素内的匹配元素上进行交互。</p><p>注意：交互方法将返回交互器的新实例，并且在新实例上调用#run（）方法之前不会进行任何交互。</p><ol><li>#click([selector]) 触发元素上的点击事件。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'button'</span>).click();</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'form'</span>).click(<span class="string">'[type="submit"]'</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>#fill([selector], value) 更改元素的值并触发输入和更改事件。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'input'</span>).fill(<span class="string">'value'</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'form'</span>).fill(<span class="string">'input#name'</span>, <span class="string">'value'</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>#select([selector], option) 通过文本值选择一个选项并触发输入和更改事件。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'select'</span>).select(<span class="string">'February'</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'form'</span>).fill(<span class="string">'select#month'</span>, <span class="string">'March'</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>#focus([selector]) 在元素上触发焦点事件。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'input'</span>).focus();</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'form'</span>).focus(<span class="string">'input[type="email"]'</span>);</span><br></pre></td></tr></table></figure><ol start="5"><li>#blur([selector]) 在元素上触发失去焦点事件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'input'</span>).blur();</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'form'</span>).blur(<span class="string">'input[type="email"]'</span>);</span><br></pre></td></tr></table></figure><ol start="6"><li>#scroll([selector], { top, left }) 设置元素的 scrollTop 和 scrollLeft 属性并触发滚动事件。顶部和左侧的值指定在该方向上滚动到多少像素；必须至少指定一个方向。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'#page'</span>).scroll(&#123; <span class="attr">top</span>: <span class="number">100</span> &#125;);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'#page'</span>).scroll(<span class="string">'.nested-view'</span>, &#123; <span class="attr">left</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure><ol start="7"><li>#trigger([selector], name[, options]) 使用任何指定的事件选项在元素上触发任意事件，名称。默认情况下，气泡和可取消选项设置为 true。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'#foo'</span>).trigger(<span class="string">'customEvent'</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'#foo'</span>).trigger(<span class="string">'customEvent'</span>, &#123; ... &#125;);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'#foo'</span>).trigger(<span class="string">'#bar'</span>, <span class="string">'customEvent'</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'#foo'</span>).trigger(<span class="string">'#bar'</span>, <span class="string">'customEvent'</span>, &#123; ... &#125;);</span><br></pre></td></tr></table></figure><h2 id="Property-Creators"><a href="#Property-Creators" class="headerlink" title="Property Creators"></a>Property Creators</h2><p>使用 @interactor 类装饰器创建自己的自定义 interactors 时，可以利用 Property creators。<br>就像默认方法一样，creator 函数接受一个可选的选择器。但是，生成的实例方法没有可选的 selector 参数。</p><h3 id="Properties-1"><a href="#Properties-1" class="headerlink" title="Properties"></a>Properties</h3><p>interactor Property creators 返回一个 getter。就像默认属性一样，除了 isPresent 之外，如果元素不能位于 interactor 的根元素中，则所有属性都会引发错误。</p><ol><li>text([selector]) 返回元素 trimmed 后的 textContent 属性</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageInteractor</span> </span>&#123;</span><br><span class="line">  heading = text(<span class="string">'h1'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> PageInteractor().heading; <span class="comment">//=&gt; "Hello World!"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>value([selector]) 返回元素的 value 属性。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormInteractor</span> </span>&#123;</span><br><span class="line">  name = value(<span class="string">'input#name'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).name; <span class="comment">//=&gt; "Foo Bar"</span></span><br></pre></td></tr></table></figure><ol start="3"><li>isVisible([selector]) 如果元素在文档中可见，则返回 true 否则 false</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">style</span>=<span class="string">"display: none"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageInteractor</span> </span>&#123;</span><br><span class="line">  isFooVisible = isVisible(<span class="string">'#foo'</span>);</span><br><span class="line">  isBarVisible = isVisible(<span class="string">'#bar'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> PageInteractor().isFooVisible; <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="keyword">new</span> PageInteractor().isBarVisible; <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><ol start="4"><li>isHidden([selector]) 如果元素存在于文档中但在视觉上被隐藏，则返回 true 否则 false。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">style</span>=<span class="string">"display: none"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageInteractor</span> </span>&#123;</span><br><span class="line">  isFooHidden = isHidden(<span class="string">'#foo'</span>);</span><br><span class="line">  isBarHidden = isHidden(<span class="string">'#bar'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> PageInteractor().isFooHidden; <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="keyword">new</span> PageInteractor().isBarHidden; <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><ol start="5"><li>isPresent([selector]) 如果可以在文档中找到一个元素，则返回 true 否则 false。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageInteractor</span> </span>&#123;</span><br><span class="line">  isFooPresent = isPresent(<span class="string">'#foo'</span>);</span><br><span class="line">  isBarPresent = isPresent(<span class="string">'#bar'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> PageInteractor().isFooPresent; <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="keyword">new</span> PageInteractor().isBarPresent; <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><ol start="6"><li>attribute([selector], attr) 通过 getAttribute 返回元素的指定属性。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"card-link"</span> <span class="attr">href</span>=<span class="string">"https://example.com"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CardInteractor</span> </span>&#123;</span><br><span class="line">  id = attribute(<span class="string">'id'</span>);</span><br><span class="line">  url = attribute(<span class="string">'.card-link'</span>, <span class="string">'href'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> CardInteractor(<span class="string">'.card'</span>).id; <span class="comment">//=&gt; "foo"</span></span><br><span class="line"><span class="keyword">new</span> CardInteractor(<span class="string">'.card'</span>).url; <span class="comment">//=&gt; "https://example.com"</span></span><br></pre></td></tr></table></figure><ol start="7"><li>property([selector], prop) 返回元素的指定属性值。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span> <span class="attr">style</span>=<span class="string">"height: 100px"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"card-cta"</span> <span class="attr">disabled</span>&gt;</span>...<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CardInteractor</span> </span>&#123;</span><br><span class="line">  height = property(<span class="string">'offsetHeight'</span>);</span><br><span class="line">  isDisabled = property(<span class="string">'button.card-cta'</span>, <span class="string">'disabled'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> CardInteractor(<span class="string">'.card'</span>).height; <span class="comment">//=&gt; 100</span></span><br><span class="line"><span class="keyword">new</span> CardInteractor(<span class="string">'.card'</span>).isDisabled; <span class="comment">//=&gt; true</span></span><br></pre></td></tr></table></figure><ol start="8"><li>hasClass([selector], className) 如果元素的 classList 包含指定的类名，则返回 true 否则 false。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"error"</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"name"</span> <span class="attr">class</span>=<span class="string">"error"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">id</span>=<span class="string">"email"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormInteractor</span> </span>&#123;</span><br><span class="line">  hasErrors = hasClass(<span class="string">'error'</span>); <span class="comment">// applies to the root</span></span><br><span class="line">  hasNameError = hasClass(<span class="string">'input#name'</span>, <span class="string">'error'</span>);</span><br><span class="line">  hasEmailError = hasClass(<span class="string">'input#email'</span>, <span class="string">'error'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).hasErrors; <span class="comment">//=&gt; true</span></span><br><span class="line"><span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).hasNameError; <span class="comment">//=&gt; true</span></span><br><span class="line"><span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).hasEmailError; <span class="comment">//=&gt; false</span></span><br></pre></td></tr></table></figure><ol start="9"><li>is([selector], match) 如果指定的匹配选择器可以通过 Element.matches（）选择一个元素，则返回 true 否则 false。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"bar"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"baz"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListInteractor</span> </span>&#123;</span><br><span class="line">  isList = is(<span class="string">'.list'</span>);</span><br><span class="line">  isFooFirst = is(<span class="string">'#foo'</span>, <span class="string">':first-child'</span>);</span><br><span class="line">  isBarLast = is(<span class="string">'#bar'</span>, <span class="string">':last-child'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).hasErrors; <span class="comment">//=&gt; true</span></span><br><span class="line"><span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).hasNameError; <span class="comment">//=&gt; true</span></span><br><span class="line"><span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).hasEmailError; <span class="comment">//=&gt; false</span></span><br></pre></td></tr></table></figure><h3 id="Methods-1"><a href="#Methods-1" class="headerlink" title="Methods"></a>Methods</h3><p>interactor methods Creators 返回链式函数，这些函数随后返回具有添加到其队列中的特定交互的新实例。直到调用交互程序的 #run() 方法或使用 async/await 语法时，interactions 才会运行。</p><ol><li>clickable([selector]) =&gt; click() 触发元素的 click 事件。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"card-link"</span> <span class="attr">href</span>=<span class="string">"https://example.com"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CardInteractor</span> </span>&#123;</span><br><span class="line">  clickThrough = clickable(<span class="string">'.card-link'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> CardInteractor(<span class="string">'.card'</span>).clickThrough();</span><br></pre></td></tr></table></figure><ol start="2"><li>fillable([selector]) =&gt; fill(value) 更改元素的 value 值并触发 input 和 change 事件</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormInteractor</span> </span>&#123;</span><br><span class="line">  fillName = fillable(<span class="string">'input#name'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).fillName(<span class="string">'value'</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>selectable([selector]) =&gt; select(option) 通过 text 值选择一个选项并触发 input 和 change 事件。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"month"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>January<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span>February<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"3"</span>&gt;</span>March<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormInteractor</span> </span>&#123;</span><br><span class="line">  selectMonth = selectable(<span class="string">'select#month'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).selectMonth(<span class="string">'February'</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>focusable([selector]) =&gt; focus() 在元素上触发 focus 事件。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> /&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormInteractor</span> </span>&#123;</span><br><span class="line">  focusEmail = focusable(<span class="string">'input[type="email"]'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).focusEmail();</span><br></pre></td></tr></table></figure><ol start="5"><li>blurrable([selector]) =&gt; blur() 在元素上触发 blur 事件。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> /&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormInteractor</span> </span>&#123;</span><br><span class="line">  blurEmail = blurrable(<span class="string">'input[type="email"]'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> FormInteractor(<span class="string">'form'</span>).blurEmail();</span><br></pre></td></tr></table></figure><ol start="6"><li>scrollable([selector]) =&gt; scroll({ top, left }) 置元素的 scrollTop 和 scrollLeft 属性并触发 scroll 事件。top 和 left 的值指定在该方向上滚动到多少像素；必须至少指定一个方向</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"page"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"scrollview"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageInteractor</span> </span>&#123;</span><br><span class="line">  scrollSection = scrollable(<span class="string">'.scrollview'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> PageInteractor(<span class="string">'#page'</span>).scrollSection(&#123; <span class="attr">top</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure><ol start="7"><li>triggerable([selector], name[, options]) =&gt; trigger([options]) 使用任何指定的事件 options 在元素上触发任意事件，名称。默认情况下，bubbles 和 cancelable 选项设置为 true。运行交互程序时，两个 options 参数将合并。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageInteractor</span> </span>&#123;</span><br><span class="line">  triggerEvent = triggerable(<span class="string">'customEvent'</span>, &#123; ... &#125;);</span><br><span class="line">  triggerFooEvent = triggerable(<span class="string">'#foo'</span>, <span class="string">'customEvent'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> PageInteractor().triggerEvent();</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> PageInteractor().triggerEvent(&#123; ... &#125;);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> PageInteractor().triggerFooEvent();</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> PageInteractor().triggerFooEvent(&#123; ... &#125;);</span><br></pre></td></tr></table></figure><h3 id="Interactors"><a href="#Interactors" class="headerlink" title="Interactors"></a>Interactors</h3><p>嵌套的 interactor creators 返回范围为父 interactor 根元素的 interactor 实例。第二个参数是要添加到返回的 interactor 中的可选的参数。第二个参数也可能是一个 interactor class，在创建嵌套的，作用域的 interactor 时会使用它自己的方法和属性。</p><ol><li>scoped(selector[, properties]) 单个嵌套 interactor 的 Interactor creator。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"login-form"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">"email"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginFormInteractor</span> </span>&#123;</span><br><span class="line">  username = scope(<span class="string">'input[name="username"]'</span>);</span><br><span class="line">  email = scope(<span class="string">'input[name="email"]'</span>);</span><br><span class="line">  submit = clickable(<span class="string">'button[type="submit"]'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> LoginFormInteractor(<span class="string">'form'</span>)</span><br><span class="line">  .username.fill(<span class="string">'darklord1926'</span>)</span><br><span class="line">  .email.fill(<span class="string">'tom.riddle@hogwarts.edu'</span>)</span><br><span class="line">  .email.blur()</span><br><span class="line">  .submit();</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> LoginFormInteractor(<span class="string">'form'</span>)</span><br><span class="line">  .username.fill(<span class="string">'h4x0r'</span>)</span><br><span class="line">  .email.only().fill(<span class="string">'not@an@email'</span>)</span><br><span class="line">  .blur();</span><br></pre></td></tr></table></figure><ol start="2"><li>collection(selector[, properties]) =&gt; fn([index]) 一组嵌套 interactor 的 Interactor creator。集合 interactor 将索引作为参数，并返回作用域为该元素的 interactor。没有索引，将返回相应的 interactor 数组</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"checkboxes"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">...</span>/&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">...</span>/&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">...</span>/&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckboxGroupInteractor</span> </span>&#123;</span><br><span class="line">  items = collection(<span class="string">'input[type="checkbox"]'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> checkboxGroup</span><br><span class="line">  .items(<span class="number">0</span>).click()</span><br><span class="line">  .items(<span class="number">1</span>).click();)</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> checkboxGroup</span><br><span class="line">  .items(<span class="number">0</span>).click()</span><br><span class="line">  .items(<span class="number">1</span>).only()</span><br><span class="line">  .focus()</span><br><span class="line">  .trigger(<span class="string">'keydown'</span>, &#123; <span class="attr">which</span>: <span class="number">32</span> &#125;)</span><br></pre></td></tr></table></figure><h3 id="Helpers"><a href="#Helpers" class="headerlink" title="Helpers"></a>Helpers</h3><p>Property creator 可用于定义您自己的自定义 interactions。支持直接在 interactor class上定义 methods 和 getters。但是，使用这些帮助程序可以让您创建可重复使用的Property creator ，例如上述交互。</p><ol><li>computed(getter) 返回 Interactor Property 的 property descriptor。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">data</span>(<span class="params">key, selector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> computed(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$(selector).dataset[key];</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interactor </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageInteractor</span> </span>&#123;</span><br><span class="line">  username = data(<span class="string">'user'</span>, <span class="string">'#user-info'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>action(method) 返回一个交互方法的 property descriptor。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> action(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.click(<span class="string">`<span class="subst">$&#123;selector&#125;</span>[name="<span class="subst">$&#123;name&#125;</span>"]`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interactor </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckboxGroupInteractor</span> </span>&#123;</span><br><span class="line">  check = check(<span class="string">'input[type="checkbox"]'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> CheckboxGroupinteractor(<span class="string">'.checkboxes'</span>).check(<span class="string">'option-1'</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是 interactor 开箱即用可用的各种交互的简要说明。&lt;/p&gt;
&lt;h2 id=&quot;Default-Interactions&quot;&gt;&lt;a href=&quot;#Default-Interactions&quot; class=&quot;headerlink&quot; title=&quot;Default Inte
      
    
    </summary>
    
      <category term="bigtest" scheme="https://shleyz.github.io/categories/bigtest/"/>
    
    
      <category term="bigtest" scheme="https://shleyz.github.io/tags/bigtest/"/>
    
  </entry>
  
  <entry>
    <title>@bigtest/interactor使用</title>
    <link href="https://shleyz.github.io/2020/01/07/bigtest-interactor%E4%BD%BF%E7%94%A8/"/>
    <id>https://shleyz.github.io/2020/01/07/bigtest-interactor使用/</id>
    <published>2020-01-07T08:42:05.000Z</published>
    <updated>2020-02-28T05:44:47.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自定义-interactor"><a href="#自定义-interactor" class="headerlink" title="自定义 interactor"></a>自定义 interactor</h2><p>虽然使用默认的 Interactor 对于简单和较小的组件可能很好，但是使用类装饰器和 interactor interaction creators 很容易创建自定义 interaction。</p><p>自定义 Interactor 使我们能够将所有选择器都放在一个位置，并具有与其他 Interactor 可组合以与更多复杂结构交互的好处。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  interactor,</span><br><span class="line">  text,</span><br><span class="line">  value,</span><br><span class="line">  property,</span><br><span class="line">  fillable,</span><br><span class="line">  focusable,</span><br><span class="line">  blurrable</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@bigtest/interactor'</span>;</span><br><span class="line"></span><br><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiledInteractor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// custom properties are lazy like the default properties</span></span><br><span class="line">  label = text(<span class="string">'[data-test-label]'</span>);</span><br><span class="line">  value = value(<span class="string">'[data-test-input]'</span>);</span><br><span class="line">  type = property(<span class="string">'[data-test-input]'</span>, <span class="string">'type'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `*able` property creators create chainable interactor methods</span></span><br><span class="line">  focus = focusable(<span class="string">'[data-test-input]'</span>);</span><br><span class="line">  fill = fillable(<span class="string">'[data-test-input]'</span>);</span><br><span class="line">  blur = blurrable(<span class="string">'[data-test-input]'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的属性和方法集具有相应的 interactor creators。还有其他几个可用的 interactor creators 可供选择。</p><h2 id="自定义方法和属性"><a href="#自定义方法和属性" class="headerlink" title="自定义方法和属性"></a>自定义方法和属性</h2><p>也可以在修饰的类上直接定义其他方法和获取属性的方法。但是，请谨慎使用 property initializers 和 this，因为它会引用未修饰的类实例，而不是您可能期望的 interactor 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FieldInteractor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// methods that return new instances of itself will be chainable with other methods</span></span><br><span class="line">  fillIn(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.focus()</span><br><span class="line">      .fill(value)</span><br><span class="line">      .blur();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// using getters ensures that properties will not be invoked until necessary</span></span><br><span class="line">  <span class="keyword">get</span> isPassword() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.type === <span class="string">'password'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// the following will not work because `this` references the undecorated class</span></span><br><span class="line">  <span class="comment">// foo = () =&gt; this.doesntWork()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义-Interaction-Creators"><a href="#自定义-Interaction-Creators" class="headerlink" title="自定义 Interaction Creators"></a>自定义 Interaction Creators</h2><p>对于常用的自定义属性和方法，存在两个 helpers，可用于定义自己的可重用 interaction creators：</p><ul><li>针对属性的 computed</li><li>针对方法的 action</li></ul><p>除了默认方法外，interaction 还具有一些自己的辅助方法。</p><ol><li>this.\$(selector)</li></ol><p>使用 interaction 的根元素和 querySelector 查找嵌套元素。当找不到元素时，将引发错误。如果未定义选择器，则返回根元素。</p><ol start="2"><li>this.\$\$(selector)</li></ol><p>也使用 interaction 的根元素，但使用 querySelectorAll 并返回匹配元素的数组。仅当找不到根元素时才会引发错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">'@bigtest/interactor'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns a specific data attribute of an element</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">data</span>(<span class="params">selector, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// to align with other interaction creators, `selector` is optional</span></span><br><span class="line">  <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">    key = selector;</span><br><span class="line">    selector = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the `computed` helper creates a getter</span></span><br><span class="line">  <span class="keyword">return</span> computed(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$(selector).dataset[key];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Interactor methods: #find（selector）和#findAll（selector）的行为与上述方法相同，只是它们返回用于链式调用的新实例。找到的元素将传递到链中的下一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; action &#125; <span class="keyword">from</span> <span class="string">'@bigtest/interactor'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// triggers a keypress event for each character in a given string</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">typeable</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// the `action` helper returns an interactor method</span></span><br><span class="line">  <span class="keyword">return</span> action(<span class="function"><span class="keyword">function</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="keyword">this</span>.find(selector)</span><br><span class="line">        <span class="comment">// `#do` executes a callback within the queue</span></span><br><span class="line">        .do(<span class="function"><span class="params">$node</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> string) &#123;</span><br><span class="line">            $node.dispatchEvent(</span><br><span class="line">              <span class="keyword">new</span> Event(<span class="string">'keypress'</span>, &#123;</span><br><span class="line">                charChode: char.charCodeAt(),</span><br><span class="line">                cancelable: <span class="literal">true</span>,</span><br><span class="line">                bubbles: <span class="literal">true</span></span><br><span class="line">              &#125;)</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用自定义-interactor"><a href="#使用自定义-interactor" class="headerlink" title="使用自定义 interactor"></a>使用自定义 interactor</h2><p>可以像使用普通 interactor 一样使用自定义 interactor。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="keyword">new</span> FieldInteractor(<span class="string">'[data-test-username-field]'</span>);</span><br><span class="line"><span class="keyword">let</span> password = <span class="keyword">new</span> FieldInteractor(<span class="string">'[data-test-password-field]'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// focuses, fills, and blurs the field input</span></span><br><span class="line"><span class="keyword">await</span> username.fillIn(<span class="string">'bigtester'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// property access could trigger "element not found" errors like default properties</span></span><br><span class="line">expect(username.type).to.equal(<span class="string">'text'</span>);</span><br><span class="line">expect(password.isPassword).to.be.true;</span><br></pre></td></tr></table></figure><p>如果一个 interactor 通常只属于一个元素，则定义一个静态的 defaultScope 属性使我们不必每次都使用范围选择器初始化该 interactor。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePageInteractor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> defaultScope = <span class="string">'[data-test-home-page]'</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defaults scope to "[data-test-home-page]"</span></span><br><span class="line"><span class="keyword">let</span> homePage = <span class="keyword">new</span> HomePageInteractor();</span><br></pre></td></tr></table></figure><p>自定义 interactor 也可以通过相互嵌套来构成其他 interactor。诸如 scoped 和 collection 之类的帮助程序还允许您将一个或一组 interactor 范围限定于父 interactor 中的特定元素。</p><h2 id="Interactors-组合"><a href="#Interactors-组合" class="headerlink" title="Interactors 组合"></a>Interactors 组合</h2><p>在定义自定义 Interactors 时，可以通过组合较小的 Interactors 来创建更复杂的 Interactors。默认情况下，嵌套 Interactors 的作用域不限于其父 Interactors。这是因为在某些情况下，例如模式或弹出窗口，元素已被附加到文档的不同部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModalInteractor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignUpFormInteractor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// the default scope is used when a new instance's selector is omitted</span></span><br><span class="line">  <span class="keyword">static</span> defaultScope = <span class="string">'[data-test-sign-up-form]'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the modal element exists outside of the form</span></span><br><span class="line">  confirmation = <span class="keyword">new</span> ModalInteractor(<span class="string">'[data-test-modal]'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Scoped-Interactors-范围交互器"><a href="#Scoped-Interactors-范围交互器" class="headerlink" title="Scoped Interactors 范围交互器"></a>Scoped Interactors 范围交互器</h2><p>使用 scoped 属性创建器，您可以创建在父 Interactors 范围内的嵌套 Interactors。第二个参数允许我们完全指定其他嵌套属性或甚至另一个 Interactors 类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignUpFormInteractor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// scoped interactors look for an element within the parent element</span></span><br><span class="line">  submit = scoped(<span class="string">'[data-test-submit]'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// a hash of other properties may be provided as the second argument</span></span><br><span class="line">  email = scoped(<span class="string">'[data-test-email-field] input'</span>, &#123;</span><br><span class="line">    placeholder: property(<span class="string">'placeholder'</span>)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// using a class is preferred for maximum composability</span></span><br><span class="line">  password = scoped(<span class="string">'[data-test-password-field]'</span>, FieldInteractor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>collection 属性创建器返回一个函数，该函数接受一个索引，并将为该索引处的元素返回一个嵌套的 Interactors。就像普通的 Interactors 一样，此 Interactors 是惰性的，在交互运行或访问属性之前，它不会尝试在索引处查找元素。如果不提供任何参数，则 collection 函数将返回一个 Interactors 数组；调用时找到的每个匹配元素都会添加一个。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interactor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignUpFormInteractor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// collections also accept additional properties or a class as the second argument</span></span><br><span class="line">  interests = collection(<span class="string">'[data-test-interests-item]"]'</span>, &#123;</span><br><span class="line">    toggle: click(<span class="string">'input[type="checkbox"]'</span>),</span><br><span class="line">    label: text(<span class="string">'[data-test-label]'</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="嵌套方法和属性"><a href="#嵌套方法和属性" class="headerlink" title="嵌套方法和属性"></a>嵌套方法和属性</h2><p>嵌套的 Interactors 方法（无论是否作用域）都会返回根 Interactors 的实例以进行其他链接。嵌套属性在访问时仍会延迟计算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> signUp = <span class="keyword">new</span> SignUpFormInteractor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// `await` will immediately invoke `#run()`, we could also save a reference</span></span><br><span class="line"><span class="comment">// to this specific interaction to re-use elsewhere</span></span><br><span class="line"><span class="keyword">await</span> signUp.email</span><br><span class="line">  .fill(<span class="string">'foo@bar.baz'</span>)</span><br><span class="line">  .password.fillIn(<span class="string">'53cr3t'</span>)</span><br><span class="line">  .interests(<span class="number">3</span>)</span><br><span class="line">  .toggle()</span><br><span class="line">  .submit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// nested interactors may be broken from the parent chain using `#only()`</span></span><br><span class="line"><span class="keyword">await</span> signUp.email</span><br><span class="line">  .only()</span><br><span class="line">  .focus()</span><br><span class="line">  .fill(<span class="string">'foo@bar'</span>)</span><br><span class="line">  .blur();</span><br><span class="line"></span><br><span class="line"><span class="comment">// nested properties may throw one of a few "element not found" errors</span></span><br><span class="line">signUp.interests(<span class="number">10</span>).label;</span><br><span class="line"><span class="comment">// =&gt; Error: unable to find "[data-test-label]"</span></span><br><span class="line"><span class="comment">// =&gt; Error: unable to find "[data-test-interest-item]" at index 10</span></span><br><span class="line"><span class="comment">// =&gt; Error: unable to find "[data-test-sign-up-form]"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;自定义-interactor&quot;&gt;&lt;a href=&quot;#自定义-interactor&quot; class=&quot;headerlink&quot; title=&quot;自定义 interactor&quot;&gt;&lt;/a&gt;自定义 interactor&lt;/h2&gt;&lt;p&gt;虽然使用默认的 Interactor 对于简
      
    
    </summary>
    
      <category term="bigtest" scheme="https://shleyz.github.io/categories/bigtest/"/>
    
    
      <category term="bigtest" scheme="https://shleyz.github.io/tags/bigtest/"/>
    
  </entry>
  
  <entry>
    <title>@bigtest/interactor介绍</title>
    <link href="https://shleyz.github.io/2020/01/07/bigtest-interactor/"/>
    <id>https://shleyz.github.io/2020/01/07/bigtest-interactor/</id>
    <published>2020-01-07T08:20:57.000Z</published>
    <updated>2020-02-28T05:44:47.717Z</updated>
    
    <content type="html"><![CDATA[<p>在生物学中，interactor 被定义为自然选择所作用的有机体的一部分。 BigTest interactor 定义了要对其进行测试的应用程序的一部分。您可以将 interactor 视为现代组件的可组合页面对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; interactor &#125; <span class="keyword">from</span> <span class="string">'@bigtest/interactor'</span>;</span><br><span class="line"><span class="comment">// an interactor can be scoped directly to an element</span></span><br><span class="line"><span class="keyword">let</span> input = <span class="keyword">new</span> interactor(<span class="string">'[data-test-input]'</span>);</span><br><span class="line"><span class="keyword">let</span> submit = <span class="keyword">new</span> interactor(<span class="string">'[data-test-submit]'</span>);</span><br></pre></td></tr></table></figure><h2 id="Interactor-Properties"><a href="#Interactor-Properties" class="headerlink" title="Interactor Properties"></a>Interactor Properties</h2><p>Interactor 属性是惰性的，在访问之前不查找元素或属性。如果找不到该元素，则会引发错误。<br>这比典型的期望失败更有用，因为我们知道期望失败的原因，而不仅仅是知道期望值不正确而失败了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// when the elements do not exist in the DOM</span></span><br><span class="line">input.value; <span class="comment">//=&gt; Error: unable to find "[data-test-input]"</span></span><br><span class="line">submit.text; <span class="comment">//=&gt; Error: unable to find "[data-test-submit]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// when the elements do exist in the DOM</span></span><br><span class="line">input.value; <span class="comment">//=&gt; "foo"</span></span><br><span class="line">submit.text; <span class="comment">//=&gt; "Submit"</span></span><br></pre></td></tr></table></figure><h2 id="Immutable-Methods"><a href="#Immutable-Methods" class="headerlink" title="Immutable Methods"></a>Immutable Methods</h2><p>Interactor 是不可变的。方法返回 Interactor 的新实例，并在队列中附加一个 interaction。<br>然后您可以通过调用 #run() 方法来在 Interactor 的队列中运行所有 Interactor。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this does not actually focus the input yet</span></span><br><span class="line"><span class="keyword">let</span> focusInput = input.focus();</span><br><span class="line"></span><br><span class="line"><span class="comment">// chaining additional interactions will add to the new instance queue</span></span><br><span class="line"><span class="keyword">let</span> focusAndFill = focusInput.fill(<span class="string">'some value'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// an interactor will wait until the element exists before interacting with it</span></span><br><span class="line">focusAndFill.run()</span><br><span class="line">.then(...)  <span class="comment">// the input was succesfully focused and filled with "some value"</span></span><br><span class="line">.catch(...) <span class="comment">// something went wrong, likely the input was not found</span></span><br></pre></td></tr></table></figure><p>Interactor 也可以相互组合以产生更复杂的交互。而且由于它们是不可变的，因此可以反复使用它们。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remember, this does not actually interact with the elements yet</span></span><br><span class="line"><span class="keyword">let</span> fillInput = input</span><br><span class="line">  .focus()</span><br><span class="line">  .fill(<span class="string">'some value'</span>)</span><br><span class="line">  .blur();</span><br><span class="line"><span class="keyword">let</span> submitForm = submit.click();</span><br><span class="line"></span><br><span class="line"><span class="comment">// when this is run, it will focus, fill, and blur the input</span></span><br><span class="line"><span class="comment">// before finally clicking on the submit button</span></span><br><span class="line"><span class="keyword">let</span> fillAndSubmit = fillInput.append(submitForm);</span><br><span class="line"></span><br><span class="line"><span class="comment">// in one test...</span></span><br><span class="line">fillAndSubmit.run();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... in another</span></span><br><span class="line">fillAndSubmit.run();</span><br></pre></td></tr></table></figure><p>默认的 interaction 方法可以选择接受一个选择器作为它们的第一个参数，以便您可以与作用域内的 interaction 中的元素进行交互。</p><p>interaction 也是可异步的，它可以立即调用#run（），从而允许 interaction 使用 async/await 语法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Interactor(<span class="string">'[data-test-form]'</span>)</span><br><span class="line">  .fill(<span class="string">'[data-test-input]'</span>, <span class="string">'some value'</span>)</span><br><span class="line">  .click(<span class="string">'[data-test-submit]'</span>);</span><br></pre></td></tr></table></figure><p>有关可用的默认属性和方法，请参阅<a href="https://bigtestjs.io/guides/interactors/available-interactions/" target="_blank" rel="noopener">Available Interactions</a>。<br>您可以通过创建自定义 interaction 来覆盖或定义自己的 interaction。<br>这可以通过直接扩展 Interactor 类或使用@interactor 类装饰器和 interaction creators 来完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在生物学中，interactor 被定义为自然选择所作用的有机体的一部分。 BigTest interactor 定义了要对其进行测试的应用程序的一部分。您可以将 interactor 视为现代组件的可组合页面对象。&lt;/p&gt;
&lt;figure class=&quot;highlight
      
    
    </summary>
    
      <category term="bigtest" scheme="https://shleyz.github.io/categories/bigtest/"/>
    
    
      <category term="bigtest" scheme="https://shleyz.github.io/tags/bigtest/"/>
    
  </entry>
  
  <entry>
    <title>@bigtest使用</title>
    <link href="https://shleyz.github.io/2020/01/07/bigtest%E4%BD%BF%E7%94%A8/"/>
    <id>https://shleyz.github.io/2020/01/07/bigtest使用/</id>
    <published>2020-01-07T07:44:08.000Z</published>
    <updated>2020-02-28T05:44:47.718Z</updated>
    
    <content type="html"><![CDATA[<p>假设您的应用程序正在使用以下技术：</p><ul><li>React</li><li>Mocha</li><li>Webpack or Parcel</li></ul><h2 id="Installing-Dependencies"><a href="#Installing-Dependencies" class="headerlink" title="Installing Dependencies"></a>Installing Dependencies</h2><p>首先，安装 BigTest 所需的软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev @bigtest/cli @bigtest/interactor @bigtest/react</span><br></pre></td></tr></table></figure><ul><li>@bigtest/cli 将使你能够访问文章内使用的 bigtest 命令。</li><li>@bigtest/interactor 允许您的测试以类似人与应用交互的方式与应用进行交互。 他们将等待元素出现，然后再与他们进行交互，这意味着您不必担心正确地安排测试时间以与任何运行循环同步。 （谁还有时间这样做？）</li><li>@bigtest/react：React DOM helper，用于设置您的应用程序以进行验收测试。</li></ul><h2 id="初始化-BigTest"><a href="#初始化-BigTest" class="headerlink" title="初始化 BigTest"></a>初始化 BigTest</h2><p>现在已经安装了所有依赖项，然后转到项目根目录并运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx bigtest init</span><br></pre></td></tr></table></figure><p>这将创建一个新的 bigtest 目录：</p><p>bigtest/<br>├── bigtest.opts<br>├── index.js<br>├── helpers/<br>│ └── setup-app.js<br>├── interactors/<br>│ └── app.js<br>└── tests/<br>└── app-test.js</p><h2 id="导入你的应用"><a href="#导入你的应用" class="headerlink" title="导入你的应用"></a>导入你的应用</h2><p>您需要将应用程序根组件导入到 bigtest/helpers/setup-app.js 文件中。<br>导入根组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; setupAppForTesting &#125; <span class="keyword">from</span> <span class="string">'@bigtest/react'</span>;</span><br><span class="line"><span class="keyword">import</span> YourApp <span class="keyword">from</span> <span class="string">'../../src/YourApp'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">setupApplicationForTesting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> setupAppForTesting(YourApp, () =&gt; &#123;</span><br><span class="line">    mountId: <span class="string">'bigtesting-container'</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动和服务"><a href="#启动和服务" class="headerlink" title="启动和服务"></a>启动和服务</h2><p>BigTest 通过将您的应用程序与您编写的测试文件捆绑在一起来工作。<br>创建的所有测试都需要导入到 bigtest/index.js。<br>您需要通过将捆绑器的入口点更改为 bigtest/index.js 来告诉捆绑器如何将测试与应用捆绑在一起。</p><p>bigtest CLI 会设置 NODE_ENV 为您测试。以 Webpack 为例，您可以检查 NODE_ENV 是否等于 test 并根据需要更改入口点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in your webpack.config.js</span></span><br><span class="line"><span class="keyword">let</span> isTesting = process.env.NODE_ENV === <span class="string">'test'</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: isTesting ? <span class="string">'.bigtest/index.js'</span> : <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bigtest-run"><a href="#bigtest-run" class="headerlink" title="bigtest run"></a>bigtest run</h3><p>bigtest run 处理启动不同的浏览器并实际运行测试的过程。将脚本添加到 package.json：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "test": "bigtest run"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们使用的是 package.json 中指定的@bigtest/cli 项目版本，而不是全局安装。</p><h3 id="bigtest-opts"><a href="#bigtest-opts" class="headerlink" title="bigtest.opts"></a>bigtest.opts</h3><p>bigtest.opts 文件使启动器（bigtest 运行）知道：</p><ul><li>如何启动您的应用服务器（–serve）</li><li>应用服务的位置（–serve-url）</li><li>您正在使用什么测试框架（–adapter），目前最大的启动器仅适用于 mocha，但我们正在努力添加更多的适配器。</li></ul><p>bigtest.opts 文件是一个配置文件，其中包含可以作为标志传递给 BigTest CLI 的各种选项。从 CLI 传递的参数优先于 opts 文件中指定的参数。</p><p>bigtest.opts 应该看起来像这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--serve <span class="string">"yarn start"</span></span><br><span class="line">--serve-url <span class="string">"http://localhost:3000"</span></span><br><span class="line">--adapter mocha</span><br></pre></td></tr></table></figure><h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>现在，所有内容都已设置好，可以通过运行我们之前设置的测试命令进行检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn <span class="built_in">test</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设您的应用程序正在使用以下技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React&lt;/li&gt;
&lt;li&gt;Mocha&lt;/li&gt;
&lt;li&gt;Webpack or Parcel&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Installing-Dependencies&quot;&gt;&lt;a href=&quot;#Inst
      
    
    </summary>
    
      <category term="bigtest" scheme="https://shleyz.github.io/categories/bigtest/"/>
    
    
      <category term="bigtest" scheme="https://shleyz.github.io/tags/bigtest/"/>
    
  </entry>
  
  <entry>
    <title>@bigtest介绍</title>
    <link href="https://shleyz.github.io/2020/01/07/bigtest/"/>
    <id>https://shleyz.github.io/2020/01/07/bigtest/</id>
    <published>2020-01-07T06:40:06.000Z</published>
    <updated>2020-02-28T05:44:47.718Z</updated>
    
    <content type="html"><![CDATA[<p>知道应用程序是否正常运行的最可靠方法是实际运行它。大型测试会在每个测试用例之前启动整个应用程序。</p><p>您的应用程序是否在浏览器中运行？然后，如果测试要衡量其是否有效，它还需要在真实用户可能使用的真实浏览器中运行，并且应该针对真实 DOM 分配真实的 UI 事件。</p><p>进行大型测试很困难，因为在您的应用程序中可能同时发生数百甚至数千个事情。包括用户互动。</p><p>BigTest 是一个旨在简化和快速接受所有单页应用程序（SPA）的框架，无论框架或库如何。</p><p>当我们在网络上构建应用时，我们希望能够在接近用户的地方对其进行测试。</p><p>真实用户将使用真实的浏览器来访问你的应用；那么测试是否是在真实的浏览器中进行的呢？<br>并非每个人都使用相同的浏览器，那么测试是否可以在多个不同的浏览器和设备上进行呢？<br>网络呢？您的应用可能会与网络进行对话，而您的测试也应该考虑到这一点，对吧？<br>更不用说一个人不会在组件级别上与您的应用进行交互。<br>他们正在一起使用整个应用程序。 您的所有组件相互协作以创造一种体验。</p><p>如果测试无法以与人使用应用程序相同的方式测试应用程序，那么你会对自己的 app 有信心吗？</p><p>在开始寻找最适合 SPA 的测试工具时，我们有一些要求：</p><ul><li>快速</li><li>构建组件（包括可组合的组件）</li><li>跨浏览器（Firefox，IE，Safari 等</li><li>跨设备（Windows，macOS，iOS，Android 等）</li><li>跨框架（React，Vue，Ember，Angular 等）</li><li>跨测试框架（Mocha，Jasmine 等）</li></ul><p>目前已经有类似的工具，如 Jest，但是这些测试无法在真正的浏览器中运行。还有赛普拉斯（Cypress），但截至本文撰写之时，您目前无法在 Chrome 之外使用它（其他不久将通过 webdriver 推出），并且还没有在组件中进行编写。</p><p>下面的对比：</p><table><thead><tr><th>Test Framework</th><th>Fast</th><th>Cross Browser</th><th>Cross Device</th><th>Cross Test Runner</th><th>Cross Framework</th><th>Composable</th></tr></thead><tbody><tr><td>BigTest</td><td>🏎</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>Cypress</td><td>🚗</td><td>❌</td><td>❌</td><td>❌</td><td>✅</td><td>❌</td></tr><tr><td>Selenium</td><td>🚌</td><td>✅</td><td>❌</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>Jest</td><td>🏎</td><td>❌</td><td>❌</td><td>❌</td><td>✅</td><td>❌</td></tr></tbody></table><p>大多数现有框架都选中了其中一些（或部分选中了它们），但不是全部。<br>随着移动浏览在当今世界变得如此普遍，我们需要一种可以轻松地在我们手边的任何设备上运行测试（通过访问 URL）的工具。</p><h2 id="测试理念"><a href="#测试理念" class="headerlink" title="测试理念"></a>测试理念</h2><p>使用 BigTest 编写测试时，务必像用户将使用您的应用程序一样编写测试。<br>当某人与您的应用进行交互时，他们使用的鼠标和键盘将转换为您的应用响应的浏览器事件。<br>他们正在点击事物，期望取得成果。 这也是我们应用程序的测试所要做的：发送浏览器事件并断言有反馈。<br>我们都知道存在跨浏览器的错误！</p><p>如果是要访问组件或控制状态的测试，那不是适当的 BigTest。 所有互动都应来自用户群。<br>需要注意的另一件事是，确保您断言的是用户在应用中看到或交互的状态。</p><p>目的是进行交互，并观察由交互引发的页面上的正确变更。</p><h2 id="BigTest-如何运作？"><a href="#BigTest-如何运作？" class="headerlink" title="BigTest 如何运作？"></a>BigTest 如何运作？</h2><p>BigTest 会将您的应用程序安装并呈现到浏览器中。然后将执行您编写的测试。<br>Interactor 驱动应用程序，它位于浏览器内部，带有 tests 和 render 的应用程序。<br>这是 BigTest 与其他测试框架之间的主要区别，BigTest 没有控制浏览器的单独过程。</p><p>这就是为什么您只需访问 URL 即可运行 BigTests 的原因。</p><p>在高层的 BigTest 中：</p><ul><li>启动您的应用程序服务器（捆绑测试和应用程序）</li><li>启动浏览器</li><li>开始运行测试运行器</li><li>Interactor 驱动应用程序（单击此处，访问路由等）</li><li>结果报告回 CLI</li></ul><h2 id="组成-BigTest-的软件包"><a href="#组成-BigTest-的软件包" class="headerlink" title="组成 BigTest 的软件包"></a>组成 BigTest 的软件包</h2><p>BigTest 框架由几个小程序包组成，这些程序包也可以单独使用。了解这些软件包及其在 BigTest 框架中的作用是有帮助的。</p><h3 id="Convergence"><a href="#Convergence" class="headerlink" title="Convergence"></a>Convergence</h3><p><a href="https://bigtestjs.io/docs/convergence/" target="_blank" rel="noopener">Convergence</a> 是不可变，可重用和可组合的断言，使您可以立即知道何时达到期望的状态。<br>简而言之：它每 10 毫秒检查一次 DOM（默认情况下为 2 秒），以查看您要检查的状态是否存在。</p><p>Convergence 是 BigTest 中所有事物的基础。这就是使 interactors 可靠的原因。<br>CLI 中甚至将 Convergence 用于等待浏览器连接状态。</p><h3 id="Interactor"><a href="#Interactor" class="headerlink" title="Interactor"></a>Interactor</h3><p>在生物学中， interactor 被定义为自然选择所作用的有机体的一部分。<br>BigTest interactor 定义了要对其进行测试的应用程序的一部分。<br>您可以将 interactor 视为现代组件的可组合页面对象。</p><p>interactor 是 BigTest 的灵魂，简而言之，我们将应用程序呈现到浏览器中，而交互器将其驱动。<br>他们使用 Convergence 来确保元素存在并且可以在执行所需的交互之前与之交互。</p><p>interactor 还与您使用现代组件获得的可组合性相匹配。这意味着您可以以类似于编写 UI 的方式来编写测试。</p><p>要了解有关 interactor 的更多信息，请务必查看<a href="https://bigtestjs.io/guides/interactors/introduction" target="_blank" rel="noopener">interactor guides</a>。</p><h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><p>BigTest CLI 旨在简化 SPA 中的验收测试设置（例如 setup，build tool integration 和浏览器启动）</p><p>您可以将 CLI 视为 Karma 或 Testem，但更易于设置并包含其他可与 BigTest 框架配合使用的有用 CLI 命令（例如 bigtest init）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;知道应用程序是否正常运行的最可靠方法是实际运行它。大型测试会在每个测试用例之前启动整个应用程序。&lt;/p&gt;
&lt;p&gt;您的应用程序是否在浏览器中运行？然后，如果测试要衡量其是否有效，它还需要在真实用户可能使用的真实浏览器中运行，并且应该针对真实 DOM 分配真实的 UI 事件。&lt;
      
    
    </summary>
    
      <category term="bigtest" scheme="https://shleyz.github.io/categories/bigtest/"/>
    
    
      <category term="bigtest" scheme="https://shleyz.github.io/tags/bigtest/"/>
    
  </entry>
  
  <entry>
    <title>LRU 缓存淘汰算法</title>
    <link href="https://shleyz.github.io/2019/12/19/LRU-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/"/>
    <id>https://shleyz.github.io/2019/12/19/LRU-缓存淘汰算法/</id>
    <published>2019-12-19T09:02:43.000Z</published>
    <updated>2020-02-28T05:44:47.714Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在移动端避免使用100vh</title>
    <link href="https://shleyz.github.io/2019/12/06/%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8100vh/"/>
    <id>https://shleyz.github.io/2019/12/06/在移动端避免使用100vh/</id>
    <published>2019-12-06T02:21:55.000Z</published>
    <updated>2020-02-28T05:44:47.743Z</updated>
    
    <content type="html"><![CDATA[<p>CSS中如果要设置元素的样式占据整个屏幕的高度，则可以设置height: 100vh。这样可以实现根据屏幕的高度而改变元素的高度，可以填充整个屏幕。</p><p>然而在实际中并非如此，100vh实现的功能在移动设备的浏览器中基本被破坏，使它基本没用。</p><p>核心原因就在于移动设备的浏览器中的地址栏，有时可见，有时隐藏，从而导致改变了视口的可见大小。<br>但浏览器的可见高度改变时，并不是把可见高度的部分自适应为100vh，反而是：这些浏览器将100vh设置为浏览器的高度，地址栏隐藏。导致的结果是，当地址栏可见时，屏幕的底部将被切断，从而从一开始就破坏了100vh的目的。</p><p>如下所示： </p><p><img src="http://ww1.sinaimg.cn/large/8c85763dly1g9msvf5xayj20qo0k0q3b.jpg" alt="移动端100vh"></p><p>当地址栏可见时，屏幕底部被切断，因为移动浏览器错误的将100vh设置为屏幕的高度，因此没有显示地址栏。在上图，本应该在屏幕底部被显示的按钮被隐藏了。</p><p>更糟糕的是，当用户第一次访问移动网站时，地址栏将显示在顶部，因此默认体验到的时错误的体验。</p><h2 id="更好的解决方案：window-innerhight"><a href="#更好的解决方案：window-innerhight" class="headerlink" title="更好的解决方案：window.innerhight"></a>更好的解决方案：window.innerhight</h2><p>解决此问题的一种方法是依靠javascript而不是CSS。页面加载时，将高度设置为window.innerHeight，这样可以正确的将高度设置为视口的高度。如果地址栏可见，window.innerHeight则将是全屏的高度。如果地址栏是隐藏的，window.innerHeight则将是屏幕上可见部分的高度，这正是我们所期望的。</p><p>遗憾的是，在不依赖JavaScript的情况下，仍然没有一种简单的方法来使元素占据整个视口高度。height: 100vh是如此接近的伟大，但给它在移动端浏览器上有局限性，最好避免这样使用它。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CSS中如果要设置元素的样式占据整个屏幕的高度，则可以设置height: 100vh。这样可以实现根据屏幕的高度而改变元素的高度，可以填充整个屏幕。&lt;/p&gt;
&lt;p&gt;然而在实际中并非如此，100vh实现的功能在移动设备的浏览器中基本被破坏，使它基本没用。&lt;/p&gt;
&lt;p&gt;核心原
      
    
    </summary>
    
      <category term="css" scheme="https://shleyz.github.io/categories/css/"/>
    
    
      <category term="移动端开发" scheme="https://shleyz.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>display:flex和position:absolute/fixed一起用产生的问题</title>
    <link href="https://shleyz.github.io/2019/11/26/display%EF%BC%9Aflex%E5%92%8Cposition-absolute-fixed/"/>
    <id>https://shleyz.github.io/2019/11/26/display：flex和position-absolute-fixed/</id>
    <published>2019-11-26T05:40:09.000Z</published>
    <updated>2020-02-28T05:44:47.719Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中遇到这样的问题</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.layout</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.layout</span> <span class="selector-class">.block1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">12em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.layout</span> <span class="selector-class">.block2</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现 layout 下面的 block2 并不是占用 block1 剩余的空间的，flex 布局没有生效</p><p>所以，被绝对定位与固定定位的盒子不参与 flex 布局。</p><p>解决办法，可以在要 flex 布局的盒子外面套一层盒子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.layout</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.layout</span> <span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.layout</span> <span class="selector-class">.container</span> <span class="selector-class">.block1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">12em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.layout</span> <span class="selector-class">.container</span> <span class="selector-class">.block2</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完美解决问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在开发中遇到这样的问题&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/spa
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>将callback转换为Promise</title>
    <link href="https://shleyz.github.io/2019/11/08/%E5%B0%86callback%E8%BD%AC%E6%8D%A2%E4%B8%BAPromise/"/>
    <id>https://shleyz.github.io/2019/11/08/将callback转换为Promise/</id>
    <published>2019-11-08T12:02:02.000Z</published>
    <updated>2020-02-28T05:44:47.744Z</updated>
    
    <content type="html"><![CDATA[<p>与回调函数相比，使用 Promises（或 Async / await）更容易。 在基于 Node 的环境中工作时尤其如此。 不幸的是，大多数 Node API 都是使用回调编写的。</p><p>下面，我们来看看如何将回调转换成 Promise 。</p><p>在这之前我们需要详细了解 <a href="https://zellwk.com/blog/js-promises/" target="_blank" rel="noopener">Promise</a></p><h2 id="将-Node-样式的回调转换为-Promise"><a href="#将-Node-样式的回调转换为-Promise" class="headerlink" title="将 Node 样式的回调转换为 Promise"></a>将 Node 样式的回调转换为 Promise</h2><p>Node API 的回调具有相同的模式。 它们作为最后一个参数传递给函数。</p><p>这是 fs.readFile 的示例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(filePath, options, callback);</span><br></pre></td></tr></table></figure><p>另外，每个回调至少包含两个参数。 第一个参数必须是一个错误对象 err。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'some-file'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// Handle Error</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Handle Data</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果遇到这种模式的回调，则可以使用 Node 的 util.promisify 将其转换为 Promise。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFilePromise = util.promisify(fs.readFile);</span><br></pre></td></tr></table></figure><p>将回调转换为 Promise 后，便可以像使用其他 Promise 一样使用它:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">readFilePromise(filePath, options)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Handle Data</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Handle Error</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>有时，您可能会遇到不符合 Node 的错误优先回调格式的 API。 对于这些情况，您不能使用 util.promisify。 您需要写下自己的 Promise。</p><h3 id="来写自己的-Promise"><a href="#来写自己的-Promise" class="headerlink" title="来写自己的 Promise:"></a>来写自己的 Promise:</h3><p>要将回调转换为 Promise，需要返回 Promise。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readFilePromise = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你可以在 promise 中使用回调运行代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readFilePromise = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filePath, options, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果有错误，reject。 这使用户可以处理 catch 中的错误。</p><p>如果没有错误，resolve。 这使用户可以决定接下来要做什么。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readFilePromise = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filePath, options, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来，您需要为 promise 中的代码提供诸如 filePath 之类的参数和选项。</p><p>为此，您可以使用 rest 和 spread 运算符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readFilePromise = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(...args, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，你就可以将 readFilePromise 用作 Promise。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readFilePromise(filePath, options)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><h2 id="将非-Node-样式的回调转换为-Promise"><a href="#将非-Node-样式的回调转换为-Promise" class="headerlink" title="将非 Node 样式的回调转换为 Promise"></a>将非 Node 样式的回调转换为 Promise</h2><p>一旦你知道如何构造 Promise，就可以轻松地将非 Node 样式的回调转换为 Promise。 它们遵循相同的步骤：</p><p>如果有错误则 reject<br>否则 resolve</p><p>假设您有一个 API，该 API 返回数据作为第一个参数，而 err 作为第二个参数。 我们是这样做的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shootPeasPromise = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这不是一个 Node 样式的回调（），这里回调的第一个参数不是 err</span></span><br><span class="line">    shootPeas(...args, (data, err) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="多个参数的回调"><a href="#多个参数的回调" class="headerlink" title="多个参数的回调"></a>多个参数的回调</h2><p>假设你有一个包含三个参数的回调：</p><p>错误对象 err<br>一些数据 location<br>另一条数据 size</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grewTrees(oprions, (err, location, size) =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p>我们不能这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样做是不对的, 因为 Promise 只返回一个参数</span></span><br><span class="line"><span class="keyword">const</span> growTreesPromise = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    growTrees(...args, (err, location, size) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(location, size);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果想要 Promise 返回多个参数，可以返回一个数组或对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回数组</span></span><br><span class="line">resolve([location, size]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象</span></span><br><span class="line">resolve(&#123; location, size &#125;);</span><br></pre></td></tr></table></figure><p>然后，您可以在 then 调用中解构数组或对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">growTreesPromise(options)</span><br><span class="line">  .then(<span class="function">(<span class="params">[location, size]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 解构处理数组</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line">growTreesPromise(options)</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123; location, size &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 解构处理对象</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>文章参考自 <a href="https://zellwk.com/blog/converting-callbacks-to-promises/" target="_blank" rel="noopener">zellwk</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;与回调函数相比，使用 Promises（或 Async / await）更容易。 在基于 Node 的环境中工作时尤其如此。 不幸的是，大多数 Node API 都是使用回调编写的。&lt;/p&gt;
&lt;p&gt;下面，我们来看看如何将回调转换成 Promise 。&lt;/p&gt;
&lt;p&gt;在这之前
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://shleyz.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>stripes 问题汇总</title>
    <link href="https://shleyz.github.io/2019/10/31/stripes-%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>https://shleyz.github.io/2019/10/31/stripes-问题汇总/</id>
    <published>2019-10-31T01:01:35.000Z</published>
    <updated>2020-02-28T05:44:47.739Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>自定义的组件库需要放在@folio 文件夹下面</p></li><li><p>platform-complete 里面的 stripes 版本必须大于各个模块的 stripes 版本</p></li><li><p>启动或者打包报内存溢出的问题，启动或者打包的时候需要添加参数–max-old-space-size</p></li><li><p>自定义组件的国际化语言包找不到的问题：</p><p>自定义组件的包名以 stripes 开头，要和 package.json 里面的包名一致，也要和 tranlations 文件夹下面的文件夹名称一致。<br>在 local 启动的时候单个模块需要额外配置 stripes.config.js.local 和.stripesclirc 以使得 stripes-core 模块内部能够找到语言包。</p></li></ol><p>文件 stripes.config.js.local 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  okapi: &#123;</span><br><span class="line">    url: <span class="string">'https://folio-testing-okapi.aws.indexdata.com'</span>,</span><br><span class="line">    tenant: <span class="string">'diku'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  config: &#123;</span><br><span class="line">    logCategories: <span class="string">'core,path,action,xhr'</span>,</span><br><span class="line">    logPrefix: <span class="string">'--'</span>,</span><br><span class="line">    showPerms: <span class="literal">false</span>,</span><br><span class="line">    hasAllPerms: <span class="literal">false</span>,</span><br><span class="line">    languages: [<span class="string">'en'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">    <span class="string">'@folio/stripes-your-components'</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">'@folio/users'</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>文件 .stripesclirc 如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"configFile"</span>: <span class="string">"stripes.config.js.local"</span>,</span><br><span class="line">  <span class="attr">"port"</span>: <span class="number">3000</span>,</span><br><span class="line">  <span class="attr">"aliases"</span>: &#123;</span><br><span class="line">    <span class="attr">"@folio/stripes-smart-components-jt"</span>: <span class="string">"../@folio/stripes-your-components"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>svgo 报错：</li></ol><p>方法一： 可以在 package.json 锁定， “svgo”: “1.3.0”</p><p>方法二： svgo 1.3.2 已经发布，应该也可以解决该问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;自定义的组件库需要放在@folio 文件夹下面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;platform-complete 里面的 stripes 版本必须大于各个模块的 stripes 版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动或者打包报内存溢出的问题，启动
      
    
    </summary>
    
    
      <category term="FOLIO" scheme="https://shleyz.github.io/tags/FOLIO/"/>
    
  </entry>
  
  <entry>
    <title>webpack构建多页面打包</title>
    <link href="https://shleyz.github.io/2019/10/17/webpack%E6%9E%84%E5%BB%BA%E5%A4%9A%E9%A1%B5%E9%9D%A2%E6%89%93%E5%8C%85/"/>
    <id>https://shleyz.github.io/2019/10/17/webpack构建多页面打包/</id>
    <published>2019-10-17T11:02:14.000Z</published>
    <updated>2020-04-02T06:51:44.588Z</updated>
    
    <content type="html"><![CDATA[<p>极客时间版权所有: <a href="https://time.geekbang.org/dailylesson/detail/100028427" target="_blank" rel="noopener">https://time.geekbang.org/dailylesson/detail/100028427</a></p><p>我们通常说的多页面应用，就是由多个完整页面构成的，它的优势是首屏时间快，SEO 效果好。<br>多页面应用特别常见，因此针对多页面应用提供一个通用的 webpack 打包方案，就显得很重要了。</p><p>实现多页面应用的核心就是 webpack 多个 entry 配置</p><p>但是如果我们总是去操作 webpack 来添加删除 entry 就会不是很方便，那么怎样实现不把多个 entry 值暴露给开发者，而是自动配置呢。</p><p>那就是设置一个合理的 entry 匹配规则，让 webpack 的 entry 的值自动计算出来。<br>还有一个关键点就是 html-webpack-plugin 的数量，多个页面就会需要多个数量的 html-webpack-plugin（根据 HTML 模版自动生成 HTML 页面,同时会把 js 和 css 注入进去）</p><p>总结起来就是：</p><blockquote><ol><li>设置一个合理的 entry 匹配规则</li><li>自动计算 entry 值</li><li>根据 entry 的 key 值增加对应的 html-webpack-plugin</li></ol></blockquote><p>首先我们要规范目录结构，可以用脚手架，也可以自定义，如下</p><p>.</p><p>├── node_modules<br>├── src<br>│     ├── pages<br>│         ├── page1<br>│         │      ├── index.js<br>│         │      └── index.html<br>│         ├── page2<br>│         │      ├── index.js<br>│         │      └── index.html<br>│         │<br>│         └── page3<br>│                ├── index.js<br>│                └── index.html<br>├── package-lock.json<br>├── package.json<br>└── webpack.config.js</p><p>这样我们只要找出 src/pages 下面的文件夹</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;极客时间版权所有: &lt;a href=&quot;https://time.geekbang.org/dailylesson/detail/100028427&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://time.geekbang.org/daily
      
    
    </summary>
    
      <category term="webpack" scheme="https://shleyz.github.io/categories/webpack/"/>
    
    
  </entry>
  
  <entry>
    <title>package.json 中的 Peer Dependencies</title>
    <link href="https://shleyz.github.io/2019/10/17/package-json%E4%B8%AD%E7%9A%84peerDependencies/"/>
    <id>https://shleyz.github.io/2019/10/17/package-json中的peerDependencies/</id>
    <published>2019-10-17T00:55:36.000Z</published>
    <updated>2020-02-28T05:44:47.732Z</updated>
    
    <content type="html"><![CDATA[<p>假设我们当前的项目是 MyProject，项目中有一些依赖，比方其中有一个依赖包 PackageA，该包的 package.json 文件指定了对 PackageB 的依赖：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"PackageB"</span>: <span class="string">"1.0.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们在我们的 MyProject 项目中执行 npm install PackageA, 我们会发现我们项目的目录结构会是如下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyProject</span><br><span class="line">└──┬─ node_modules</span><br><span class="line">   └──┬─ PackageA</span><br><span class="line">      └──┬─ node_modules</span><br><span class="line">         └── PackageB</span><br></pre></td></tr></table></figure><p>那么在我们的项目中，我们能通过下面语句引入”PackageA”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> packageA = <span class="built_in">require</span>(<span class="string">'PackageA'</span>);</span><br></pre></td></tr></table></figure><p>但是，如果你想在项目中直接引用 PackageB:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> packageA = <span class="built_in">require</span>(<span class="string">'PackageA'</span>);</span><br><span class="line"><span class="keyword">var</span> packageB = <span class="built_in">require</span>(<span class="string">'PackageB'</span>);</span><br></pre></td></tr></table></figure><p>这是不行的，即使 PackageB 被安装过；因为 Node 只会在“MyProject/node_modules”目录下查找 PackageB，它不会在进入 PackageA 模块下的 node_modules 下查找。<br>所以，为了解决这个问题，在 MyProject 项目 package.json 中我们必须直接声明对 PackageB 的依赖并安装。</p><p>但是，有时我们不用在当前项目中声明对 PackageB 的依赖就可以直接引用，尤其是，PackageA 是一个类似于 grunt 的插件，例如 grunt-contrib-jshint。</p><p>为什么在项目中不用声明就可以直接使用呢？这就不得不说说 peerDependencies 的作用了。</p><h3 id="peerDependencies-的引入"><a href="#peerDependencies-的引入" class="headerlink" title="peerDependencies 的引入"></a>peerDependencies 的引入</h3><p>为了解决这种问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果你安装我，那么你最好也安装X,Y和Z.</span><br></pre></td></tr></table></figure><p>于是 peerDependencies 就被引入了。例如上面 PackageA 的 package.json 文件如果是下面这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"peerDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"PackageB"</span>: <span class="string">"1.0.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，它会告诉 npm：如果某个 package 把我列为依赖的话，那么那个 package 也必需应该有对 PackageB 的依赖。</p><p>也就是说，如果你 npm install PackageA，你将会得到下面的如下的目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyProject</span><br><span class="line">└─┬─node_modules</span><br><span class="line">  ├─ PackageA</span><br><span class="line">  └─ PackageB</span><br></pre></td></tr></table></figure><p>你可能注意到：</p><blockquote><p>在 npm2 中，即使当前项目 MyProject 中没有直接依赖 PackageB，该 PackageB 包依然会安装到当前项目的 node_modules 文件夹中。</p></blockquote><p>下面的代码现在可以正常工作了，因为两个包在”MyProject/node_modules”中被安装了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> packageA = <span class="built_in">require</span>(<span class="string">'PackageA'</span>);</span><br><span class="line"><span class="keyword">var</span> packageB = <span class="built_in">require</span>(<span class="string">'PackageB'</span>);</span><br></pre></td></tr></table></figure><p>总结一句话，peerDependencies 的具体作用：</p><p>peerDependencies 的目的是提示宿主环境去安装满足插件 peerDependencies 所指定依赖的包，然后在插件 import 或者 require 所依赖的包的时候，永远都是引用宿主环境统一安装的 npm 包，最终解决插件与所依赖包不一致的问题。</p><p>举个例子，就拿目前基于 react 的 ui 组件库 <a href="mailto:ant-design@3.x" target="_blank" rel="noopener">ant-design@3.x</a> 来说，因该 ui 组件库只是提供一套 react 组件库，它要求宿主环境需要安装指定的 react 版本。具体可以看它 package.json 中的配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"peerDependencies": &#123;</span><br><span class="line">  "react": "&gt;=16.0.0",</span><br><span class="line">  "react-dom": "&gt;=16.0.0"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它要求宿主环境安装 react@&gt;=16.0.0 和 react-dom@&gt;=16.0.0 的版本，而在每个 antd 组件的定义文件顶部：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br></pre></td></tr></table></figure><p>组件中引入的 react 和 react-dom 包其实都是宿主环境提供的依赖包。</p><p><a href="https://www.cnblogs.com/wonyun/p/9692476.html" target="_blank" rel="noopener">文章来源</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设我们当前的项目是 MyProject，项目中有一些依赖，比方其中有一个依赖包 PackageA，该包的 package.json 文件指定了对 PackageB 的依赖：&lt;/p&gt;
&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="webpack" scheme="https://shleyz.github.io/categories/webpack/"/>
    
    
      <category term="webpack" scheme="https://shleyz.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>05 索引：下</title>
    <link href="https://shleyz.github.io/2019/10/10/05-%E7%B4%A2%E5%BC%95%EF%BC%9A%E4%B8%8B/"/>
    <id>https://shleyz.github.io/2019/10/10/05-索引：下/</id>
    <published>2019-10-10T09:15:42.000Z</published>
    <updated>2020-02-28T05:44:47.710Z</updated>
    
    <content type="html"><![CDATA[<p>在开始这篇文章之前，我们先来看一下这个问题：</p><p>在下面这个表 T 中，如果我执行 select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？下面是这个表的初始化语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0, </span><br><span class="line">s varchar(16) NOT NULL DEFAULT '',</span><br><span class="line">index k(k))</span><br><span class="line">engine=InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">1</span>, <span class="string">'aa'</span>),(<span class="number">200</span>,<span class="number">2</span>,<span class="string">'bb'</span>),(<span class="number">300</span>,<span class="number">3</span>,<span class="string">'cc'</span>),(<span class="number">500</span>,<span class="number">5</span>,<span class="string">'ee'</span>),(<span class="number">600</span>,<span class="number">6</span>,<span class="string">'ff'</span>),(<span class="number">700</span>,<span class="number">7</span>,<span class="string">'gg'</span>);</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/8c85763dgy1ga25oaimrxj20vq0nsn1h.jpg" alt="InnoDB 的索引组织结构"></p><p>现在，我们一起来看看这条 SQL 查询语句的执行流程：</p><ol><li>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</li><li>再到 ID 索引树查到 ID=300 对应的 R3；</li><li>在 k 索引树取下一个值 k=5，取得 ID=500；</li><li>再回到 ID 索引树查到 ID=500 对应的 R4；</li><li>在 k 索引树取下一个值 k=6，不满足条件，循环结束。</li></ol><p>在这个过程中，<strong>回到主键索引树搜索的过程，我们称为回表</strong>。可以看到，这个查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。</p><p>在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果执行的语句是 select <strong>ID</strong> from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p><p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p><p>需要注意的是，在引擎内部使用覆盖索引在索引 k 上其实读了三个记录，R3~R5（对应的索引 k 上的记录项），但是对于 MySQL 的 Server 层来说，它就是找引擎拿到了两条记录，因此 MySQL 认为扫描行数是 2。</p><p>基于上面覆盖索引的说明，我们来讨论一个问题：在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？</p><p>假设这个市民表的定义是这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tuser`</span> ( <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="string">`id_card`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>, <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>, <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>, <span class="string">`ismale`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>, PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>), <span class="keyword">KEY</span> <span class="string">`id_card`</span> (<span class="string">`id_card`</span>), <span class="keyword">KEY</span> <span class="string">`name_age`</span> (<span class="string">`name`</span>,<span class="string">`age`</span>)) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br></pre></td></tr></table></figure><p>我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？</p><p>如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在开始这篇文章之前，我们先来看一下这个问题：&lt;/p&gt;
&lt;p&gt;在下面这个表 T 中，如果我执行 select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？下面是这个表的初始化语句。&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
      <category term="MySQL" scheme="https://shleyz.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://shleyz.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>04 索引：上</title>
    <link href="https://shleyz.github.io/2019/10/09/04-%E7%B4%A2%E5%BC%95%EF%BC%9A%E4%B8%8A/"/>
    <id>https://shleyz.github.io/2019/10/09/04-索引：上/</id>
    <published>2019-10-09T04:51:42.000Z</published>
    <updated>2020-02-28T05:44:47.710Z</updated>
    
    <content type="html"><![CDATA[<p>提到数据库索引，我想你并不陌生，在日常工作中会经常接触到。比如某一个 SQL 查询比较慢，分析完原因之后，你可能就会说“给某个字段加个索引吧”之类的解决方案。但到底什么是索引，索引又是如何工作的呢？今天就让我们一起来聊聊这个话题吧。</p><p>一句话简单来说，<strong>索引的出现其实就是为了提高数据查询的效率</strong>，就像书的目录一样。一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。</p><h2 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h2><p>索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，这里我先给你介绍三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。</p><p>下面我主要从使用的角度，为你简单分析一下这三种模型的区别。</p><h3 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h3><p>哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。</p><p>不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。</p><p>假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：</p><p><img src="http://ww1.sinaimg.cn/large/8c85763dly1g9qdqa4152j20vq0nsq8o.jpg" alt="哈希表"></p><p>图中，User2 和 User4 根据身份证号算出来的值都是 N，但没关系，后面还跟了一个链表。假设，这时候你要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。</p><p>需要注意的是，图中四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。</p><p>你可以设想下，如果你现在要找身份证号在 [ID_card_X, ID_card_Y] 这个区间的所有用户，就必须全部扫描一遍了。</p><p>所以，<strong>哈希表这种结构适用于只有等值查询的场景</strong>，比如 Memcached 及其他一些 NoSQL 引擎。</p><h3 id="2-有序数组"><a href="#2-有序数组" class="headerlink" title="2. 有序数组"></a>2. 有序数组</h3><p>而<strong>有序数组在等值查询和范围查询场景中的性能就都非常优秀</strong>。还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：</p><p><img src="http://ww1.sinaimg.cn/large/8c85763dly1g9qdtapczgj20vq0lvtci.jpg" alt="有序数组"></p><p>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查 ID_card_n2 对应的名字，用二分法就可以快速得到，这个时间复杂度是 O(log(N))。</p><p>同时很显然，这个索引结构支持范围查询。你要查身份证号在 [ID_card_X, ID_card_Y] 区间的 User，可以先用二分法找到 ID_card_X（如果不存在 ID_card_X，就找到大于 ID_card_X 的第一个 User），然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证号，退出循环。</p><p>如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。</p><p>所以，<strong>有序数组索引只适用于静态存储引擎</strong>，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。</p><h3 id="3-二叉搜索树"><a href="#3-二叉搜索树" class="headerlink" title="3. 二叉搜索树"></a>3. 二叉搜索树</h3><p>二叉搜索树也是课本里的经典数据结构了。还是上面根据身份证号查名字的例子，如果我们用二叉搜索树来实现的话，示意图如下所示：</p><p><img src="http://ww1.sinaimg.cn/large/8c85763dly1g9qdvsgabzj20vq0nsq96.jpg" alt="二叉搜索树"></p><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&gt; UserC -&gt; UserF -&gt; User2 这个路径得到。这个时间复杂度是 O(log(N))。</p><p>当然为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O(log(N))。</p><p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p><p>你可以想象一下一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。</p><p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。</p><p>以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p><p><strong>N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不管是哈希还是有序数组，或者 N 叉树，它们都是不断迭代、不断优化的产物或者解决方案。数据库技术发展到今天，跳表、LSM 树等数据结构也被用于引擎设计中，这里我就不再一一展开了。</p><p>你心里要有个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。</p><p>截止到这里，我用了半篇文章的篇幅和你介绍了不同的数据结构，以及它们的适用场景，你可能会觉得有些枯燥。但是，我建议你还是要多花一些时间来理解这部分内容，毕竟这是数据库处理数据的核心概念之一，在分析问题的时候会经常用到。当你理解了索引的模型后，就会发现在分析问题的时候会有一个更清晰的视角，体会到引擎设计的精妙之处。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。由于 InnoDB 存储引擎在 MySQL 数据库中使用最为广泛，所以下面我就以 InnoDB 为例，和你分析一下其中的索引模型。</p><h3 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h3><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。</p><p>每一个索引在 InnoDB 里面对应一棵 B+ 树。</p><p>假设，我们有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。</p><p>这个表的建表语句是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(</span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure><p>表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。</p><p><img src="http://ww1.sinaimg.cn/large/8c85763dly1g9qebzpw3xj20vq0nsn1h.jpg" alt="InnoDB 的索引组织结构"></p><p>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p><p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。</p><p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</p><p>根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区别？</p><ul><li>如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</li><li>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。</li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p><p>而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</p><p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。</p><p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p><p>基于上面的索引维护过程说明，我们来讨论一个案例：</p><blockquote><p>你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。</p></blockquote><p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。</p><p>插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。</p><p>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p><p>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p><p>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</p><p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。</p><p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p><p>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p><p>有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p><ol><li>只有一个索引；</li><li>该索引必须是唯一索引。</li></ol><p>你一定看出来了，这就是典型的 KV 场景。</p><p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p><p>这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;提到数据库索引，我想你并不陌生，在日常工作中会经常接触到。比如某一个 SQL 查询比较慢，分析完原因之后，你可能就会说“给某个字段加个索引吧”之类的解决方案。但到底什么是索引，索引又是如何工作的呢？今天就让我们一起来聊聊这个话题吧。&lt;/p&gt;
&lt;p&gt;一句话简单来说，&lt;stro
      
    
    </summary>
    
      <category term="MySQL" scheme="https://shleyz.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://shleyz.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>03 事务隔离：为什么你改了我还看不见</title>
    <link href="https://shleyz.github.io/2019/10/09/03-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81/"/>
    <id>https://shleyz.github.io/2019/10/09/03-事务隔离：为什么你改了我还看不见/</id>
    <published>2019-10-09T04:30:55.000Z</published>
    <updated>2020-02-28T05:44:47.710Z</updated>
    
    <content type="html"><![CDATA[<p>提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转账，你要给朋友小王转 100 块钱，而此时你的银行卡只有 100 块钱。</p><p>转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，你这 100 块钱，完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念了。</p><p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。</p><p>今天的文章里，我将会以 InnoDB 为例，剖析 MySQL 在事务支持方面的特定实现，并基于原理给出相应的实践建议，希望这些案例能加深你对 MySQL 事务原理的理解。</p><h2 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h2><p>提到事务，你肯定会想到 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天我们就来说说其中 I，也就是“隔离性”。</p><p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。</p><p>在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释：</p><ul><li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p>其中“读提交”和“可重复读”比较难理解，所以我用一个例子说明这几种隔离级别。假设数据表 T 中只有一列，其中一行的值为 1，下面是按照时间顺序执行两个事务的行为。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(c int) engine=InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T(c) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/8c85763dly1g9qd6bsdsuj20vq13g43h.jpg" alt="事务"></p><p>我们来看看在不同的隔离级别下，事务 A 会有哪些不同的返回结果，也就是图里面 V1、V2、V3 的返回值分别是什么。</p><ul><li><p>若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。</p></li><li><p>若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。</p></li><li><p>若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</p></li><li><p>若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。</p></li></ul><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。</p><p>在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。<br>在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。<br>这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；<br>而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p><p>我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle 数据库的默认隔离级别其实就是“读提交”，因此<strong>对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，你一定要记得将 MySQL 的隔离级别设置为“读提交”</strong>。</p><p>配置的方式是，将启动参数 transaction-isolation 的值设置成 READ-COMMITTED。你可以用 show variables 来查看当前的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; show variables like 'transaction_isolation';</span><br><span class="line"></span><br><span class="line">+<span class="comment">-----------------------+----------------+</span></span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+<span class="comment">-----------------------+----------------+</span></span><br><span class="line"></span><br><span class="line">| transaction_isolation | READ-COMMITTED |</span><br><span class="line"></span><br><span class="line">+<span class="comment">-----------------------+----------------+</span></span><br></pre></td></tr></table></figure><p>总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。我想你可能会问<strong>那什么时候需要“可重复读”的场景呢？</strong>我们来看一个数据校对逻辑的案例。</p><p>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p><p>这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</p><h2 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h2><p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。</p><p>在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p><p>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。</p><p><img src="http://ww1.sinaimg.cn/large/8c85763dly1g9qddyxehoj20vq0kh76q.jpg" alt="回滚"></p><p>当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。</p><p>同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。</p><p>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p><p>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 read-view 的时候。</p><p>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</p><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><p>在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。</p><p>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。</p><h2 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h2><p>如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL 的事务启动方式有以下几种：</p><ol><li>显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。</li><li>set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。</li></ol><p>有些客户端连接框架会默认连接成功后先执行一个 set autocommit=0 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</p><p>因此，我会建议你总是使用 set autocommit=1, 通过显式语句的方式来启动事务。</p><p>但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你使用 commit work and chain 语法。</p><p>在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p><p>你可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(<span class="keyword">timediff</span>(<span class="keyword">now</span>(),trx_started))&gt;<span class="number">60</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>介绍了 MySQL 的事务隔离级别的现象和实现，根据实现原理分析了长事务存在的风险，以及如何用正确的方式避免长事务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转账，你要给朋友小王转 100 块钱，而此时你的银行卡只有 100 块钱。&lt;/p&gt;
&lt;p&gt;转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不
      
    
    </summary>
    
      <category term="MySQL" scheme="https://shleyz.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://shleyz.github.io/tags/MySQL/"/>
    
  </entry>
  
</feed>
