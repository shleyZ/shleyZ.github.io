---
title: 数组拷贝
date: 2018-04-28 09:09:09
categories: javascript
---

### 首先要理解什么是栈内存和堆内存  

javascript中变量的存放有原始值和引用值之分

原始值代表原始数据类型，如Undefined，Null，Number， String，Boolean类型的值

引用值如Object，Function，Array

#### 1.栈内存存放存储对象的地址  

  原始类型的值，其地址和具体内容都存放在栈内,栈中数据的大小一般是已知的或者有上限的，自动分配内存空间，由系统自动释放内存

#### 2.堆内存存放存储对象的具体内容  

  引用类型的值(对象变量的指针)，其地址存放在栈内，但是其具体内容存放在堆中,堆中数据的大小一般是未知的，是动态分配内存的，系统不会自动释放内存
  这也是为什么null作为对象却存放在栈中。

**null === null    --> true  存储在栈**
**NaN === NaN  --> false  存储在堆**

#### 3.栈内存和堆内存的区别  

  栈内存相对与堆内存运行效率比较高，空间相对于堆内存来说较小

  **说明一下const一般定义的类型值是不能改的，但是定义的对象可以通过修改对象的属性来改变的（但是栈中存在的指针是不能变得）。**


---

### 什么是深拷贝和浅拷贝  

#### 浅拷贝  
  
  拷贝引用也就是栈内存放的指针，拷贝对象的和被拷贝对象都指向一个引用，并且修改数据会影响另一个数据


#### 深拷贝   
  
  复制变量的值，对于非基本类型的值，则递归至基本变量后，再复制。可以使用slice()和concat()


#### 1.浅拷贝的实现  

``` js

    var arr = ['a', 'b', 'c'];
    var arr1 = arr
    arr1[0] = 'd'
    arr   // ['d', 'b', 'c']  arr2的修改会影响被拷贝的值

```

#### 2.深拷贝的实现slice和concat和自定义函数实现    


##### 2.1 slice  

``` js

    var arr = ['a', 'b', 'c']
    var arr2 = arr.slice(0)
    arr2[0] = 'd'
    arr2  // ['d', 'b', 'c']
    arr   // ['a', 'b', 'c']  arr2的修改不会影响被拷贝的值

```

##### 2.2 concat  

``` js

    var arr = ['a', 'b', 'c']
    var arr2 = [].concat(arr)
    arr2[0] = 'd'
    arr2  // ['d', 'b', 'c']
    arr   // ['a', 'b', 'c']  arr2的修改不会影响被拷贝的值

```

##### 2.3 自定义  

``` js

    function DeepClone(obj) {
      if(obj === null){
        return null
      }
      if(obj.constructor !== 'object'){
        return obj
      }
      if(obj.constructor === Date){
        return new Date(obj)
      }
      if(obj.constructor === RegExp) {
        return new RegExp(obj)
      }

      var newObj = new obj.constructor() //保持继承的原型
      for (var key in obj) {
        if(obj.hasOwnProperty(key)) {
          var val = obj[key];
          newObj[key] = typeof val === 'object' ? DeepClone(val) : val
        }
      }
      return newObj
    }

    let a = DeepClone({'a': 1, 'b': 2, 'c': {'c1': 3}})
    a // {a: 1, b: 2, c: {c1: 3}}

```    