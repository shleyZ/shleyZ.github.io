<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><meta name="keywords" content="from-end, shleyZ, key1, key2, key3"><title>关于ES6语法 | 雪林的博客</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">关于ES6语法</h1><a id="logo" href="/.">雪林的博客</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">关于ES6语法</h1><div class="post-meta"><a href="/2017/09/28/关于ES6语法/#comments" class="comment-count"></a><p><span class="date">Sep 28, 2017</span><span><a href="/categories/ES6/" class="category">ES6</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="1-let和const命令"><a href="#1-let和const命令" class="headerlink" title="1.let和const命令"></a>1.let和const命令</h2><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>1.let用法类似var，但是let声明的变量只在let代码块内有效。用let很适用于for循环。</p>
<p>2.for循环有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<pre><code>for (let i = 0; i &lt; 3; i++) {
  let i = &apos;abc&apos;;
  console.log(i);
}
// abc
// abc
// abc
</code></pre><p>上面代码正确运行，输出了3次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。    </p>
<p>3.let不存在变量提升，即不可以没有声明就使用。否则会报错。</p>
<pre><code>// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
</code></pre><p>这表示在let声明bar之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。</p>
<p>4.暂时性死区</p>
<p>ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。    </p>
<p>ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</p>
<p>5.不允许重复声明</p>
<p>let不允许在<em>相同作用域内</em>，重复声明同一个变量。</p>
<pre><code>// 报错
function func() {
  let a = 10;
  var a = 1;
}

// 报错
function func() {
  let a = 10;
  let a = 1;
}
</code></pre><p>因此，不能在函数内部重新声明参数。</p>
<pre><code>function func(arg) {
  let arg; // 报错
}

function func(arg) {
  {
    let arg; // 不报错
  }
}
</code></pre><h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><p>ES5的作用域只有全局作用域和函数作用域<br>ES6中的let相当于增加了块级作用域</p>
<p>1.块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p>
<pre><code>// IIFE 写法
(function () {
  var tmp = ...;
  ...
}());

// 块级作用域写法
{
  let tmp = ...;
  ...
}
</code></pre><p>2.块级作用域与函数声明</p>
<p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p>
<pre><code>// 情况一（在ES5规定中是非法的，但是实际可以运行不会报错）
if (true) {
  function f() {}
}

// 情况二（在ES5规定中是非法的，但是实际可以运行不会报错）
try {
  function f() {}
} catch(e) {
  // ...
}    
</code></pre><p>ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p>
<p>ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p>
<pre><code>允许在块级作用域内声明函数。
函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
同时，函数声明还会提升到所在的块级作用域的头部。
</code></pre><p>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。</p>
<p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<pre><code>// 函数声明语句
{
  let a = &apos;secret&apos;;
  function f() {
    return a;
  }
}

// 函数表达式
{
  let a = &apos;secret&apos;;
  let f = function () {
    return a;
  };
}
</code></pre><h4 id="const-声明一个只读的常量"><a href="#const-声明一个只读的常量" class="headerlink" title="const 声明一个只读的常量"></a>const 声明一个只读的常量</h4><p>1.一旦声明，常量的值不能改变。并且声明的时候必须赋值，不能先声明后赋值。</p>
<pre><code>const PI = 3.1415;
PI // 3.1415

PI = 3;
// TypeError: Assignment to constant variable.
</code></pre><p>2.const与let的作用域一样，只在声明所在的块级作用域内有效。</p>
<pre><code>if (true) {
  const MAX = 5;
}
MAX // Uncaught ReferenceError: MAX is not defined    
</code></pre><p>3.const同样存在暂时性死区，只能在声明的位置后面使用。    </p>
<p>4.const声明的常量，也与let一样不可重复声明。</p>
<p>5.const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p>
<h4 id="ES6声明对象的六种方法"><a href="#ES6声明对象的六种方法" class="headerlink" title="ES6声明对象的六种方法"></a>ES6声明对象的六种方法</h4><p>ES5有:var,function两种方法</p>
<p>ES6有:var,function,let,const,import,class六种方法</p>
<h4 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h4><p>ES5之中，顶层对象的属性与全局变量是等价的。</p>
<pre><code>window.a = 1;
a // 1

a = 2;
window.a // 2
</code></pre><p>顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。    </p>
<p>ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<pre><code>var a = 1;
// 如果在Node的REPL环境，可以写成global.a
// 或者采用通用方法，写成this.a
window.a // 1

let b = 1;
window.b // undefined
</code></pre><p>全局变量a由var命令声明，所以它是顶层对象的属性；<br>全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。</p>
<h2 id="2-变量的结构赋值"><a href="#2-变量的结构赋值" class="headerlink" title="2.变量的结构赋值"></a>2.变量的结构赋值</h2><h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h4><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<pre><code>let [a, b, c] = [1, 2, 3];
</code></pre><p>从数组中提取值，按照对应位置，对变量赋值。如果解构不成功，变量的值就等于undefined。如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。</p>
<p>解构赋值允许指定默认值。（如果一个数组成员不严格等于undefined，默认值是不会生效的。）</p>
<pre><code>let [foo = true] = [];
foo // true
let [x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;
let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos;
</code></pre><p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。    </p>
<h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<pre><code>let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;

let { baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
baz // undefined
</code></pre><p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。    </p>
<h4 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h4><p>字符串被转换成了一个类似数组的对象。</p>
<pre><code>let {length : len} = &apos;hello&apos;;
len // 5
</code></pre><p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。<br>由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。    </p>
<h4 id="圆括号的问题"><a href="#圆括号的问题" class="headerlink" title="圆括号的问题"></a>圆括号的问题</h4><p>ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。因此，建议只要有可能，就不要在模式中放置圆括号。</p>
<p>不可以使用圆括号的情况：</p>
<p>1.变量声明语句<br>2.函数参数<br>3.赋值语句的模式</p>
<p>可以使用圆括号的情况：</p>
<p>只有一种：赋值语句的非模式部分，可以使用圆括号。</p>
<pre><code>[(b)] = [3]; // 正确
({ p: (d) } = {}); // 正确
[(parseInt.prop)] = [3]; // 正确
</code></pre><h4 id="变量解构赋值的用途"><a href="#变量解构赋值的用途" class="headerlink" title="变量解构赋值的用途"></a>变量解构赋值的用途</h4><p>1.交换变量的值</p>
<pre><code>let x = 1;
let y = 2;
[x, y] = [y, x];
</code></pre><p>2.从函数返回多个值</p>
<pre><code>// 返回一个数组
function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();

// 返回一个对象
function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar } = example();
</code></pre><p>3.函数参数的定义</p>
<pre><code>// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});
</code></pre><p>4.提取JSON数据</p>
<pre><code>let jsonData = {
  id: 42,
  status: &quot;OK&quot;,
  data: [867, 5309]
};

let { id, status, data: number } = jsonData;

console.log(id, status, number);
// 42, &quot;OK&quot;, [867, 5309]
</code></pre><p>5.函数参数的默认值</p>
<pre><code>jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
}) {
  // ... do stuff
};
</code></pre><p>6.遍历Map结构</p>
<pre><code>任何部署了Iterator接口的对象，都可以用for...of循环遍历。
const map = new Map();
map.set(&apos;first&apos;, &apos;hello&apos;);
map.set(&apos;second&apos;, &apos;world&apos;);

for (let [key, value] of map) {
  console.log(key + &quot; is &quot; + value);
}
// first is hello
// second is world
</code></pre><p>7.输入模块的指定方法</p>
<pre><code>const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);
</code></pre><h2 id="3-字符串的扩展"><a href="#3-字符串的扩展" class="headerlink" title="3.字符串的扩展"></a>3.字符串的扩展</h2><p>codePointAt()  —返回一个字符的码点。<br>String.fromCodePoint()      —从码点返回对应字符。<br>字符串的遍历器接口   —字符串可以被for…of循环遍历。<br>normalize()   —将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。<br>includes(), startsWith(), endsWith()<br>repeat(n)   —返回一个新字符串，表示将原字符串重复n次。<br>padStart()，padEnd()    —头部补全，尾部补全<br>模板字符串   —使用<br><code>In JavaScript &#39;\n&#39; is a line-feed.</code><br>模板字符串中嵌入变量，需要将变量名写在${}之中。使用&lt;%…%&gt;放置JavaScript代码，使用&lt;%= … %&gt;输出JavaScript表达式。<br>标签模板<br>String.raw()   —模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串</p>
<h2 id="4-正则的扩展"><a href="#4-正则的扩展" class="headerlink" title="4.正则的扩展"></a>4.正则的扩展</h2><h4 id="1-RegExp构造函数"><a href="#1-RegExp构造函数" class="headerlink" title="1.RegExp构造函数"></a>1.RegExp构造函数</h4><p>在ES5中RegExp构造函数的参数有两种表现形式：</p>
<pre><code>var regex = new RegExp(&apos;xyz&apos;, &apos;i&apos;);
var regex = new RegExp(/xyz/i);
</code></pre><p>在第二种参数为正则表达式时，不允许有第二个参数。</p>
<p>但是在ES6中，如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。并且会忽略第一个参数正则里面的修饰符，只使用新的修饰符。</p>
<pre><code>new RegExp(/abc/ig, &apos;i&apos;).flags
// &quot;i&quot;
</code></pre><h4 id="2-字符串的正则方法"><a href="#2-字符串的正则方法" class="headerlink" title="2.字符串的正则方法"></a>2.字符串的正则方法</h4><p>match()<br>replace()<br>search()<br>split()</p>
<h4 id="3-u修饰符"><a href="#3-u修饰符" class="headerlink" title="3.u修饰符"></a>3.u修饰符</h4><p>ES6 对正则表达式<em>添加了u修饰符</em>，含义为“Unicode模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</p>
<p>1.点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。</p>
<pre><code>var s = &apos;𠮷&apos;;
/^.$/.test(s) // false
/^.$/u.test(s) // true
</code></pre><p>2.Unicode 字符表示法：ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。</p>
<pre><code>/\u{61}/.test(&apos;a&apos;) // false
/\u{61}/u.test(&apos;a&apos;) // true
/\u{20BB7}/u.test(&apos;𠮷&apos;) // true
</code></pre><p>3.量词:使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。</p>
<pre><code>/a{2}/.test(&apos;aa&apos;) // true
/a{2}/u.test(&apos;aa&apos;) // true
/𠮷{2}/.test(&apos;𠮷𠮷&apos;) // false
/𠮷{2}/u.test(&apos;𠮷𠮷&apos;) // true
</code></pre><p>4.预定义模式</p>
<pre><code>/^\S$/.test(&apos;𠮷&apos;) // false
/^\S$/u.test(&apos;𠮷&apos;) // true
</code></pre><p>上面代码的\S是预定义模式，匹配所有不是空格的字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的 Unicode 字符。</p>
<p>5.i 修饰符:有些 Unicode 字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K。</p>
<pre><code>/[a-z]/i.test(&apos;\u212A&apos;) // false
/[a-z]/iu.test(&apos;\u212A&apos;) // true
</code></pre><p>上面代码中，不加u修饰符，就无法识别非规范的K字符。</p>
<h4 id="y修饰符—“粘连”（sticky）修饰符"><a href="#y修饰符—“粘连”（sticky）修饰符" class="headerlink" title="y修饰符—“粘连”（sticky）修饰符"></a>y修饰符—“粘连”（sticky）修饰符</h4><p>y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p>
<p>y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。</p>
<p>单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。</p>
<pre><code>&apos;a1a2a3&apos;.match(/a\d/y) // [&quot;a1&quot;]
&apos;a1a2a3&apos;.match(/a\d/gy) // [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;]
</code></pre><h2 id="5-数值的扩展"><a href="#5-数值的扩展" class="headerlink" title="5.数值的扩展"></a>5.数值的扩展</h2><h4 id="1-二进制和八进制表示法："><a href="#1-二进制和八进制表示法：" class="headerlink" title="1.二进制和八进制表示法："></a>1.二进制和八进制表示法：</h4><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。</p>
<p>如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。</p>
<pre><code>Number(&apos;0b111&apos;)  // 7
Number(&apos;0o10&apos;)  // 8
</code></pre><h4 id="2-Number-isFinite-Number-isNaN"><a href="#2-Number-isFinite-Number-isNaN" class="headerlink" title="2.Number.isFinite(), Number.isNaN()"></a>2.Number.isFinite(), Number.isNaN()</h4><h4 id="3-Number-parseInt-Number-parseFloat"><a href="#3-Number-parseInt-Number-parseFloat" class="headerlink" title="3.Number.parseInt(), Number.parseFloat()"></a>3.Number.parseInt(), Number.parseFloat()</h4><pre><code>// ES5的写法
parseInt(&apos;12.34&apos;) // 12
parseFloat(&apos;123.45#&apos;) // 123.45
// ES6的写法
Number.parseInt(&apos;12.34&apos;) // 12
Number.parseFloat(&apos;123.45#&apos;) // 123.45
</code></pre><h4 id="4-Number-isInteger-判断一个值是否为整数"><a href="#4-Number-isInteger-判断一个值是否为整数" class="headerlink" title="4.Number.isInteger()判断一个值是否为整数"></a>4.Number.isInteger()判断一个值是否为整数</h4><h4 id="5-Number-EPSILON"><a href="#5-Number-EPSILON" class="headerlink" title="5.Number.EPSILON"></a>5.Number.EPSILON</h4><p>ES6在Number对象上面，新增一个极小的常量Number.EPSILON。</p>
<pre><code>Number.EPSILON
// 2.220446049250313e-16
Number.EPSILON.toFixed(20)
// &apos;0.00000000000000022204&apos;    
</code></pre><p>Number.EPSILON的实质是一个可以接受的误差范围。</p>
<pre><code>function withinErrorMargin (left, right) {
  return Math.abs(left - right) &lt; Number.EPSILON;
}
withinErrorMargin(0.1 + 0.2, 0.3)
// true
withinErrorMargin(0.2 + 0.2, 0.3)
// false    
</code></pre><p>上面的代码为浮点数运算，部署了一个误差检查函数。    </p>
<h4 id="6-Math对象的扩展"><a href="#6-Math对象的扩展" class="headerlink" title="6.Math对象的扩展"></a>6.Math对象的扩展</h4><p>Math.trunc()去除一个数的小数部分，返回整数部分<br>Math.sign()判断一个数是正数(返回+1)、负数(返回-1)、还是0(返回0)，非数值转换为数值，无法转换为数值返回NaN。<br>Math.cbrt()计算一个数的立方根<br>Math.clz32()返回一个数的32位无符号整数形式有多少个前导0,如果是小数的话，则只考虑整数部分。<br>Math.imul()返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。<br>Math.fround()返回一个数的单精度浮点数形式。<br>Math.hyot()返回所有参数的平方之和的平方根。如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回NaN。</p>
<p>对数方法：<br>Math.expm1()返回ex - 1，即Math.exp(x) - 1（e的x次方减1）.<br>Math.log1p()返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。<br>Math.log10()返回以10为底的x的对数。如果x小于0，则返回NaN。<br>Math.log2()返回以2为底的x的对数。如果x小于0，则返回NaN。</p>
<p>双曲函数方法：<br>Math.sinh(x)返回x的双曲正弦<br>Math.cosh(x)返回x的双曲余弦<br>Math.tanh(x)返回x的双曲正切<br>Math.asinh(x)返回x的反双曲正弦<br>Math.acosh(x)返回x的反双曲余弦<br>Math.atanh(x)返回x的反双曲正切</p>
<h4 id="7-Math-signbit-判断值是否是负值（包括-0，判断符号位）"><a href="#7-Math-signbit-判断值是否是负值（包括-0，判断符号位）" class="headerlink" title="7.Math.signbit()判断值是否是负值（包括-0，判断符号位）"></a>7.Math.signbit()判断值是否是负值（包括-0，判断符号位）</h4><p>如果参数是NaN，返回false<br>如果参数是-0，返回true<br>如果参数是负值，返回true<br>其他情况返回false</p>
<h4 id="8-指数运算符"><a href="#8-指数运算符" class="headerlink" title="8.指数运算符**"></a>8.指数运算符**</h4><p>ES6新增的指数运算符：</p>
<pre><code>a ** b  //a的b次幂    
</code></pre><p>注：在V8引擎中，指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。    </p>
<pre><code>Math.pow(99,99)
//3.697296376497263e+197
99 ** 99
//3.697296376497268e+197
</code></pre><h4 id="9-integer数据类型"><a href="#9-integer数据类型" class="headerlink" title="9.integer数据类型"></a>9.integer数据类型</h4><p>JavaScript 所有数字都保存成64位浮点数，这决定了整数的精确程度只能到53个二进制位。大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。</p>
<p>为了与 Number 类型区别，Integer 类型的数据必须使用后缀n表示。</p>
<h2 id="6-函数的扩展"><a href="#6-函数的扩展" class="headerlink" title="6.函数的扩展"></a>6.函数的扩展</h2><h4 id="1-函数参数的默认值"><a href="#1-函数参数的默认值" class="headerlink" title="1.函数参数的默认值"></a>1.函数参数的默认值</h4><p>在ES6以前是不能给参数指定默认值的，但在ES6可以，即直接写着参数定义的后面。<br>参数变量是默认声明的，所以不能用let或const再次声明。<br>参数不能有同名参数出现</p>
<pre><code>function(x,y = &apos;world&apos;){
    console.log(x,y);
}
</code></pre><p>优点：<br>1.可以明显得知那些参数是可以省略的<br>2.利于代码的优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p>
<h4 id="2-函数的length属性"><a href="#2-函数的length属性" class="headerlink" title="2.函数的length属性"></a>2.函数的length属性</h4><p>arguments.length是函数实际接收到的参数个数<br>Function.length 是函数形参的个数，即期望得到的参数的个数</p>
<p>当函数制定了默认值，函数的length属性将失真，即不包含默认值的参数（也不包含设置默认值参数之后的参数）</p>
<pre><code>(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2
</code></pre><p>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。</p>
<pre><code>(function (a = 0, b, c) {}).length // 0
(function (a, b = 1, c) {}).length // 1
</code></pre><h4 id="3-rest参数"><a href="#3-rest参数" class="headerlink" title="3.rest参数"></a>3.rest参数</h4><p>用于获取函数的多余参数（values是一个数组）</p>
<pre><code>形式为  ...变量名
function add(...values){}
</code></pre><p>栗子：</p>
<pre><code>function add(...values) {
    let sum = 0;

    for(var val of values){
        sum += val;
    }
    return sum;
}

add(1,2,3,4,5);  //15
</code></pre><p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<p>函数的length属性，不包括 rest 参数。</p>
<pre><code>(function(a) {}).length  // 1
(function(...a) {}).length  // 0
(function(a, ...b) {}).length  // 1
</code></pre><p>函数的arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。</p>
<pre><code>function push(array, ...items) {
  items.forEach(function(item) {
    array.push(item);
    console.log(item);
  });
}
var a = [];
push(a, 1, 2, 3)
</code></pre><h4 id="4-严格模式"><a href="#4-严格模式" class="headerlink" title="4.严格模式"></a>4.严格模式</h4><p>从 ES5 开始，函数内部可以设定为严格模式。</p>
<p>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
<p>两种方法可以规避这种情况：</p>
<p>1.设定全局性的严格模式，这是合法的。</p>
<pre><code>&apos;use strict&apos;;

function doSomething(a, b = a) {
  // code
}
</code></pre><p>2.把函数包在一个无参数的立即执行函数里面。</p>
<pre><code>const doSomething = (function () {
  &apos;use strict&apos;;
  return function(value = 42) {
    return value;
  };
}());
</code></pre><h4 id="5-name属性"><a href="#5-name属性" class="headerlink" title="5.name属性"></a>5.name属性</h4><p>返回函数的函数名</p>
<pre><code>function foo() {}
foo.name // &quot;foo&quot;
</code></pre><p>匿名函数在ES5和ES6中返回结果不一样，ES5返回空，ES6返回函数名</p>
<pre><code>var f = function () {};
// ES5
f.name // &quot;&quot;
// ES6
f.name // &quot;f&quot;    
</code></pre><p>构造函数的name返回值为：anonymous</p>
<pre><code>(new Function).name // &quot;anonymous&quot;
</code></pre><p>bind返回的函数，name属性值会加上bound前缀。</p>
<pre><code>function foo() {};
foo.bind({}).name // &quot;bound foo&quot;

(function(){}).bind({}).name // &quot;bound &quot;    
</code></pre><h4 id="6-箭头函数"><a href="#6-箭头函数" class="headerlink" title="6.箭头函数"></a>6.箭头函数</h4><p>ES6允许使用“箭头”（=&gt;）定义函数。</p>
<pre><code>var sum = (num1, num2) =&gt; { return num1 + num2; }
</code></pre><p>(num1, num2)是参数部分，    { return num1 + num2; }是函数体</p>
<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<pre><code>var f = () =&gt; 5;
// 等同于
var f = function () { return 5 };
</code></pre><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p>
<pre><code>// 报错
let getTempItem = id =&gt; { id: id, name: &quot;Temp&quot; };

// 不报错
let getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });    
</code></pre><p>箭头函数的一个用处是简化回调函数。</p>
<pre><code>// 正常函数写法
[1,2,3].map(function (x) {
  return x * x;
});

// 箭头函数写法
[1,2,3].map(x =&gt; x * x);
</code></pre><p>rest 参数与箭头函数结合的例子：</p>
<pre><code>const numbers = (...nums) =&gt; nums;

numbers(1, 2, 3, 4, 5)
// [1,2,3,4,5]

const headAndTail = (head, ...tail) =&gt; [head, tail];

headAndTail(1, 2, 3, 4, 5)
// [1,[2,3,4,5]]    
</code></pre><p>箭头函数的注意点（箭头函数没有自己的this）：</p>
<p>1.函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>2.不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。<br>3.不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。<br>4.不可以使用yield命令，因此箭头函数不能用作 Generator 函数。    </p>
<h4 id="7-绑定this"><a href="#7-绑定this" class="headerlink" title="7.绑定this"></a>7.绑定this</h4><p>函数绑定运算符::，运算符左边是对象，右边是函数，将对象绑定到函数的this对象上。</p>
<pre><code>foo::bar;
// 等同于
bar.bind(foo);

foo::bar(...arguments);
// 等同于
bar.apply(foo, arguments);

const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return obj::hasOwnProperty(key);
}
</code></pre><p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p>
<pre><code>var method = obj::obj.foo;
// 等同于
var method = ::obj.foo;

let log = ::console.log;
// 等同于
var log = console.log.bind(console);
</code></pre><p>由于双冒号运算符返回的还是原对象，因此可以采用链式写法。</p>
<pre><code>// 例一
import { map, takeWhile, forEach } from &quot;iterlib&quot;;

getPlayers()
::map(x =&gt; x.character())
::takeWhile(x =&gt; x.strength &gt; 100)
::forEach(x =&gt; console.log(x));

// 例二
let { find, html } = jake;

document.querySelectorAll(&quot;div.myClass&quot;)
::find(&quot;p&quot;)
::html(&quot;hahaha&quot;);
</code></pre><h4 id="8-尾调用优化"><a href="#8-尾调用优化" class="headerlink" title="8.尾调用优化"></a>8.尾调用优化</h4><p>尾调用就是函数的最后一步是调用另一个函数。</p>
<p>“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>
<p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>
<pre><code>function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);    
</code></pre><p>尾递归：尾调用自身的情况</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<pre><code>function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}

factorial(5) // 120    
</code></pre><p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。    </p>
<pre><code>function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5, 1) // 120
</code></pre><p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。    </p>
<p>非尾递归的 Fibonacci 数列实现如下。</p>
<pre><code>function Fibonacci (n) {
  if ( n &lt;= 1 ) {return 1};

  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10) // 89
Fibonacci(100) // 堆栈溢出
Fibonacci(500) // 堆栈溢出
</code></pre><p>尾递归优化过的 Fibonacci 数列实现如下。</p>
<pre><code>function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n &lt;= 1 ) {return ac2};

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
</code></pre><p><em>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</em></p>
<h2 id="7-数组的扩展"><a href="#7-数组的扩展" class="headerlink" title="7.数组的扩展"></a>7.数组的扩展</h2><h4 id="1-扩展运算符spread（…）"><a href="#1-扩展运算符spread（…）" class="headerlink" title="1.扩展运算符spread（…）"></a>1.扩展运算符spread（…）</h4><p>它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。主要用于函数的调用</p>
<pre><code>function push(array, ...items) {
  array.push(...items);
}

function add(x, y) {
  return x + y;
}

const numbers = [4, 38];
add(...numbers) // 42
</code></pre><p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>
<pre><code>function f(v, w, x, y, z) { }
const args = [0, 1];
f(-1, ...args, 2, ...[3]);
</code></pre><p>扩展运算符可以替换apply方法（把数组转换为函数的参数）：</p>
<pre><code>// ES5 的写法
Math.max.apply(null, [14, 3, 77])

// ES6 的写法
Math.max(...[14, 3, 77])

// 等同于
Math.max(14, 3, 77);
</code></pre><p>上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。</p>
<p>扩展运算符的应用：</p>
<p>1.复制数组</p>
<p>对于ES5，一维数组可以用slice或者concat实现深拷贝。</p>
<pre><code>const a1 = [1, 2];
const a2 = a1.concat();

a2[0] = 2;
a1 // [1, 2]
</code></pre><p>用扩展运算符…实现：</p>
<pre><code>const a1 = [1,2,3];
const a2 = [...a1];
</code></pre><p>2.合并数组</p>
<pre><code>// ES5
[1, 2].concat(more)
// ES6
[1, 2, ...more]
</code></pre><p>3.与解构赋值结合</p>
<p>4.将字符串转换为数组</p>
<pre><code>[...&apos;hello&apos;]
// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]
</code></pre><p>5.实现了 Iterator 接口的对象</p>
<p>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组。</p>
<pre><code>let nodeList = document.querySelectorAll(&apos;div&apos;);
let array = [...nodeList];
</code></pre><h4 id="2-Array-from"><a href="#2-Array-from" class="headerlink" title="2.Array.from"></a>2.Array.from</h4><p>将类数组对象和可遍历的对象转换为数组</p>
<pre><code>Array.from(&apos;hello&apos;)
// [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]

let namesSet = new Set([&apos;a&apos;, &apos;b&apos;])
Array.from(namesSet) // [&apos;a&apos;, &apos;b&apos;]    
</code></pre><p>对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。</p>
<p>Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。</p>
<pre><code>Array.from({ length: 2 }, () =&gt; &apos;jack&apos;)
// [&apos;jack&apos;, &apos;jack&apos;]    
</code></pre><h4 id="3-Array-of"><a href="#3-Array-of" class="headerlink" title="3.Array.of"></a>3.Array.of</h4><p>将一组值，转换为数组。    </p>
<pre><code>Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
</code></pre><h4 id="4-数组实例的copyWithin"><a href="#4-数组实例的copyWithin" class="headerlink" title="4.数组实例的copyWithin()"></a>4.数组实例的copyWithin()</h4><p>数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<pre><code>[1, 2, 3, 4, 5].copyWithin(0, 3)
// [4, 5, 3, 4, 5]
</code></pre><p>语法：</p>
<pre><code>Array.prototype.copyWithin(target, start = 0, end = this.length)
</code></pre><p>它接受三个参数。</p>
<p>target（必需）：从该位置开始替换数据。<br>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。<br>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。        </p>
<h4 id="5-数组实例的find-和findIndex"><a href="#5-数组实例的find-和findIndex" class="headerlink" title="5.数组实例的find()和findIndex()"></a>5.数组实例的find()和findIndex()</h4><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p>
<p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>
<pre><code>[1, 4, -5, 10].find((n) =&gt; n &lt; 0)
// -5

[1, 5, 10, 15].findIndex(function(value, index, arr) {
  return value &gt; 9;
}) // 2
</code></pre><p>这两个方法都可以发现NaN，弥补了数组的<em>IndexOf</em>方法的不足。</p>
<pre><code>[NaN].indexOf(NaN)
// -1
[NaN].findIndex(y =&gt; Object.is(NaN, y))
// 0    
</code></pre><h4 id="6-数组实例的fill"><a href="#6-数组实例的fill" class="headerlink" title="6.数组实例的fill()"></a>6.数组实例的fill()</h4><p>fill方法使用给定值，填充一个数组。</p>
<p>fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<pre><code>[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)
// [&apos;a&apos;, 7, &apos;c&apos;]
</code></pre><h4 id="7-数组实例的-entries-keys-values"><a href="#7-数组实例的-entries-keys-values" class="headerlink" title="7.数组实例的    entries(),keys(),values()"></a>7.数组实例的    entries(),keys(),values()</h4><p>ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
<pre><code>for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) {
  console.log(elem);
}
// &apos;a&apos;
// &apos;b&apos;

for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) {
  console.log(index, elem);
}
// 0 &quot;a&quot;
// 1 &quot;b&quot;
</code></pre><h4 id="8-数组实例的-includes"><a href="#8-数组实例的-includes" class="headerlink" title="8.数组实例的    includes()"></a>8.数组实例的    includes()</h4><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。</p>
<pre><code>[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true
</code></pre><h4 id="9-数组的空位"><a href="#9-数组的空位" class="headerlink" title="9.数组的空位"></a>9.数组的空位</h4><p>数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。</p>
<pre><code>Array(3) // [, , ,]
</code></pre><p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
<h2 id="8-对象的扩展"><a href="#8-对象的扩展" class="headerlink" title="8.对象的扩展"></a>8.对象的扩展</h2><h4 id="1-属性的简洁表示法"><a href="#1-属性的简洁表示法" class="headerlink" title="1.属性的简洁表示法"></a>1.属性的简洁表示法</h4><p>ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。</p>
<pre><code>function f(x, y) {
  return {x, y};
}

// 等同于

function f(x, y) {
  return {x: x, y: y};
}

f(1, 2) // Object {x: 1, y: 2}
</code></pre><p>方法的简写：</p>
<pre><code>let birth = &apos;2000/01/01&apos;;

const Person = {

  name: &apos;张三&apos;,

  //等同于birth: birth
  birth,

  // 等同于hello: function ()...
  hello() { console.log(&apos;我的名字是&apos;, this.name); }

};    
</code></pre><h4 id="2-属性名表达式"><a href="#2-属性名表达式" class="headerlink" title="2.属性名表达式"></a>2.属性名表达式</h4><p>ES6允许用表达式定义对象的属性名。</p>
<pre><code>let propKey = &apos;foo&apos;;
let obj = {
  [propKey]: true,
  [&apos;a&apos; + &apos;bc&apos;]: 123
};
</code></pre><p>S6允许用表达式定义对象的方法名：</p>
<pre><code>let obj = {
  [&apos;h&apos; + &apos;ello&apos;]() {
    return &apos;hi&apos;;
  }
};

obj.hello() // hi    
</code></pre><p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。</p>
<pre><code>const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
  [keyA]: &apos;valueA&apos;,
  [keyB]: &apos;valueB&apos;
};

myObject // Object {[object Object]: &quot;valueB&quot;}    
</code></pre><p>上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。</p>
<h4 id="3-方法的name属性"><a href="#3-方法的name属性" class="headerlink" title="3.方法的name属性"></a>3.方法的name属性</h4><p>函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。</p>
<pre><code>const person = {
  sayName() {
    console.log(&apos;hello!&apos;);
  },
};

person.sayName.name   // &quot;sayName&quot;
</code></pre><p>如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。</p>
<p>有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。</p>
<pre><code>(new Function()).name // &quot;anonymous&quot;

var doSomething = function() {
  // ...
};
doSomething.bind().name // &quot;bound doSomething&quot;
</code></pre><h4 id="4-Object-is-比较两个值是否严格相等"><a href="#4-Object-is-比较两个值是否严格相等" class="headerlink" title="4.Object.is()比较两个值是否严格相等"></a>4.Object.is()比较两个值是否严格相等</h4><p>它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>
<p>它们的不同是(+0与-0，NaN与NaN)：</p>
<pre><code>+0 === -0     //true
NaN === NaN   //false

Object.is(+0,-0)     //false
Object.is(NaN,NaN)   //true
</code></pre><h4 id="5-Object-assign-用于对象的合并"><a href="#5-Object-assign-用于对象的合并" class="headerlink" title="5.Object.assign()用于对象的合并"></a>5.Object.assign()用于对象的合并</h4><pre><code>const target = { a: 1 };

const source1 = { b: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
</code></pre><p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<p>如果该参数不是对象，则会先转成对象，然后返回。</p>
<p>由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。</p>
<p>Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。</p>
<p>用途：</p>
<p>1.为对象添加属性或方法<br>2.克隆对象（浅拷贝）<br>3.合并多个对象</p>
<pre><code>const merge =(...sources) =&gt; Object.assign({}, ...sources);
</code></pre><p>4.为属性指定默认值</p>
<h4 id="6-属性的可枚举性和遍历"><a href="#6-属性的可枚举性和遍历" class="headerlink" title="6.属性的可枚举性和遍历"></a>6.属性的可枚举性和遍历</h4><p>Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</p>
<pre><code>let obj = { foo: 123 };
Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;)
//configurable:true
//enumerable:true
//value:123
//writable:true
</code></pre><p>其中的enumerable枚举属性，如果为false，那么for…in,Object.keys(),JSON.stringfy(),Object.assign()这些操作都会忽略该属性。<br>（for…in会遍历继承的属性，而Object.keys()则不会，因此当我们只关心对象自身的属性时，最好不要用for…in,而选用Object.keys()）.</p>
<h4 id="7-Object-getOwnPropertyDescriptors"><a href="#7-Object-getOwnPropertyDescriptors" class="headerlink" title="7.Object.getOwnPropertyDescriptors()"></a>7.Object.getOwnPropertyDescriptors()</h4><p>返回某个对象属性的描述对象（descriptor）,即返回某个对象的自身属性，而不包含继承属性</p>
<h4 id="8-proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#8-proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="8.proto 属性，Object.setPrototypeOf()，Object.getPrototypeOf()"></a>8.<strong>proto</strong> 属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h4><p>1.<strong>proto</strong> 属性用来读取和设置当前对象的prototype属性。</p>
<p>一个属性的<strong>proto</strong> 值表示这个对象的原型。ES6不建议用这个方法。</p>
<p>2.Object.setPrototypeOf()</p>
<p>设置对象的prototype，ES6建议用Object.setPropertyOf().返回对象本身。</p>
<pre><code>let proto = {};
let obj = { x: 10 };
Object.setPrototypeOf(obj, proto);

proto.y = 20;
proto.z = 40;

obj.x // 10
obj.y // 20
obj.z // 40
</code></pre><p>3.Object.getPrototypeOf()</p>
<p>用于读取一个对象的原型</p>
<h4 id="9-super关键字"><a href="#9-super关键字" class="headerlink" title="9.super关键字"></a>9.super关键字</h4><p>super关键字指向当前对象的原型对象。只能用在对象的方法里面，用在其他地方会报错。</p>
<h4 id="10-Object-keys-Object-values-Object-entries"><a href="#10-Object-keys-Object-values-Object-entries" class="headerlink" title="10.Object.keys(),Object.values(),Object.entries()"></a>10.Object.keys(),Object.values(),Object.entries()</h4><p>Object.keys()       遍历对象的所有（enumerable为true，不是继承的）键名<br>Object.values()      遍历对象的所有（enumerable为true，不是继承的）键值<br>Object.entries()    遍历对象的所有（enumerable为true，不是继承的）键值对</p>
<h2 id="10-symbol"><a href="#10-symbol" class="headerlink" title="10.symbol"></a>10.symbol</h2><p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<p>凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<pre><code>let s = Symbol();

typeof s
// &quot;symbol&quot;
</code></pre><p>Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<p>Symbol值不能与其他类型的值进行运算，否则会报错。</p>
<p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
<p>注意，Symbol 值作为对象属性名时，不能用点运算符。<br>在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。<br>Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</p>
<h2 id="11-Set和Map数据结构"><a href="#11-Set和Map数据结构" class="headerlink" title="11.Set和Map数据结构"></a>11.Set和Map数据结构</h2><h4 id="1-Set"><a href="#1-Set" class="headerlink" title="1.Set"></a>1.Set</h4><p>ES6提供新的数据结构SET。它类似于数组，但是其内部成员的值都是唯一的，没有重复值(判断的方法类似于全等判断)。</p>
<pre><code>const s = new Set();
[2,3,5,4,5,2,2].forEach(x =&gt; s.add(x));

for(let i of s){
    console.log(i);
}
</code></pre><p>返回结果是：2 3 5 4。结果表明 Set 结构不会添加重复的值。</p>
<p>Set函数可以接受一个数组作为参数来初始化：</p>
<pre><code>const set = new Set([1, 2, 3, 4, 4]);
[...set]
// [1, 2, 3, 4]

const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
items.size // 5    
items.length //undefined
</code></pre><p>利用Set的成员唯一性，可以用来数组去重：</p>
<pre><code>let myArray = [1,2,3,4,3,2,4,1];
let arr = [...new Set(myArray)];
console.log(arr);
//[1, 2, 3, 4]
</code></pre><h4 id="2-Set实例的属性和方法"><a href="#2-Set实例的属性和方法" class="headerlink" title="2.Set实例的属性和方法"></a>2.Set实例的属性和方法</h4><p>操作方法：</p>
<p>1.add(value)     添加某个值，返回Set结构本身<br>2.delete(value)  删除某个值，返回布尔值，是否删除成功<br>3.has(value)     判断某个值是不是Set成员，返回布尔值<br>4.clear()        清空Set成员，没有返回值</p>
<pre><code>s.add(1).add(2).add(2);
// 注意2被加入了两次

s.size // 2

s.has(1) // true
s.has(2) // true
s.has(3) // false

s.delete(2);
s.has(2) // false
</code></pre><p>Array.from方法可以将 Set 结构转为数组。</p>
<pre><code>const items = new Set([1, 2, 3, 4, 5]);
const array = Array.from(items);
</code></pre><p>这样数组去重就可以这样来写：</p>
<pre><code>Array.from(new Set(array))
</code></pre><p>遍历Set：</p>
<p>1.keys()      返回键名<br>2.values()    返回键值<br>3.entries()   返回键值对<br>4.foreach()   使用回调函数遍历</p>
<h4 id="3-WeakSet"><a href="#3-WeakSet" class="headerlink" title="3.WeakSet"></a>3.WeakSet</h4><p>与Set差不多，都是不重复值的集合，但是<em>WeakSet的值必须是对象</em>，不能是其他类型的值。</p>
<p>语法：</p>
<pre><code>const ws = new WeakSet()
</code></pre><p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。这个类数组对象的成员必须是对象。否则会报错</p>
<pre><code>const a = [[1, 2], [3, 4]];
const ws = new WeakSet(a);
// WeakSet {[1, 2], [3, 4]}
const b = [3, 4];
const ws = new WeakSet(b);
// Uncaught TypeError: Invalid value used in weak set(…)
</code></pre><p>WeakSet的方法：</p>
<p>1.WeakSet.prototype.add(value)<br>2.WeakSet.prototype.delete(value)<br>3.WeakSet.prototype.has(value)</p>
<p>他没有size属性,不能遍历它的成员</p>
<h4 id="4-Map"><a href="#4-Map" class="headerlink" title="4.Map"></a>4.Map</h4><p>Object 结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应。即对象的属性名（键）不只是字符串形式了，还可以是各种类型的值或对象。</p>
<pre><code>const m = new Map();
const o = {p: &apos;Hello World&apos;};

m.set(o, &apos;content&apos;)
m.get(o) // &quot;content&quot;

m.has(o) // true
m.delete(o) // true
m.has(o) // false
</code></pre><p>作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>
<pre><code>const map = new Map([
  [&apos;name&apos;, &apos;张三&apos;],
  [&apos;title&apos;, &apos;Author&apos;]
]);

map.size // 2
map.has(&apos;name&apos;) // true
map.get(&apos;name&apos;) // &quot;张三&quot;
map.has(&apos;title&apos;) // true
map.get(&apos;title&apos;) // &quot;Author&quot;
</code></pre><h4 id="5-WeakMap"><a href="#5-WeakMap" class="headerlink" title="5.WeakMap"></a>5.WeakMap</h4><p>WeakMap结构与Map结构类似，也是用于生成键值对的集合。</p>
<p>首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</p>
<p>其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。</p>
<p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。</p>
<p>一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。</p>
<pre><code>const wm = new WeakMap();

const element = document.getElementById(&apos;example&apos;);

wm.set(element, &apos;some information&apos;);
wm.get(element) // &quot;some information&quot;
</code></pre><p>总之，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。</p>
<p>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</p>
<pre><code>const wm = new WeakMap();
let key = {};
let obj = {foo: 1};

wm.set(key, obj);
obj = null;
wm.get(key)
// Object {foo: 1}
</code></pre><p>上面代码中，键值obj是正常引用。所以，即使在 WeakMap 外部消除了obj的引用，WeakMap 内部的引用依然存在。</p>
<p>WeakMap规定不能取到键名,无法清空.即不支持clear方法。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。</p>
<pre><code>const wm = new WeakMap();

// size、forEach、clear 方法都不存在
wm.size // undefined
wm.forEach // undefined
wm.clear // undefined
</code></pre><h2 id="12-Proxy"><a href="#12-Proxy" class="headerlink" title="12.Proxy"></a>12.Proxy</h2><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<h2 id="13-Reflect"><a href="#13-Reflect" class="headerlink" title="13.Reflect"></a>13.Reflect</h2><p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。</p>
<p>（1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</p>
<p>（2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</p>
<p>（3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</p>
<p>（4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</p>
<h2 id="14-Promise对象"><a href="#14-Promise对象" class="headerlink" title="14.Promise对象"></a>14.Promise对象</h2><p>一种异步解决方案。从Promise对象，可以获取异步操作的信息。</p>
<p>简单来说Promise是一个容器，它包含着一个未来才会结束的事件（通常是一个异步操作）</p>
<p>Promise分为三个状态：pending-进行中,fulfilled-已成功,rejected-已失败.</p>
<p>Promise的特点：</p>
<p>1.对象的状态不受外部影响。只有异步操作的结果可以影响Promise状态。任何其他操作都无法改变这个状态。</p>
<p>2.一旦状态改变就不会再次改变，这时就称为 resolved（已定型）。任何时候都能得到异步结果（状态）。Promise状态的改变，只有可能有两种：pending -&gt; fulfilled  或者  pending -&gt; rejected.</p>
<p>Promise的缺点：</p>
<p>1.无法取消Promise。一旦新建就会立即执行，无法中途取消。</p>
<p>2.如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</p>
<p>3.当处于pending状态时，无法得知目前进展到什么阶段（是刚刚开始海试即将完成）。</p>
<h4 id="Promise基本用法"><a href="#Promise基本用法" class="headerlink" title="Promise基本用法"></a>Promise基本用法</h4><p>Promise对象是一个构造函数。</p>
<pre><code>var promise = new Promise(function(resolve,reject){
    //some coding ....

    //如果异步操作成功resolve(value)，否则reject(err)
    if(win){
        resolve(value);
    }else{
        reject(err);
    }
})
</code></pre><p>其中的回调函数中的两个参数resolve和reject分别是两个函数，它们由javascript引擎提供，不需要自己部署。</p>
<p>resolve函数的作用：将Promise对象的状态由pending变为fulfilled，并且在异步操作成功时，将异步操作的结果value，作为参数传递出去。</p>
<p>reject函数的作用：将Promise对象的状态由pending变为rejected。并且在异步操作失败时，将异步操作报出的错误作为参数传递出去。</p>
</div><div class="tags"><a href="/tags/ES6/">ES6</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2017/10/11/Array-prototype-slice-call-obj/" class="pre">Array.prototype.slice.call(obj)</a><a href="/2017/09/25/CSS揭秘/" class="next">CSS揭秘</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-let和const命令"><span class="toc-text">1.let和const命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#let"><span class="toc-text">let</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#块级作用域"><span class="toc-text">块级作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-声明一个只读的常量"><span class="toc-text">const 声明一个只读的常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES6声明对象的六种方法"><span class="toc-text">ES6声明对象的六种方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#顶层对象的属性"><span class="toc-text">顶层对象的属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-变量的结构赋值"><span class="toc-text">2.变量的结构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数组的解构赋值"><span class="toc-text">数组的解构赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象的解构赋值"><span class="toc-text">对象的解构赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串的解构赋值"><span class="toc-text">字符串的解构赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#圆括号的问题"><span class="toc-text">圆括号的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量解构赋值的用途"><span class="toc-text">变量解构赋值的用途</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-字符串的扩展"><span class="toc-text">3.字符串的扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-正则的扩展"><span class="toc-text">4.正则的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-RegExp构造函数"><span class="toc-text">1.RegExp构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-字符串的正则方法"><span class="toc-text">2.字符串的正则方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-u修饰符"><span class="toc-text">3.u修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#y修饰符—“粘连”（sticky）修饰符"><span class="toc-text">y修饰符—“粘连”（sticky）修饰符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-数值的扩展"><span class="toc-text">5.数值的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-二进制和八进制表示法："><span class="toc-text">1.二进制和八进制表示法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Number-isFinite-Number-isNaN"><span class="toc-text">2.Number.isFinite(), Number.isNaN()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Number-parseInt-Number-parseFloat"><span class="toc-text">3.Number.parseInt(), Number.parseFloat()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Number-isInteger-判断一个值是否为整数"><span class="toc-text">4.Number.isInteger()判断一个值是否为整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Number-EPSILON"><span class="toc-text">5.Number.EPSILON</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Math对象的扩展"><span class="toc-text">6.Math对象的扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Math-signbit-判断值是否是负值（包括-0，判断符号位）"><span class="toc-text">7.Math.signbit()判断值是否是负值（包括-0，判断符号位）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-指数运算符"><span class="toc-text">8.指数运算符**</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-integer数据类型"><span class="toc-text">9.integer数据类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-函数的扩展"><span class="toc-text">6.函数的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-函数参数的默认值"><span class="toc-text">1.函数参数的默认值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-函数的length属性"><span class="toc-text">2.函数的length属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-rest参数"><span class="toc-text">3.rest参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-严格模式"><span class="toc-text">4.严格模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-name属性"><span class="toc-text">5.name属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-箭头函数"><span class="toc-text">6.箭头函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-绑定this"><span class="toc-text">7.绑定this</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-尾调用优化"><span class="toc-text">8.尾调用优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-数组的扩展"><span class="toc-text">7.数组的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-扩展运算符spread（…）"><span class="toc-text">1.扩展运算符spread（…）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Array-from"><span class="toc-text">2.Array.from</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Array-of"><span class="toc-text">3.Array.of</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-数组实例的copyWithin"><span class="toc-text">4.数组实例的copyWithin()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-数组实例的find-和findIndex"><span class="toc-text">5.数组实例的find()和findIndex()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-数组实例的fill"><span class="toc-text">6.数组实例的fill()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-数组实例的-entries-keys-values"><span class="toc-text">7.数组实例的    entries(),keys(),values()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-数组实例的-includes"><span class="toc-text">8.数组实例的    includes()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-数组的空位"><span class="toc-text">9.数组的空位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-对象的扩展"><span class="toc-text">8.对象的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-属性的简洁表示法"><span class="toc-text">1.属性的简洁表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-属性名表达式"><span class="toc-text">2.属性名表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-方法的name属性"><span class="toc-text">3.方法的name属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Object-is-比较两个值是否严格相等"><span class="toc-text">4.Object.is()比较两个值是否严格相等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Object-assign-用于对象的合并"><span class="toc-text">5.Object.assign()用于对象的合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-属性的可枚举性和遍历"><span class="toc-text">6.属性的可枚举性和遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Object-getOwnPropertyDescriptors"><span class="toc-text">7.Object.getOwnPropertyDescriptors()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf"><span class="toc-text">8.proto 属性，Object.setPrototypeOf()，Object.getPrototypeOf()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-super关键字"><span class="toc-text">9.super关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-Object-keys-Object-values-Object-entries"><span class="toc-text">10.Object.keys(),Object.values(),Object.entries()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-symbol"><span class="toc-text">10.symbol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Set和Map数据结构"><span class="toc-text">11.Set和Map数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Set"><span class="toc-text">1.Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Set实例的属性和方法"><span class="toc-text">2.Set实例的属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-WeakSet"><span class="toc-text">3.WeakSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Map"><span class="toc-text">4.Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-WeakMap"><span class="toc-text">5.WeakMap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Proxy"><span class="toc-text">12.Proxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Reflect"><span class="toc-text">13.Reflect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-Promise对象"><span class="toc-text">14.Promise对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise基本用法"><span class="toc-text">Promise基本用法</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/05/NATAPP内网穿透/">NATAPP内网穿透与 webpack 一同食用出现invalid host header 问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/29/node版本升级/">node 版本升级</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/19/net/">.net</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/20/nginx centOS/">Nginx 安装使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/20/linux操作/">Linux使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/20/SSH连接/">SSH连接</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/20/nginx web服务器/">阿里云服务器nginx安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/17/git相关/">git相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/15/解决webstorm被限制读写权限的问题/">解决webstorm被限制读写权限的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/13/mac修改hostname/">mac修改hostname</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/">ES6</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linx/">Linx</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sass/">Sass</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/automated-testing/">automated testing</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/demo/">demo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/html/">html</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/jquery/">jquery</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/node/">node</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/webstorm/">webstorm</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/组件开发/" style="font-size: 15px;">组件开发</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/JSON/" style="font-size: 15px;">JSON</a> <a href="/tags/chrome快捷键/" style="font-size: 15px;">chrome快捷键</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/html/" style="font-size: 15px;">html</a> <a href="/tags/babel/" style="font-size: 15px;">babel</a> <a href="/tags/sass/" style="font-size: 15px;">sass</a> <a href="/tags/伪元素/" style="font-size: 15px;">伪元素</a> <a href="/tags/codepen/" style="font-size: 15px;">codepen</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/正则/" style="font-size: 15px;">正则</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.qingyun100.com/" title="青云100" target="_blank">青云100</a><ul></ul><a href="https://github.com/shleyZ" title="shleyZ" target="_blank">shleyZ</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">雪林.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>