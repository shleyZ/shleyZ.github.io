<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><meta name="keywords" content="from-end, shleyZ, key1, key2, key3"><title>javascript组件化 | 雪林的博客</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">javascript组件化</h1><a id="logo" href="/.">雪林的博客</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">javascript组件化</h1><div class="post-meta"><a href="/2017/10/28/javascript组件化/#comments" class="comment-count"></a><p><span class="date">Oct 28, 2017</span><span><a href="/categories/javascript/" class="category">javascript</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>文章来源于purplebamboo的博客：<a href="https://github.com/purplebamboo/blog/issues/16" target="_blank" rel="noopener">https://github.com/purplebamboo/blog/issues/16</a></p>
<p>作为一名前端工程师，写组件的能力至关重要。虽然javascript经常被人嘲笑是个小玩具，但是在一代代大牛的前仆后继的努力下，渐渐的也摸索了一套组件的编写方式。</p>
<p>下面我们来谈谈，在现有的知识体系下，如何很好的写组件。</p>
<p>比如我们要实现这样一个组件，就是一个输入框里面字数的计数。这个应该是个很简单的需求。</p>
<p><img src="http://ow3w1zm3t.bkt.clouddn.com/components.gif" alt="components"></p>
<p>我们来看看，下面的各种写法。</p>
<p>为了更清楚的演示，下面全部使用jQuery作为基础语言库。</p>
<h2 id="最简陋的写法"><a href="#最简陋的写法" class="headerlink" title="最简陋的写法"></a>最简陋的写法</h2><hr>
<p>嗯 所谓的入门级写法呢，就是完完全全的全局函数全局变量的写法。（就我所知，现在好多外包还是这种写法）</p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;test&lt;/title&gt;</span><br><span class="line">  &lt;script src=&quot;http://code.jquery.com/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    $(function() &#123;</span><br><span class="line"></span><br><span class="line">      var input = $(&apos;#J_input&apos;);</span><br><span class="line"></span><br><span class="line">      //用来获取字数</span><br><span class="line">      function getNum()&#123;</span><br><span class="line">        return input.val().length;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //渲染元素</span><br><span class="line">      function render()&#123;</span><br><span class="line">        var num = getNum();</span><br><span class="line"></span><br><span class="line">        //没有字数的容器就新建一个</span><br><span class="line">        if ($(&apos;#J_input_count&apos;).length == 0) &#123;</span><br><span class="line">          input.after(&apos;&lt;span id=&quot;J_input_count&quot;&gt;&lt;/span&gt;&apos;);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        $(&apos;#J_input_count&apos;).html(num+&apos;个字&apos;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //监听事件</span><br><span class="line">      input.on(&apos;keyup&apos;,function()&#123;</span><br><span class="line">        render();</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      //初始化，第一次渲染</span><br><span class="line">      render();</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;J_input&quot;/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>这段代码跑也是可以跑的，但是呢，各种变量混乱，没有很好的隔离作用域,当页面变的复杂的时候,会很难去维护。目前这种代码基本是用不了的。当然少数的活动页面可以简单用用。</p>
<h2 id="作用域隔离"><a href="#作用域隔离" class="headerlink" title="作用域隔离"></a>作用域隔离</h2><hr>
<p>让我们对上面的代码作些改动，使用单个变量模拟命名空间。</p>
<figure class="highlight plain"><figcaption><span>textCount </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  input:null,</span><br><span class="line">  init:function(config)&#123;</span><br><span class="line">    this.input = $(config.id);</span><br><span class="line">    this.bind();</span><br><span class="line">    //这边范围对应的对象，可以实现链式调用</span><br><span class="line">    return this;</span><br><span class="line">  &#125;,</span><br><span class="line">  bind:function()&#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    this.input.on(&apos;keyup&apos;,function()&#123;</span><br><span class="line">      self.render();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  getNum:function()&#123;</span><br><span class="line">    return this.input.val().length;</span><br><span class="line">  &#125;,</span><br><span class="line">  //渲染元素</span><br><span class="line">  render:function()&#123;</span><br><span class="line">    var num = this.getNum();</span><br><span class="line"></span><br><span class="line">    if ($(&apos;#J_input_count&apos;).length == 0) &#123;</span><br><span class="line">      this.input.after(&apos;&lt;span id=&quot;J_input_count&quot;&gt;&lt;/span&gt;&apos;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    $(&apos;#J_input_count&apos;).html(num+&apos;个字&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(function() &#123;</span><br><span class="line">  //在domready后调用</span><br><span class="line">  textCount.init(&#123;id:&apos;#J_input&apos;&#125;).render();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样一改造，立马变的清晰了很多，所有的功能都在一个变量下面。代码更清晰，并且有统一的入口调用方法。</p>
<p>但是还是有些瑕疵，这种写法没有私有的概念，比如上面的getNum,bind应该都是私有的方法。但是其他代码可以很随意的改动这些。当代码量特别特别多的时候，很容易出现变量重复，或被修改的问题。</p>
<p>于是又出现了一种函数闭包的写法：</p>
<figure class="highlight plain"><figcaption><span>TextCount </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  //私有方法，外面将访问不到</span><br><span class="line">  var _bind = function(that)&#123;</span><br><span class="line">    that.input.on(&apos;keyup&apos;,function()&#123;</span><br><span class="line">      that.render();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var _getNum = function(that)&#123;</span><br><span class="line">    return that.input.val().length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var TextCountFun = function(config)&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TextCountFun.prototype.init = function(config) &#123;</span><br><span class="line">    this.input = $(config.id);</span><br><span class="line">    _bind(this);</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  TextCountFun.prototype.render = function() &#123;</span><br><span class="line">    var num = _getNum(this);</span><br><span class="line"></span><br><span class="line">    if ($(&apos;#J_input_count&apos;).length == 0) &#123;</span><br><span class="line">      this.input.after(&apos;&lt;span id=&quot;J_input_count&quot;&gt;&lt;/span&gt;&apos;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    $(&apos;#J_input_count&apos;).html(num+&apos;个字&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line">  //返回构造函数</span><br><span class="line">  return TextCountFun;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">$(function() &#123;</span><br><span class="line">  new TextCount().init(&#123;id:&apos;#J_input&apos;&#125;).render();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这种写法，把所有的东西都包在了一个自动执行的闭包里面，所以不会受到外面的影响，并且只对外公开了TextCountFun构造函数，生成的对象只能访问到init,render方法。这种写法已经满足绝大多数的需求了。事实上大部分的jQuery插件都是这种写法。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><hr>
<p>上面的写法已经可以满足绝大多数需求了。</p>
<p>但是呢，当一个页面特别复杂，当我们需要的组件越来越多，当我们需要做一套组件。仅仅用这个就不行了。首先的问题就是，这种写法太灵活了，写单个组件还可以。如果我们需要做一套风格相近的组件，而且是多个人同时在写。那真的是噩梦。</p>
<p>在编程的圈子里，面向对象一直是被认为最佳的编写代码方式。比如java，就是因为把面向对象发挥到了极致，所以多个人写出来的代码都很接近，维护也很方便。但是很不幸的是，javascript不支持class类的定义。但是我们可以模拟。</p>
<p>下面我们先实现个简单的javascript类：</p>
<pre><code>var Class = (function() {
  var _mix = function(r, s) {
    for (var p in s) {
      if (s.hasOwnProperty(p)) {
        r[p] = s[p]
      }
    }
  }

  var _extend = function() {

    //开关 用来使生成原型时,不调用真正的构成流程init
    this.initPrototype = true
    var prototype = new this()
    this.initPrototype = false

    var items = Array.prototype.slice.call(arguments) || []
    var item

    //支持混入多个属性，并且支持{}也支持 Function
    while (item = items.shift()) {
      _mix(prototype, item.prototype || item)
    }


    // 这边是返回的类，其实就是我们返回的子类
    function SubClass() {
      if (!SubClass.initPrototype &amp;&amp; this.init)
        this.init.apply(this, arguments)//调用init真正的构造函数
    }

    // 赋值原型链，完成继承
    SubClass.prototype = prototype

    // 改变constructor引用
    SubClass.prototype.constructor = SubClass

    // 为子类也添加extend方法
    SubClass.extend = _extend

    return SubClass
  }
  //超级父类
  var Class = function() {}
  //为超级父类添加extend方法
  Class.extend = _extend

  return Class
})()
</code></pre><p>这是拿John Resig的class简单修改了下。</p>
<p>这边只是很简陋的实现了类的继承机制。如果对类的实现有兴趣可以参考我另一篇文章<a href="http://purplebamboo.github.io/2014/07/13/javascript-oo-class/" target="_blank" rel="noopener">javascript oo</a>实现<br>我们看下使用方法：</p>
<pre><code>//继承超级父类，生成个子类Animal，并且混入一些方法。这些方法会到Animal的原型上。
//另外这边不仅支持混入{}，还支持混入Function
var Animal = Class.extend({
  init:function(opts){
    this.msg = opts.msg
    this.type = &quot;animal&quot;
  },
  say:function(){
    alert(this.msg+&quot;:i am a &quot;+this.type)
  }
})

//继承Animal，并且混入一些方法
var Dog = Animal.extend({
  init:function(opts){
    //并未实现super方法，直接简单使用父类原型调用即可
    Animal.prototype.init.call(this,opts)
    //修改了type类型
    this.type = &quot;dog&quot;
  }
})

//new Animal({msg:&apos;hello&apos;}).say()

new Dog({msg:&apos;hi&apos;}).say()
</code></pre><p>使用很简单，超级父类具有extend方法，可以继承出一个子类。子类也具有extend方法。</p>
<p>这边要强调的是，继承的父类都是一个也就是单继承。但是可以通过extend实现多重混入。详见下面用法。</p>
<p>有了这个类的扩展，我们可以这么编写代码了：</p>
<pre><code>var TextCount = Class.extend({
  init:function(config){
    this.input = $(config.id);
    this._bind();
    this.render();
  },
  render:function() {
    var num = this._getNum();

    if ($(&apos;#J_input_count&apos;).length == 0) {
      this.input.after(&apos;&lt;span id=&quot;J_input_count&quot;&gt;&lt;/span&gt;&apos;);
    };

    $(&apos;#J_input_count&apos;).html(num+&apos;个字&apos;);

  },
  _getNum:function(){
    return this.input.val().length;
  },
  _bind:function(){
    var self = this;
    self.input.on(&apos;keyup&apos;,function(){
      self.render();
    });
  }
})

$(function() {
  new TextCount({
    id:&quot;#J_input&quot;
  });
})
</code></pre><p>这边可能还没看见class的真正好处，不急我们继续往下。</p>
<h2 id="抽象出base"><a href="#抽象出base" class="headerlink" title="抽象出base"></a>抽象出base</h2><hr>
<p>可以看到，我们的组件有些方法，是大部分组件都会有的。</p>
<p>比如init用来初始化属性。<br>比如render用来处理渲染的逻辑。<br>比如bind用来处理事件的绑定。<br>当然这也是一种约定俗成的规范了。如果大家全部按照这种风格来写代码，开发大规模组件库就变得更加规范，相互之间配合也更容易。</p>
<p>这个时候面向对象的好处就来了，我们抽象出一个Base类。其他组件编写时都继承它。</p>
<pre><code>var Base = Class.extend({
  init:function(config){
    //自动保存配置项
    this.__config = config
    this.bind()
    this.render()
  },
  //可以使用get来获取配置项
  get:function(key){
    return this.__config[key]
  },
  //可以使用set来设置配置项
  set:function(key,value){
    this.__config[key] = value
  },
  bind:function(){
  },
  render:function() {
  },
  //定义销毁的方法，一些收尾工作都应该在这里
  destroy:function(){

  }
})
</code></pre><p>base类主要把组件的一般性内容都提取了出来，这样我们编写组件时可以直接继承base类，覆盖里面的bind和render方法。</p>
<p>于是我们可以这么写代码：</p>
<pre><code>var TextCount = Base.extend({
  _getNum:function(){
    return this.get(&apos;input&apos;).val().length;
  },
  bind:function(){
    var self = this;
    self.get(&apos;input&apos;).on(&apos;keyup&apos;,function(){
      self.render();
    });
  },
  render:function() {
    var num = this._getNum();

    if ($(&apos;#J_input_count&apos;).length == 0) {
      this.get(&apos;input&apos;).after(&apos;&lt;span id=&quot;J_input_count&quot;&gt;&lt;/span&gt;&apos;);
    };

    $(&apos;#J_input_count&apos;).html(num+&apos;个字&apos;);

  }
})

$(function() {
  new TextCount({
  //这边直接传input的节点了，因为属性的赋值都是自动的。
    input:$(&quot;#J_input&quot;)
  });
})
</code></pre><p>可以看到我们直接实现一些固定的方法，bind，render就行了。其他的base会自动处理（这里只是简单处理了配置属性的赋值）。</p>
<p>事实上，这边的init，bind，render就已经有了点生命周期的影子，但凡是组件都会具有这几个阶段，初始化，绑定事件，以及渲染。当然这边还可以加一个destroy销毁的方法，用来清理现场。</p>
<p>此外为了方便，这边直接变成了传递input的节点。因为属性赋值自动化了，一般来说这种情况下都是使用getter，setter来处理。这边就不详细展开了。</p>
<h2 id="引入事件机制（观察者模式）"><a href="#引入事件机制（观察者模式）" class="headerlink" title="引入事件机制（观察者模式）"></a>引入事件机制（观察者模式）</h2><hr>
<p>有了base应该说我们编写组件更加的规范化，体系化了。下面我们继续深挖。</p>
<p>还是上面的那个例子，如果我们希望输入字的时候超过5个字就弹出警告。该怎么办呢。</p>
<p>小白可能会说，那简单啊直接改下bind方法：</p>
<pre><code>var TextCount = Base.extend({
  ...
  bind:function(){
    var self = this;
    self.get(&apos;input&apos;).on(&apos;keyup&apos;,function(){
      if(self._getNum() &gt; 5){
        alert(&apos;超过了5个字了。。。&apos;)
      }
      self.render();
    });
  },
  ...
})
</code></pre><p>的确也是一种方法，但是太low了，代码严重耦合。当这种需求特别特别多，代码会越来越乱。</p>
<p>这个时候就要引入事件机制，也就是经常说的观察者模式。</p>
<p>注意这边的事件机制跟平时的浏览器那些事件不是一回事，要分开来看。<br>什么是观察者模式呢，官方的解释就不说了，直接拿这个例子来说。</p>
<p>想象一下base是个机器人会说话，他会一直监听输入的字数并且汇报出去（通知）。而你可以把耳朵凑上去，听着他的汇报（监听）。发现字数超过5个字了，你就做些操作。</p>
<p>所以这分为两个部分，一个是通知，一个是监听。</p>
<p>假设通知是 fire方法，监听是on。于是我们可以这么写代码：</p>
<pre><code>var TextCount = Base.extend({
  ...
  bind:function(){
    var self = this;
    self.get(&apos;input&apos;).on(&apos;keyup&apos;,function(){
      //通知,每当有输入的时候，就报告出去。
      self.fire(&apos;Text.input&apos;,self._getNum())
      self.render();
    });
  },
  ...
})

$(function() {
  var t = new TextCount({
    input:$(&quot;#J_input&quot;)
  });
  //监听这个输入事件
  t.on(&apos;Text.input&apos;,function(num){
    //可以获取到传递过来的值
    if(num&gt;5){
       alert(&apos;超过了5个字了。。。&apos;)
    }
  })
})
</code></pre><p>fire用来触发一个事件，可以传递数据。而on用来添加一个监听。这样组件里面只负责把一些关键的事件抛出来，至于具体的业务逻辑都可以添加监听来实现。没有事件的组件是不完整的。</p>
<p>下面我们看看怎么实现这套事件机制。</p>
<p>我们首先抛开base，想想怎么实现一个具有这套机制的类。</p>
<pre><code>//辅组函数，获取数组里某个元素的索引 index
var _indexOf = function(array,key){
  if (array === null) return -1
  var i = 0, length = array.length
  for (; i &lt; length; i++) if (array[i] === item) return i
  return -1
}

var Event = Class.extend({
  //添加监听
  on:function(key,listener){
    //this.__events存储所有的处理函数
    if (!this.__events) {
      this.__events = {}
    }
    if (!this.__events[key]) {
      this.__events[key] = []
    }
    if (_indexOf(this.__events,listener) === -1 &amp;&amp; typeof listener === &apos;function&apos;) {
      this.__events[key].push(listener)
    }

    return this
  },
  //触发一个事件，也就是通知
  fire:function(key){

    if (!this.__events || !this.__events[key]) return

    var args = Array.prototype.slice.call(arguments, 1) || []

    var listeners = this.__events[key]
    var i = 0
    var l = listeners.length

    for (i; i &lt; l; i++) {
      listeners[i].apply(this,args)
    }

    return this
  },
  //取消监听
  off:function(key,listener){

    if (!key &amp;&amp; !listener) {
      this.__events = {}
    }
    //不传监听函数，就去掉当前key下面的所有的监听函数
    if (key &amp;&amp; !listener) {
      delete this.__events[key]
    }

    if (key &amp;&amp; listener) {
      var listeners = this.__events[key]
      var index = _indexOf(listeners, listener)

      (index &gt; -1) &amp;&amp; listeners.splice(index, 1)
    }

    return this;
  }
})


var a = new Event()

//添加监听 test事件
a.on(&apos;test&apos;,function(msg){
  alert(msg)
})

//触发 test事件
a.fire(&apos;test&apos;,&apos;我是第一次触发&apos;)
a.fire(&apos;test&apos;,&apos;我又触发了&apos;)

a.off(&apos;test&apos;)

a.fire(&apos;test&apos;,&apos;你应该看不到我了&apos;)
</code></pre><p>实现起来并不复杂，只要使用this.__events存下所有的监听函数。在fire的时候去找到并且执行就行了。</p>
<p>这个时候面向对象的好处就来了，如果我们希望base拥有事件机制。只需要这么写:</p>
<pre><code>var Base = Class.extend(Event,{
  ...
  destroy:function(){
    //去掉所有的事件监听
    this.off()
  }
})
//于是可以
//var a  = new Base()
// a.on(xxx,fn)
//
// a.fire()
</code></pre><p>是的只要extend的时候多混入一个Event，这样Base或者它的子类生成的对象都会自动具有事件机制。</p>
<p>有了事件机制我们可以把组件内部很多状态暴露出来，比如我们可以在set方法中抛出一个事件，这样每次属性变更的时候我们都可以监听到。</p>
<p>到这里为止，我们的base类已经像模像样了，具有了init，bind，render，destroy方法来表示组件的各个关键过程，并且具有了事件机制。基本上已经可以很好的来开发组件了。</p>
<h2 id="更进一步，richbase"><a href="#更进一步，richbase" class="headerlink" title="更进一步，richbase"></a>更进一步，richbase</h2><hr>
<p>我们还可以继续深挖。看看我们的base，还差些什么。首先浏览器的事件监听还很落后，需要用户自己在bind里面绑定，再然后现在的TextCount里面还存在dom操作，也没有自己的模板机制。这都是需要扩展的，于是我们在base的基础上再继承出一个richbase用来实现更完备的组件基类。</p>
<p>主要实现这些功能：</p>
<p>事件代理：不需要用户自己去找dom元素绑定监听，也不需要用户去关心什么时候销毁。<br>模板渲染：用户不需要覆盖render方法，而是覆盖实现setUp方法。可以通过在setUp里面调用render来达到渲染对应html的目的。<br>单向绑定：通过setChuckdata方法，更新数据，同时会更新html内容，不再需要dom操作。<br>我们看下我们实现richbase后怎么写组件：</p>
<pre><code>var TextCount = RichBase.extend({
  //事件直接在这里注册，会代理到parentNode节点，parentNode节点在下面指定
  EVENTS:{
    //选择器字符串，支持所有jQuery风格的选择器
    &apos;input&apos;:{
      //注册keyup事件
      keyup:function(self,e){
        //单向绑定，修改数据直接更新对应模板
        self.setChuckdata(&apos;count&apos;,self._getNum())

      }
    }
  },
  //指定当前组件的模板
  template:&apos;&lt;span id=&quot;J_input_count&quot;&gt;&lt;%= count %&gt;个字&lt;/span&gt;&apos;,
  //私有方法
  _getNum:function(){
    return this.get(&apos;input&apos;).val().length || 0
  },
  //覆盖实现setUp方法，所有逻辑写在这里。最后可以使用render来决定需不需要渲染模板
  //模板渲染后会append到parentNode节点下面，如果未指定，会append到document.body
  setUp:function(){
    var self = this;

    var input = this.get(&apos;parentNode&apos;).find(&apos;#J_input&apos;)
    self.set(&apos;input&apos;,input)

    var num = this._getNum()
    //赋值数据，渲染模板，选用。有的组件没有对应的模板就可以不调用这步。
    self.render({
      count:num
    })

  }
})

$(function() {
  //传入parentNode节点，组件会挂载到这个节点上。所有事件都会代理到这个上面。
  new TextCount({
    parentNode:$(&quot;#J_test_container&quot;)
  });
})

/**对应的html,做了些修改，主要为了加上parentNode，这边就是J_test_container

&lt;div id=&quot;J_test_container&quot;&gt;
  &lt;input type=&quot;text&quot; id=&quot;J_input&quot;/&gt;
&lt;/div&gt;

*/
</code></pre><p>看下上面的用法，可以看到变得更简单清晰了：</p>
<p>  1.事件不需要自己绑定，直接注册在EVENTS属性上。程序会自动将事件代理到parentNode上。<br>  2.引入了模板机制，使用template规定组件的模板，然后在setUp里面使用render(data)的方式渲染模板，程序会自动帮你append到parentNode下面。<br>  3.单向绑定，无需操作dom，后面要改动内容，不需要操作dom，只需要调用setChuckdata(key,新的值)，选择性的更新某个数据，相应的html会自动重新渲染。<br>下面我们看下richebase的实现：</p>
<pre><code>var RichBase = Base.extend({
  EVENTS:{},
  template:&apos;&apos;,
  init:function(config){
    //存储配置项
    this.__config = config
    //解析代理事件
    this._delegateEvent()
    this.setUp()
  },
  //循环遍历EVENTS，使用jQuery的delegate代理到parentNode
  _delegateEvent:function(){
    var self = this
    var events = this.EVENTS || {}
    var eventObjs,fn,select,type
    var parentNode = this.get(&apos;parentNode&apos;) || $(document.body)

    for (select in events) {
      eventObjs = events[select]

      for (type in eventObjs) {
        fn = eventObjs[type]

        parentNode.delegate(select,type,function(e){
          fn.call(null,self,e)
        })
      }

    }

  },
  //支持underscore的极简模板语法
  //用来渲染模板，这边是抄的underscore的。非常简单的模板引擎，支持原生的js语法
  _parseTemplate:function(str,data){
    /**
     * http://ejohn.org/blog/javascript-micro-templating/
     * https://github.com/jashkenas/underscore/blob/0.1.0/underscore.js#L399
     */
    var fn = new Function(&apos;obj&apos;,
        &apos;var p=[],print=function(){p.push.apply(p,arguments);};&apos; +
        &apos;with(obj){p.push(\&apos;&apos; + str
            .replace(/[\r\t\n]/g, &quot; &quot;)
            .split(&quot;&lt;%&quot;).join(&quot;\t&quot;)
            .replace(/((^|%&gt;)[^\t]*)&apos;/g, &quot;$1\r&quot;)
            .replace(/\t=(.*?)%&gt;/g, &quot;&apos;,$1,&apos;&quot;)
            .split(&quot;\t&quot;).join(&quot;&apos;);&quot;)
            .split(&quot;%&gt;&quot;).join(&quot;p.push(&apos;&quot;)
            .split(&quot;\r&quot;).join(&quot;\\&apos;&quot;) +
        &quot;&apos;);}return p.join(&apos;&apos;);&quot;)
    return data ? fn(data) : fn
  },
  //提供给子类覆盖实现
  setUp:function(){
    this.render()
  },
  //用来实现刷新，只需要传入之前render时的数据里的key还有更新值，就可以自动刷新模板
  setChuckdata:function(key,value){
    var self = this
    var data = self.get(&apos;__renderData&apos;)

    //更新对应的值
    data[key] = value

    if (!this.template) return;
    //重新渲染
    var newHtmlNode = $(self._parseTemplate(this.template,data))
    //拿到存储的渲染后的节点
    var currentNode = self.get(&apos;__currentNode&apos;)
    if (!currentNode) return;
    //替换内容
    currentNode.replaceWith(newHtmlNode)

    self.set(&apos;__currentNode&apos;,newHtmlNode)

  },
  //使用data来渲染模板并且append到parentNode下面
  render:function(data){
    var self = this
    //先存储起来渲染的data,方便后面setChuckdata获取使用
    self.set(&apos;__renderData&apos;,data)

    if (!this.template) return;

    //使用_parseTemplate解析渲染模板生成html
    //子类可以覆盖这个方法使用其他的模板引擎解析
    var html = self._parseTemplate(this.template,data)

    var parentNode = this.get(&apos;parentNode&apos;) || $(document.body)

    var currentNode = $(html)
    //保存下来留待后面的区域刷新
    //存储起来，方便后面setChuckdata获取使用
    self.set(&apos;__currentNode&apos;,currentNode)
    parentNode.append(currentNode)
  },
  destroy:function(){

    var self = this
    //去掉自身的事件监听
    self.off()
    //删除渲染好的dom节点
    self.get(&apos;__currentNode&apos;).remove()
    //去掉绑定的代理事件
    var events = self.EVENTS || {}
    var eventObjs,fn,select,type
    var parentNode = self.get(&apos;parentNode&apos;)

    for (select in events) {
      eventObjs = events[select]

      for (type in eventObjs) {
        fn = eventObjs[type]

        parentNode.undelegate(select,type,fn)
      }

    }

  }
})
</code></pre><p>主要做了两件事，一个就是事件的解析跟代理，全部代理到parentNode上面。另外就是把render抽出来，用户只需要实现setUp方法。如果需要模板支持就在setUp里面调用render来渲染模板，并且可以通过setChuckdata来刷新模板，实现单向绑定。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><hr>
<p>有了richbase，基本上组件开发就没啥问题了。但是我们还是可以继续深挖下去。</p>
<p>比如组件自动化加载渲染，局部刷新，比如父子组件的嵌套，再比如双向绑定，再比如实现ng-click这种风格的事件机制。</p>
<p>当然这些东西已经不属于组件里面的内容了。再进一步其实已经是一个框架了。实际上最近比较流行的react，ploymer还有我们的brix等等都是实现了这套东西。受限于篇幅，这个以后有空再写篇文章详细分析下。</p>
<p>鉴于有人跟我要完整代码，其实上面都列出来了。好吧 那我就再整理下，放在github了包含具体的demo，请点<a href="https://github.com/purplebamboo/demo-richbase/tree/master/example" target="_blank" rel="noopener">这里</a>。不过仅仅作为理解使用最好不要用于生产环境。如果觉得有帮助就给我个star吧。</p>
</div><div class="tags"><a href="/tags/组件开发/">组件开发</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2017/11/25/python参数/" class="pre">python参数</a><a href="/2017/10/20/我的FCC项目/" class="next">我的FCC项目</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#最简陋的写法"><span class="toc-text">最简陋的写法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作用域隔离"><span class="toc-text">作用域隔离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象"><span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象出base"><span class="toc-text">抽象出base</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引入事件机制（观察者模式）"><span class="toc-text">引入事件机制（观察者模式）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更进一步，richbase"><span class="toc-text">更进一步，richbase</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结语"><span class="toc-text">结语</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/05/NATAPP内网穿透/">NATAPP内网穿透与 webpack 一同食用出现invalid host header 问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/29/node版本升级/">node 版本升级</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/19/net/">.net</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/20/nginx centOS/">Nginx 安装使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/20/linux操作/">Linux使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/20/SSH连接/">SSH连接</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/20/nginx web服务器/">阿里云服务器nginx安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/17/git相关/">git相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/15/解决webstorm被限制读写权限的问题/">解决webstorm被限制读写权限的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/13/mac修改hostname/">mac修改hostname</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/">ES6</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linx/">Linx</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sass/">Sass</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/automated-testing/">automated testing</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/demo/">demo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/html/">html</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/jquery/">jquery</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/node/">node</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/webstorm/">webstorm</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/组件开发/" style="font-size: 15px;">组件开发</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/JSON/" style="font-size: 15px;">JSON</a> <a href="/tags/chrome快捷键/" style="font-size: 15px;">chrome快捷键</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/html/" style="font-size: 15px;">html</a> <a href="/tags/babel/" style="font-size: 15px;">babel</a> <a href="/tags/sass/" style="font-size: 15px;">sass</a> <a href="/tags/伪元素/" style="font-size: 15px;">伪元素</a> <a href="/tags/codepen/" style="font-size: 15px;">codepen</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/正则/" style="font-size: 15px;">正则</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.qingyun100.com/" title="青云100" target="_blank">青云100</a><ul></ul><a href="https://github.com/shleyZ" title="shleyZ" target="_blank">shleyZ</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">雪林.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>